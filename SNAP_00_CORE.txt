CONTEXT GROUP: SNAP_00_CORE.txt
GENERATED AT: 2/8/2026, 8:05:50 PM


>>> FILE_START: src/stores.js
// src/stores.js
import { writable } from 'svelte/store';

// --- [NEW] CH·∫æ ƒê·ªò DEMO ---
export const isDemoMode = writable(false); 
// -------------------------

// QUAN TR·ªåNG: Ph·∫£i c√≥ ch·ªØ 'export' ·ªü ƒë·∫ßu d√≤ng n√†y
export const currentCluster = writable(null);
export const activeTab = writable('data-section');
export const isAdmin = writable(false); 
export const currentUser = writable(null);
export const feedbackList = writable([]);
export const userStats = writable([]); 
export const helpContent = writable({ data: '...', luyke: '...', sknv: '...', realtime: '...' });

// --- [S·ª¨A ƒê·ªîI] X·ª¨ L√ù L∆ØU TR·ªÆ M·∫™U NH·∫¨N X√âT (PERSISTENCE) ---
// Thay v√¨ kh·ªüi t·∫°o r·ªóng, ta ƒë·ªçc t·ª´ localStorage n·∫øu c√≥
let savedTemplates = { luyke: '', sknv: '', realtime: '' };
if (typeof localStorage !== 'undefined') {
    try {
        const raw = localStorage.getItem('composerTemplates');
        if (raw) savedTemplates = JSON.parse(raw);
    } catch (e) {
        console.error('L·ªói ƒë·ªçc m·∫´u nh·∫≠n x√©t t·ª´ localStorage:', e);
    }
}
export const composerTemplates = writable(savedTemplates);
// -------------------------------------------------------------

export const competitionNameMappings = writable({}); 
export const homeConfig = writable({ videoUrl: '', timeline: [], sliderImages: [], changelogs: [] });
export const danhSachNhanVien = writable([]);
export const ycxData = writable([]);
export const rawGioCongData = writable([]);
export const thuongNongData = writable([]);
export const thuongERPData = writable([]);
export const pastedThiDuaReportData = writable([]);
export const realtimeYCXData = writable([]);
export const thiDuaVungChiTiet = writable([]);
export const thiDuaVungTong = writable([]);
export const ycxDataThangTruoc = writable([]);
export const thuongNongDataThangTruoc = writable([]);
export const thuongERPDataThangTruoc = writable([]);
export const masterReportData = writable({ luyke: [], sknv: [], realtime: [] });
export const competitionData = writable([]);
export const declarations = writable({ hinhThucXuat: '', hinhThucXuatGop: '', heSoQuyDoi: '' });
export const categoryStructure = writable([]); 
export const brandList = writable([]); 
export const specialProductList = writable([]);
export const macroCategoryConfig = writable([]); 
export const macroProductGroupConfig = writable([]); 
export const categoryNameMapping = writable({}); 
export const groupNameMapping = writable({});
export const brandNameMapping = writable({}); 
export const localCompetitionConfigs = writable([]); 
export const globalCompetitionConfigs = writable([]); 
export const globalSpecialPrograms = writable([]); 
export const efficiencyConfig = writable([]); 
export const qdcConfigStore = writable([]);
export const warehouseCustomMetrics = writable([]);
export const customRevenueTables = writable([]);
export const customPerformanceTables = writable([]);

// --- [LOGGING SECTION] QU·∫¢N L√ù M·ª§C TI√äU (KPI) ---
let savedKpi = null;
if (typeof localStorage !== 'undefined') {
    const raw = localStorage.getItem('kpiStore_cache');
    console.log(`[STORE ${new Date().toLocaleTimeString()}] Raw LocalStorage:`, raw);
    savedKpi = raw ? JSON.parse(raw) : null;
}

export const kpiStore = writable(savedKpi || {
    targets: {}, 
    globalSettings: {} 
});

kpiStore.subscribe(value => {
    // console.log('[STORE] KPI Update:', value); // Uncomment n·∫øu mu·ªën log chi ti·∫øt thay ƒë·ªïi
    if (typeof localStorage !== 'undefined') {
        localStorage.setItem('kpiStore_cache', JSON.stringify(value));
    }
});
// -----------------------------------------------------

export const luykeGoalSettings = writable({});
export const realtimeGoalSettings = writable({});
export const highlightSettings = writable({ luyke: {}, sknv: {}, realtime: {} });
export const debugInfo = writable({});
export const employeeMaNVMap = writable(new Map());
export const employeeNameToMaNVMap = writable(new Map());
export const charts = writable({});
export const choices = writable({
    luyke_employee: null, luyke_date_picker: null, luyke_highlight_nhanhang: null, luyke_highlight_nhomhang: null, luyke_highlight_employee: null,
    sknv_employee: null, sknv_date_picker: null, sknv_highlight_nhanhang: null, sknv_highlight_nhomhang: null, sknv_highlight_employee: null,
    realtime_employee: null, realtime_highlight_nhanhang: null, realtime_highlight_nhomhang: null, realtime_highlight_employee: null,
    thiDuaVung_sieuThi: null,
    competition_group: null,
    competition_brand: null,
    special_program_group: null, 
    thidua_employee_detail: null,
    realtime_brand_category_filter: null,
    realtime_brand_filter: null,
});
export const viewingDetailFor = writable(null);
export const sortState = writable({});
export const warehouseList = writable([]);
export const selectedWarehouse = writable(null);
export const drawerState = writable({ activeDrawer: null });
export const modalState = writable({ activeModal: null });
export const notificationStore = writable({ message: '', type: 'info', visible: false });
export const interfaceSettings = writable({
    contrastLevel: '3', globalFontSize: '18', kpiFontSize: '36',
    kpiCard1Bg: '#38bdf8', kpiCard2Bg: '#34d399', kpiCard3Bg: '#fbbf24',
    kpiCard4Bg: '#2dd4bf', kpiCard5Bg: '#a78bfa', kpiCard6Bg: '#f472b6',
    kpiCard7Bg: '#818cf8', kpiCard8Bg: '#f87171',
    kpiTitleColor: '#ffffff', kpiMainColor: '#ffffff', kpiSubColor: '#ffffff'
});
export const firebaseStore = writable({ app: null, auth: null, db: null, storage: null });
export const fileSyncState = writable({});
<<< FILE_END: src/stores.js

>>> FILE_START: src/main.js
// src/main.js
// Version 5.2 - Fix Demo Mode Conflict & Crash Guard
import './app.css'
import App from './App.svelte'
import { mount } from 'svelte'
import { firebaseService } from './services/firebase.service.js';
import feather from 'feather-icons';
import './services/employeeService.js'; 
import { authService as auth } from './services/auth.service.js'; 
import { dataService } from './services/dataService.js'; 
import { analyticsService } from './services/analytics.service.js';

async function initializeApp() {
  try {
    // 1. Kh·ªüi t·∫°o Firebase
    firebaseService.initCore();
    
    // 2. Setup Feather Icons (Global)
    window.feather = feather;

    // 3. Mount App
    mount(App, {
        target: document.getElementById('app'),
    });

    // [FIX] G·ªçi replace ngay sau khi mount ƒë·ªÉ ƒë·∫£m b·∫£o icon l·∫ßn ƒë·∫ßu
    setTimeout(() => {
        if (window.feather) window.feather.replace();
    }, 100);

    // 4. B·∫Øt ƒë·∫ßu lu·ªìng d·ªØ li·ªáu
    startDataFlow();

  } catch (e) {
    console.error("L·ªói kh·ªüi t·∫°o:", e);
    // [FIX] Fallback n·∫øu crash: Hi·ªÉn th·ªã th√¥ng b√°o l·ªói th√¢n thi·ªán
    const appEl = document.getElementById('app');
    if (appEl) {
        appEl.innerHTML = `<div style="padding: 20px; color: #dc2626; font-family: sans-serif;">
            <h3>‚ö†Ô∏è H·ªá th·ªëng g·∫∑p s·ª± c·ªë kh·ªüi ƒë·ªông.</h3>
            <p>${e.message}</p>
            <button onclick="localStorage.removeItem('isDemoMode'); location.reload()" style="padding: 8px 16px; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer;">
                Tho√°t ch·∫ø ƒë·ªô Demo & T·∫£i l·∫°i
            </button>
        </div>`;
    }
  }
}

async function startDataFlow() {
    try {
        // [CRITICAL FIX] CH·ªêT CH·∫∂N CH·∫æ ƒê·ªò DEMO
        // N·∫øu ƒëang ch·∫°y Demo, TUY·ªÜT ƒê·ªêI KH√îNG k·∫øt n·ªëi Auth hay t·∫£i d·ªØ li·ªáu th·∫≠t
        if (localStorage.getItem('isDemoMode') === 'true') {
            console.log("üõë [Main] Ph√°t hi·ªán ch·∫ø ƒë·ªô Demo. ƒê√£ ch·∫∑n lu·ªìng d·ªØ li·ªáu th·ª±c (Real Data Flow).");
            return; 
        }

        // --- LU·ªíNG CH√çNH TH·ª®C (CH·ªà CH·∫†Y KHI KH√îNG PH·∫¢I DEMO) ---
        await auth.ensureAnonymousAuth();
        const isLoggedIn = auth.initAuth();
        
        if (isLoggedIn) {
            console.log("[Main] User logged in. Starting real data load sequence...");
            await dataService.loadAllFromCache();
            
            const email = localStorage.getItem('userEmail');
            if(email) analyticsService.upsertUserRecord(email);
        } else {
            console.log("[Main] User not logged in. Data load deferred.");
        }

    } catch (e) {
        console.error("L·ªói lu·ªìng d·ªØ li·ªáu:", e);
    }
}

initializeApp();
<<< FILE_END: src/main.js

>>> FILE_START: src/App.svelte
<script>
  import { onMount, afterUpdate, tick } from 'svelte';
  import { 
      activeTab, 
      modalState, 
      efficiencyConfig, 
      customRevenueTables, 
      customPerformanceTables,
      isAdmin, 
      warehouseCustomMetrics,
      selectedWarehouse,
      danhSachNhanVien,
      warehouseList,
      isDemoMode
  } from './stores.js';
  import { get } from 'svelte/store';
  import { authService } from './services/auth.service.js';
  import { adminService } from './services/admin.service.js';
  import { datasyncService } from './services/datasync.service.js';
  import { demoService } from './services/demo.service.js';
  import { DEMO_SNAPSHOT } from './data/demoFixtures.js';

  // --- COMPONENTS CH√çNH ---
  import Sidebar from './components/Sidebar.svelte';
  import HomeSection from './components/HomeSection.svelte';
  import DataSection from './components/DataSection.svelte';
  import HealthSection from './components/HealthSection.svelte';
  import HealthEmployeeSection from './components/HealthEmployeeSection.svelte';
  import RealtimeSection from './components/realtime/RealtimeSection.svelte';
  import DeclarationSection from './components/DeclarationSection.svelte';
  // --- COMMON UI ---
  import GlobalNotification from './components/common/GlobalNotification.svelte';
  import VersionManager from './components/common/VersionManager.svelte';
  // --- DRAWERS ---
  import InterfaceDrawer from './components/drawers/InterfaceDrawer.svelte';
  import GoalDrawer from './components/drawers/GoalDrawer.svelte';
  // --- MODALS ---
  import AdminModal from './components/modals/AdminModal.svelte';
  import LoginModal from './components/modals/LoginModal.svelte';
  import UserCompetitionModal from './components/modals/UserCompetitionModal.svelte';
  import UserSpecialProgramModal from './components/modals/UserSpecialProgramModal.svelte';
  import ComposerModal from './components/modals/composer/ComposerModal.svelte';
  import AddEfficiencyColumnModal from './components/modals/AddEfficiencyColumnModal.svelte';
  import AddRevenueTableModal from './components/modals/AddRevenueTableModal.svelte';
  import AddPerformanceTableModal from './components/modals/AddPerformanceTableModal.svelte';
  import UnexportedDetailModal from './components/modals/UnexportedDetailModal.svelte';
  import CustomerDetailModal from './components/modals/CustomerDetailModal.svelte';
  // import DemoWelcomeModal from './components/modals/DemoWelcomeModal.svelte'; // <-- [T·∫ÆT DEMO] Comment import

  // Ki·ªÉm tra localStorage ngay khi kh·ªüi t·∫°o
  // let isBootingDemo = typeof localStorage !== 'undefined' && localStorage.getItem('isDemoMode') === 'true';
  let isBootingDemo = false; // <-- [T·∫ÆT DEMO] Lu√¥n √©p v·ªÅ false ƒë·ªÉ ch·∫°y ch·∫ø ƒë·ªô th·∫≠t
  
  // N·∫øu ƒëang boot demo th√¨ ch∆∞a s·∫µn s√†ng (false)
  let isAppReady = !isBootingDemo;

  onMount(async () => {
    // [LOGIC PH√ÇN LU·ªíNG]
    if (isBootingDemo) {
        // --- LU·ªíNG 1: CH·∫æ ƒê·ªò DEMO (OFFLINE FIRST) ---
        await initDemoMode();
    } else {
        // --- LU·ªíNG 2: CH·∫æ ƒê·ªò TH·ª∞C (ONLINE) ---
        // ƒê·∫£m b·∫£o x√≥a c·ªù demo n·∫øu l·ª° c√≤n l∆∞u
        if (typeof localStorage !== 'undefined') localStorage.removeItem('isDemoMode');
        await initRealMode();
    }
  });

  // [FIX] H√†m kh·ªüi t·∫°o ri√™ng cho Demo - B·ªè qua Auth v√† Fetch Server
  async function initDemoMode() {
      console.log("üöÄ [Bootloader] ƒêang kh·ªüi ƒë·ªông ch·∫ø ƒë·ªô Demo...");
      isDemoMode.set(true);
      
      try {
          // 1. N·∫°p Snapshot
          await demoService.loadSnapshot(DEMO_SNAPSHOT);
          
          // 2. Ch·ªù Store c·∫≠p nh·∫≠t
          await tick();

          // 3. Ch·ªçn kho m·∫∑c ƒë·ªãnh t·ª´ d·ªØ li·ªáu v·ª´a n·∫°p
          const currentList = get(danhSachNhanVien);
          if (currentList && currentList.length > 0) {
              const firstWarehouse = currentList[0].maKho || "908";
              selectedWarehouse.set(firstWarehouse);
              // C·∫≠p nh·∫≠t danh s√°ch kho cho Select Box
              warehouseList.set([firstWarehouse]); 
          } else {
              selectedWarehouse.set("908");
          }
          
          // 4. M·ªü kh√≥a giao di·ªán
          isAppReady = true;
          console.log("‚úÖ [Bootloader] Demo Ready -> Unlocking UI");

          // 5. Chuy·ªÉn Tab (Delay nh·∫π ƒë·ªÉ UI render xong)
          setTimeout(() => {
              activeTab.set('realtime-section');
          }, 200);

      } catch (e) {
          console.error("‚ùå L·ªói n·∫°p Demo:", e);
          alert("Kh√¥ng th·ªÉ n·∫°p d·ªØ li·ªáu Demo. Vui l√≤ng th·ª≠ l·∫°i.");
          // Fallback v·ªÅ ch·∫ø ƒë·ªô th·∫≠t n·∫øu l·ªói
          localStorage.removeItem('isDemoMode');
          window.location.reload();
      }
  }

  // [FIX] H√†m kh·ªüi t·∫°o cho App th·∫≠t
  async function initRealMode() {
      try { 
          await authService.ensureAnonymousAuth(); 
      } catch (e) { 
          console.error("Firebase Auth Error:", e); 
      }
      
      const isLoggedIn = authService.initAuth();
      if (!isLoggedIn) modalState.update(s => ({ ...s, activeModal: 'login-modal' }));

      // Load c·∫•u h√¨nh t·ª´ Server (Ch·ªâ ch·∫°y ·ªü ch·∫ø ƒë·ªô th·∫≠t)
      await loadGlobalSystemConfig();
      await loadInitialTables();
      
      // M·ªü kh√≥a giao di·ªán ngay l·∫≠p t·ª©c
      isAppReady = true;
  }

  // H√†m t·∫£i c·∫•u h√¨nh h·ªá th·ªëng (CH·ªà D√ôNG CHO REAL MODE)
  async function loadGlobalSystemConfig() {
      try {
          await Promise.all([
              adminService.loadCategoryDataFromFirestore(),
              adminService.loadEfficiencyConfig(),
              adminService.loadSpecialProductList(),
              adminService.loadHomeConfig()       
          ]);
      } catch (error) {
          console.error("[App] L·ªói t·∫£i c·∫•u h√¨nh h·ªá th·ªëng:", error);
      }
  }

  async function loadInitialTables() {
     const sysTables = await adminService.loadSystemPerformanceTables();
     customPerformanceTables.set(sysTables);
  }

  afterUpdate(() => {
    if (window.feather) window.feather.replace();
  });

  function handleSaveEffConfig(event) {
      const newItem = { ...event.detail };
      if ($activeTab === 'declaration-section') {
          newItem.isSystem = true;
          efficiencyConfig.update(items => {
              const idx = items.findIndex(i => i.id === newItem.id);
              if (idx >= 0) { items[idx] = newItem; return [...items]; } 
              else { return [...items, newItem]; }
          });
          adminService.saveEfficiencyConfig(get(efficiencyConfig));
      } 
      else {
          newItem.isSystem = false;
          let currentLocal = get(warehouseCustomMetrics) || [];
          const idx = currentLocal.findIndex(i => i.id === newItem.id);
          if (idx >= 0) {
              currentLocal[idx] = newItem;
          } else {
              currentLocal = [...currentLocal, newItem];
          }
          warehouseCustomMetrics.set(currentLocal);
          const wh = get(selectedWarehouse);
          if(wh) {
               datasyncService.saveCustomMetrics(wh, currentLocal);
          } else {
              alert("Vui l√≤ng ch·ªçn Kho ƒë·ªÉ l∆∞u ch·ªâ s·ªë n√†y.");
          }
      }
  }

  async function handleSaveCustomTable(event) {
      const newItem = event.detail;
      customRevenueTables.update(items => {
          const idx = items.findIndex(i => i.id === newItem.id);
          if (idx >= 0) { 
              items[idx] = { ...items[idx], ...newItem }; 
              return [...items]; 
          } else { 
              return [...items, newItem]; 
          }
      });
      if (newItem.isSystem) {
          const currentSystemTables = get(customRevenueTables).filter(t => t.isSystem);
          await adminService.saveSystemRevenueTables(currentSystemTables);
          console.log("ƒê√£ l∆∞u b·∫£ng h·ªá th·ªëng l√™n Admin Cloud");
      } else {
          const currentPersonalTables = get(customRevenueTables).filter(t => !t.isSystem);
          localStorage.setItem('customRevenueTables', JSON.stringify(currentPersonalTables));
          const wh = get(selectedWarehouse);
          if (wh) {
              await datasyncService.savePersonalRevenueTables(wh, currentPersonalTables);
          }
          console.log("ƒê√£ l∆∞u b·∫£ng c√° nh√¢n");
      }
  }

  async function handleSavePerformanceTable(event) {
      const newItem = event.detail;
      customPerformanceTables.update(items => {
          const idx = items.findIndex(i => i.id === newItem.id);
          if (idx >= 0) {
              items[idx] = { ...items[idx], ...newItem };
              return [...items];
          } else {
             return [...items, newItem];
          }
      });
      if (newItem.isSystem) {
          const systemTables = get(customPerformanceTables).filter(t => t.isSystem);
          await adminService.saveSystemPerformanceTables(systemTables);
      } else {
          const personalTables = get(customPerformanceTables).filter(t => !t.isSystem);
          const wh = get(selectedWarehouse);
          if (wh) {
              await datasyncService.savePersonalPerformanceTables(wh, personalTables);
          } else {
              alert("Vui l√≤ng ch·ªçn Kho ƒë·ªÉ l∆∞u b·∫£ng c√° nh√¢n.");
          }
      }
  }

  const closeModal = () => modalState.update(s => ({ ...s, activeModal: null, payload: null }));

  $: {
      if ($danhSachNhanVien && $danhSachNhanVien.length > 0) {
          const uniqueWarehouses = [...new Set($danhSachNhanVien
              .map(nv => nv.maKho)
              .filter(k => k && String(k).trim() !== '')
          )].sort();
          warehouseList.set(uniqueWarehouses);
      }
  }

  function exitDemoMode() {
    if(confirm('B·∫°n c√≥ ch·∫Øc mu·ªën tho√°t ch·∫ø ƒë·ªô Demo?')) {
        isDemoMode.set(false);
        localStorage.removeItem('isDemoMode');
        window.location.reload();
    }
  }
</script>

<GlobalNotification />
<VersionManager />

<InterfaceDrawer />
<GoalDrawer />

<AdminModal />
<LoginModal />
<UserCompetitionModal />
<UserSpecialProgramModal />
<ComposerModal /> 

{#if $modalState.activeModal === 'unexported-detail-modal'}
    <UnexportedDetailModal 
        unexportedDetails={$modalState.payload?.unexportedDetails || []}
        on:close={closeModal}
    />
{/if}

{#if $modalState.activeModal === 'customer-detail-modal'}
    <CustomerDetailModal 
        customers={$modalState.payload?.customers || []}
        mucTieu={$modalState.payload?.mucTieu || {}}
        on:close={closeModal}
    />
{/if}

<AddRevenueTableModal 
    isOpen={$modalState.activeModal === 'add-revenue-table-modal'} 
    editItem={$modalState.payload}
    on:close={closeModal}
    on:save={handleSaveCustomTable}
/>

<AddPerformanceTableModal
    isOpen={$modalState.activeModal === 'add-performance-table-modal'}
    editItem={$modalState.payload}
    isSystem={$modalState.isSystem || false}
    on:close={closeModal}
    on:save={handleSavePerformanceTable}
/>

<AddEfficiencyColumnModal 
    isOpen={$modalState.activeModal === 'add-efficiency-modal'} 
    editItem={$modalState.payload}
    isAdmin={$activeTab === 'declaration-section'}
    on:close={closeModal}
    on:save={handleSaveEffConfig}
/>

{#if $isDemoMode}
<div class="fixed bottom-4 right-4 z-[9999] flex items-center gap-3 bg-indigo-900 text-white px-4 py-3 rounded-xl shadow-2xl border border-indigo-500 animate-bounce-in">
    <div class="flex flex-col">
        <span class="text-xs font-bold text-indigo-300 uppercase tracking-wider">M√¥i tr∆∞·ªùng</span>
        <span class="font-bold">ƒêANG CH·∫†Y DEMO</span>
    </div>
    <div class="h-8 w-[1px] bg-indigo-700 mx-1"></div>
    <button 
        on:click={exitDemoMode}
        class="bg-white text-indigo-900 px-3 py-1.5 rounded-lg text-sm font-bold hover:bg-gray-100 transition-colors"
    >
        Tho√°t
    </button>
</div>
{/if}

<div class="flex min-h-screen">
  <div id="sidebar-container">
    <Sidebar />
  </div>

  <main id="main-content">
    <div class="flex-1 p-6">
      <div class="max-w-full mx-auto">
        {#if isAppReady}
            <HomeSection activeTab={$activeTab} />
            <DataSection activeTab={$activeTab} />
            <HealthSection activeTab={$activeTab} />
            <HealthEmployeeSection activeTab={$activeTab} />
            <RealtimeSection activeTab={$activeTab} />
            <DeclarationSection activeTab={$activeTab} />
        {:else}
            <div class="flex flex-col items-center justify-center h-[80vh] text-gray-400">
                <svg class="animate-spin h-10 w-10 mb-4 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="font-medium">ƒêang thi·∫øt l·∫≠p m√¥i tr∆∞·ªùng Demo...</p>
            </div>
        {/if}
      </div>
    </div>
  </main>
</div> 

<div id="modal-force-update-container"></div>
<div id="modal-help-container"></div>
<div id="modal-chart-container"></div>
<div id="modal-preview-container"></div>
<div id="modal-selection-container"></div>
<div id="modal-customer-detail-container"></div>
<div id="modal-unexported-detail-container"></div>

<style>
  :global(#main-content) { 
    transition: margin-left 0.3s ease-in-out;
    margin-left: 68px; 
    min-width: 0;
    display: flex;
    flex-direction: column;
    flex: 1 1 0%;
  }

  :global(.page-header) { 
    display: flex; 
    flex-wrap: wrap; 
    justify-content: space-between; 
    align-items: center; 
    gap: 1rem; 
    margin-bottom: 1.5rem;
  }

  :global(.page-header__title) { 
    font-size: 1.75rem; 
    font-weight: 700; 
    color: #1f2937;
  }
  
  @keyframes bounceIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
  }
  .animate-bounce-in {
      animation: bounceIn 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards;
  }
</style>
<<< FILE_END: src/App.svelte

>>> FILE_START: src/config.js
// src/config.js
// Version 2.4 - Add Installment Sectors
// Ch·ª©a t·∫•t c·∫£ c√°c c·∫•u h√¨nh tƒ©nh c·ªßa ·ª©ng d·ª•ng.

export const config = {
    ADMIN_PASSWORD: "Linh3010", 
    COLUMN_MAPPINGS: {
        danhsachnv: {
            maKho: { required: true, displayName: 'M√£ Kho', aliases: ['m√£ kho', 'makho', 'kho'] },
            maNV: { required: true, displayName: 'M√£ Nh√¢n Vi√™n', aliases: ['m√£ nv', 'msnv', 'm√£ nh√¢n vi√™n', 'manv', 'm√£ s·ªë nh√¢n vi√™n'] },
            hoTen: { required: true, displayName: 'H·ªç v√† T√™n', aliases: ['h·ªç v√† t√™n', 't√™n nh√¢n vi√™n', 't√™n nv', 'h·ªç t√™n'] },
            boPhan: { required: true, displayName: 'B·ªô ph·∫≠n', aliases: ['b·ªô ph·∫≠n'] }
        },
        ycx: {
            ngayTao: { required: true, displayName: 'Ng√†y t·∫°o', aliases: ['ng√†y t·∫°o'] },
            ngayHenGiao: { required: false, displayName: 'Ng√†y h·∫πn giao', aliases: ['ng√†y h·∫πn giao'] },
            nguoiTao: { required: true, displayName: 'Ng∆∞·ªùi t·∫°o', aliases: ['ng∆∞·ªùi t·∫°o'] },
            thanhTien: { required: true, displayName: 'Gi√° b√°n', aliases: ['gi√° b√°n_1', 'gi√° b√°n'] },
            soLuong: { required: true, displayName: 'S·ªë l∆∞·ª£ng', aliases: ['sl b√°n', 's·ªë l∆∞·ª£ng'] },
            nhomHang: { required: true, displayName: 'Nh√≥m h√†ng', aliases: ['nh√≥m h√†ng'] },
            tenSanPham: { required: true, displayName: 'T√™n s·∫£n ph·∫©m', aliases: ['t√™n s·∫£n ph·∫©m'] },
            maSanPham: { required: true, displayName: 'M√£ s·∫£n ph·∫©m', aliases: ['m√£ s·∫£n ph·∫©m', 'masanpham', 'm√£ sp', 'product code'] },
            tenKhachHang: { required: true, displayName: 'T√™n kh√°ch h√†ng', aliases: ['t√™n kh√°ch h√†ng', 'tenkhachhang'] },
            nhaSanXuat: { required: true, displayName: 'Nh√† s·∫£n xu·∫•t', aliases: ['nh√† s·∫£n xu·∫•t', 'nhasanxuat'] },
            nganhHang: { required: true, displayName: 'Ng√†nh h√†ng', aliases: ['ng√†nh h√†ng'] },
            hinhThucXuat: { required: true, displayName: 'H√¨nh th·ª©c xu·∫•t', aliases: ['h√¨nh th·ª©c xu·∫•t'] },
            trangThaiThuTien: { required: true, displayName: 'Tr·∫°ng th√°i thu ti·ªÅn', aliases: ['tr·∫°ng th√°i thu ti·ªÅn'] },
            trangThaiHuy: { required: true, displayName: 'Tr·∫°ng th√°i h·ªßy', aliases: ['tr·∫°ng th√°i h·ªßy'] },
            tinhTrangTra: { required: true, displayName: 'T√¨nh tr·∫°ng tr·∫£', aliases: ['t√¨nh tr·∫°ng nh·∫≠p tr·∫£ c·ªßa s·∫£n ph·∫©m ƒë·ªïi v·ªõi s·∫£n ph·∫©m ch√≠nh', 't√¨nh tr·∫°ng tr·∫£'] },
            trangThaiXuat: { required: true, displayName: 'Tr·∫°ng th√°i xu·∫•t', aliases: ['tr·∫°ng th√°i xu·∫•t'] }
        },
        giocong: {
            maNV: { required: false, displayName: 'M√£ NV', aliases: ['m√£ nv', 'msnv'] },
            hoTen: { required: false, displayName: 'T√™n NV', aliases: ['t√™n nv', 'tennv'] },
            tongGioCong: { required: true, displayName: 'T·ªïng gi·ªù c√¥ng', aliases: ['t·ªïng gi·ªù c√¥ng (x.nh·∫≠n) total', 't·ªïng gi·ªù c√¥ng'] }
        },
        thuongnong: {
            maNV: { required: false, displayName: 'M√£ NV', aliases: ['manv', 'm√£ nv'] },
            hoTen: { required: false, displayName: 'T√™n NV', aliases: ['tennv', 't√™n nv'] },
            diemThuong: { required: true, displayName: 'ƒêi·ªÉm th∆∞·ªüng', aliases: ['diemthuong', 'ƒëi·ªÉm th∆∞·ªüng'] }
        }
    },
    PRODUCT_GROUPS: {
        ICT: ['1491', '931', '42'],
        CE: ['1097', '1098', '1099', '1094', '894'],
        PHU_KIEN: ['16', '1394', '184', '764'],
        GIA_DUNG: ['484', '1214'],
        MAY_LOC_NUOC: ['4171', '4172'],
        PIN_SDP: '12',
        CAMERA_TRONG_NHA: '6479',
        CAMERA_NGOAI_TROi: '4219',
        TAI_NGHE_BLT: '4540',
        NOI_CHIEN: '4099',
        ROBOT_HB: '4439',
        TIVI: '1094',
        TU_LANH: '1097',
        MAY_GIAT: '1099',
        MAY_LANH: '1098',
        DIEN_THOAI: ['13', '1491', '18'],
        LAPTOP: '42',
        SIM: ['1891', '664'],
        VAS: ['164', '571'],
        BAO_HIEM_VAS: ['4479', '4499'],
        SMARTPHONE: ['1491', '18', '13'],
        BAO_HIEM_DENOMINATOR: ['1491', '1097', '894', '1099', '1098', '42', '1094', '3859', '911', '893', '3659'],
        QDC_GROUPS: {
            PIN_SDP: { codes: ['12'], name: 'Pin SDP' },
            TAI_NGHE_BLT: { codes: ['3346', '4540'], name: 'Tai nghe BLT' },
            DONG_HO: { codes: ['4059', '4060', '4061', '4062', '4063', '4064', '4070'], name: 'ƒê·ªìng h·ªì' },
            CAMERA: { codes: ['4219', '6479'], name: 'Camera' },
            LOA: { codes: ['1031', '1351', '4779'], name: 'Loa' },
            UDDD: { codes: ['571', '611'], name: 'UDDƒê' },
            BAO_HIEM: { codes: ['4479', '4499'], name: 'B·∫£o hi·ªÉm' },
            NOI_COM: { codes: ['4157', '4158'], name: 'N·ªìi c∆°m ƒëi·ªán t·ª≠ + cao t·∫ßn' },
            NOI_CHIEN: { codes: ['4099'], name: 'N·ªìi chi√™n' },
            MAY_LOC_NUOC: { codes: ['4171', '4172'], name: 'M√°y l·ªçc n∆∞·ªõc' },
            ROBOT_HB: { codes: ['4439'], name: 'Robot h√∫t b·ª•i' },
            SIM_ONLINE: { codes: ['1891'], name: 'SIM' }
        }
    },
    DEPARTMENT_GROUPS: [
        'BP T∆∞ V·∫•n - ƒêM',
        'BP Trang Tr√≠ ki√™m Thu ng√¢n - Sim S·ªë - ƒêM',
        'BP Kho Ki√™m H·ªó Tr·ª£ K·ªπ Thu·∫≠t Xe ƒê·∫°p - ƒêM'
    ],
    DEFAULT_DATA: {
        // [GENESIS ADD] Danh s√°ch M√£ Ng√†nh H√†ng ƒë∆∞·ª£c ph√©p hi·ªÉn th·ªã ·ªü tab Tr·∫£ G√≥p
        NGANH_HANG_TRA_GOP_ALLOW_LIST: [
            '484',  // ƒêi·ªán gia d·ª•ng
            '13',   // ƒêi·ªán tho·∫°i
            '244',  // Tablet
            '1754', // M√°y l·∫°nh, n∆∞·ªõc n√≥ng
            '304',  // ƒêi·ªán t·ª≠
            '1756', // M√°y gi·∫∑t, s·∫•y
            '1214', // Gia d·ª•ng l·∫Øp ƒë·∫∑t
            '1755', // T·ªß l·∫°nh, ƒë√¥ng, m√°t
            '1116', // M√°y l·ªçc n∆∞·ªõc
            '22',   // Laptop
            '1274', // ƒê·ªìng H·ªì Th·ªùi Trang
            '23'    // Wearable
        ],
        HINH_THUC_XUAT_TINH_DOANH_THU: [
            'Xu·∫•t b√°n h√†ng t·∫°i si√™u th·ªã', 'Xu·∫•t cung ·ª©ng d·ªãch v·ª•',
            'Xu·∫•t b√°n pre-order t·∫°i si√™u th·ªã', 'Xu·∫•t SIM tr·∫Øng k√®m theo SIM',
            'Xu·∫•t b√°n h√†ng ∆∞u ƒë√£i cho nh√¢n vi√™n', 'Xu·∫•t b√°n h√†ng t·∫°i si√™u th·ªã (TCƒêM)',
            'Xu·∫•t d·ªãch v·ª• b·∫£o h√†nh tr·ªçn ƒë·ªùi', 'Xu·∫•t d·ªãch v·ª• b·∫£o d∆∞·ª°ng tr·ªçn ƒë·ªùi',
            'Xu·∫•t b√°n h√†ng tr·∫£ g√≥p t·∫°i si√™u th·ªã', 'Xu·∫•t b√°n tr·∫£ g√≥p ∆∞u ƒë√£i cho nh√¢n vi√™n',
            'Xu·∫•t b√°n tr·∫£ g√≥p cho NV ph·ª•c v·ª• c√¥ng vi·ªác', 'Xu·∫•t b√°n pre-order tr·∫£ g√≥p t·∫°i si√™u th·ªã',
            'Xu·∫•t b√°n pre-order tr·∫£ g√≥p t·∫°i si√™u th·ªã (TCƒêM)',
            'Xu·∫•t d·ªãch v·ª• thu h·ªô b·∫£o hi·ªÉm'
        ],
        HINH_THUC_XUAT_TRA_GOP: ['Xu·∫•t b√°n h√†ng tr·∫£ g√≥p t·∫°i si√™u th·ªã', 'Xu·∫•t b√°n tr·∫£ g√≥p ∆∞u ƒë√£i cho nh√¢n vi√™n', 'Xu·∫•t b√°n tr·∫£ g√≥p cho NV ph·ª•c v·ª• c√¥ng vi·ªác', 'Xu·∫•t b√°n pre-order tr·∫£ g√≥p t·∫°i si√™u th·ªã', 'Xu·∫•t b√°n pre-order tr·∫£ g√≥p t·∫°i si√™u th·ªã (TCƒêM)'],
        HE_SO_QUY_DOI: { '1098 - M√°y l·∫°nh (IMEI)': 1,'4659 - Ph·ª• ki·ªán ti·ªán √≠ch Apple': 3.37,'6400 - Ph·ª• ki·ªán √¢m thanh Apple': 3.37,'2381 - Ph·ª• ki·ªán trang tr√≠ Apple': 3.37,'2011 - Khuy·∫øn m√£i - SP ·∫¢o': 1, '2511 - N·∫°p ti·ªÅn AirTime M_Service': 1, '2151 - Phi·∫øu mua h√†ng/Pre Order': 1, '971 - Th·∫ª c√†o ƒëi·ªán t·ª≠': 1, '431 - ·ªêp L∆∞ng - Flip Cover': 3.37, '2571 - Thu h·ªô c∆∞·ªõc Viettel': 1, '4519 - Thu H·ªô Ti·ªÅn Tr·∫£ G√≥p': 1, '2513 - Thu h·ªô Payoo': 1, '4302 - N√≥n b·∫£o hi·ªÉm c√°c lo·∫°i': 1.92, '2291 - Sim tr·∫Øng (Seri)': 1, '18 - ƒêi·ªán Tho·∫°i Di ƒê·ªông': 1, '4599 - Thu H·ªô Ti·ªÅn M·∫∑t': 1, '12 - Pin s·∫°c d·ª± ph√≤ng': 3.37, '571 - UDDƒê': 1, '58 - Mi·∫øng d√°n m·∫∑t sau': 3.37, '1231 - Mi·∫øng d√°n m·∫∑t tr∆∞·ªõc': 3.37, '1491 - Smartphone': 1, '1891 - Sim Online': 5.45, '4479 - D·ªãch V·ª• B·∫£o Hi·ªÉm': 4.18, '3359 - Ph·ª• ki·ªán ƒë·ªìng h·ªì': 3, '2391 - Smartwatch': 3, '911 - M√°y n∆∞·ªõc n√≥ng': 1, '4499 - Thu H·ªô Ph√≠ B·∫£o Hi·ªÉm': 4.18, '4142 - B√¨nh ƒëun si√™u t·ªëc': 1.85, '4153 - Xay Sinh t·ªë': 1.85, '15 - Tai nghe d√¢y': 3.37, '1412 - D·ªãch v·ª• b·∫£o tr√¨': 1, '3345 - C√°p': 3.37, '2312 - M√£ n·∫°p th·∫ª game': 1, '4900 - B√†n ph√≠m': 3.37, '4141 - B√†n ·ªßi kh√¥': 1.85, '4156 - N·ªìi c∆°m n·∫Øp g√†i/n·∫Øp r·ªùi': 1.85, '14 - S·∫°c/ Adapter': 3.37, '42 - Laptop': 1.2, '751 - Khuy·∫øn m√£i ba l√¥, t√∫i x√°ch': 1, '1031 - Loa di ƒë·ªông': 3.37, '4199 - Mi·∫øng D√°n K√≠nh': 3.37, '3346 - Tai Nghe Bluetooth': 3.37, '931 - M√°y t√≠nh b·∫£ng': 1.2, '19 - Khuy·∫øn m√£i ƒêTDƒê': 1, '10 - Chu·ªôt': 3.37, '4060 - ƒê·ªìng h·ªì Nam D√¢y da': 3, '880 - Loa Karaoke': 1.29, '851 - Khuy·∫øn m√£i ƒêi·ªán T·ª≠': 1, '4169 - L√µi l·ªçc': 1.85, '4540 - Tai Nghe Bluetooth - imei': 3.37, '4062 - ƒê·ªìng h·ªì N·ªØ D√¢y kim lo·∫°i': 3, '2831 - Ph·ª• ki·ªán Apple': 3.37, '2691 - B·ªô S·∫°c/C√°p/Adaptor (Gi√° R·∫ª)': 3.37, '1351 - Loa vi t√≠nh (imei)': 3.37, '1094 - Tivi LED (IMEI)': 1, '4324 - Khung treo, gi√° ƒë·ª°': 3.37, '1099 - M√°y gi·∫∑t (IMEI)': 1, '1097 - T·ªß l·∫°nh (IMEI)': 1, '4099 - N·ªìi chi√™n': 1.85, '4070 - ƒê·ªìng h·ªì Tr·∫ª em': 3, '967 - S·∫•y t√≥c': 1.85, '957 - L√≤ n∆∞·ªõng': 1.85, '958 - L√≤ vi s√≥ng': 1.85, '4158 - N·ªìi c∆°m ƒëi·ªán t·ª≠': 1.85, '3241 - Dao/K√©o/Th·ªõt': 1.92, '3240 - H·ªôp/H≈©': 1.92, '3265 - N·ªìi': 1.92, '4139 - ƒê√®n b√†n/ƒê√®n S·∫°c/ƒê√®n b·∫Øt mu·ªói': 1.85, '73 - Ph·ª• ki·ªán ƒëi·ªán m√°y': 3.37, '4171 - L·ªçc n∆∞·ªõc d·∫°ng t·ªß ƒë·ª©ng': 1.85, '3384 - ƒê·ªì ngh·ªÅ s·ª≠ d·ª•ng ƒëi·ªán': 1, '4147 - B·∫øp ƒëi·ªán ƒë∆°n': 1.85, '4063 - ƒê·ªìng h·ªì N·ªØ D√¢y da': 3, '3263 - Ch·∫£o': 1.92, '3185 - V·ªá sinh nh√† c·ª≠a': 1.92, '4143 - B√†n ·ªßi h∆°i n∆∞·ªõc ƒë·ª©ng': 1.85, '4146 - B·∫øp gas ƒë√¥i': 1.85, '1052 - Khuy·∫øn m√£i ƒêi·ªán L·∫°nh': 1, '3799 - Qu·∫°t ƒëi·ªÅu h√≤a': 1.85, '1951 - Software (s·ªë L∆∞·ª£ng)': 1, '6000 - M√°y √©p tr√°i c√¢y': 1.85, '4059 - ƒê·ªìng h·ªì Nam D√¢y kim lo·∫°i': 3, '4160 - Qu·∫°t b√†n/h·ªôp/s·∫°c': 1.85, '4162 - B√¨nh/Ca ƒë·ª±ng n∆∞·ªõc': 1.92, '4660 - Qu·∫°t l·ª≠ng': 1.85, '17 - Ph·ª• ki·ªán IT kh√°c': 3.37, '4145 - B·∫øp gas ƒë∆°n': 1.85, '875 - D√†n m√°y': 1, '1071 - Ph·ª• ki·ªán ƒëi·ªán t·ª≠': 3.37, '891 - Micro': 1, '4152 - ·ªî c·∫Øm ƒëi·ªán/v·ª£t mu·ªói': 1.85, '4154 - Xay √©p/Kh√°c': 1.85, '5975 - Balo T√∫i Ch·ªëng S·ªëc': 3.37, '893 - T·ªß ƒë√¥ng': 1, '2531 - Thu h·ªô Mservice': 1, '4019 - Sim tr·∫Øng ƒëi·ªán t·ª≠': 1, '4320 - ƒê·ªìng h·ªì - Khuy·∫øn m√£i mua': 1, '3187 - B√¨nh/Ly/Ca gi·ªØ nhi·ªát': 1.92, '4159 - Qu·∫°t ƒë·ª©ng': 1.85, '4157 - N·ªìi c∆°m cao t·∫ßn': 1.85, '16 - Th·∫ª Nh·ªõ': 3.37, '4140 - B√†n ·ªßi h∆°i n∆∞·ªõc': 1.85, '4150 - M√°y n∆∞·ªõc n√≥ng l·∫°nh': 1.85, '591 - Thay sim': 1, '2999 - D·ª•ng c·ª• nh√† b·∫øp kh√°c': 1.92, '4779 - Loa di ƒë·ªông - imei': 3.37, '4440 - G√≥i C∆∞·ªõc V√† D·ªãch V·ª• GTGT': 1, '4121 - M√°y B∆°m N∆∞·ªõc': 1, '4161 - Qu·∫°t treo': 1.85, '4961 - Qu·∫ßn b√≥ & legging n·ªØ Th·ªÉ Thao': 1, '4151 - √Åp su·∫•t/l·∫©u/chi√™n/n∆∞·ªõng': 1.85, '4144 - B·∫øp gas √¢m': 1.85, '871 - USB': 3.37, '6479 - Camera IP Trong nh√†': 3.37, '4219 - Camera IP Ngo√†i tr·ªùi': 3.37, '4659 - Ph·ª• ki·ªán ti·ªán √≠ch Apple': 3.37, '531 - Pin, 4095 - C√°p (Gi√° R·∫ª)': 3.37, '2791 - Kinh doanh m√πa v·ª•': 3.37, '2771 - Gi√° treo m√†n h√¨nh m√°y t√≠nh': 3.37, '80 - Khuy·∫øn m√£i Kh√°c': 1, '1131 - M√°y in, Fax': 2, '4125 - Smartband': 3, '743 - Qu·∫°t s∆∞·ªüi': 1.85, '4659 - Ph·ª• ki·ªán Apple - Imei': 3.37, '4064 - ƒê·ªìng h·ªì N·ªØ D√¢y kh√°c': 3, '956 - H√∫t b·ª•i': 1.85, '4172 - L·ªçc n∆∞·ªõc √¢m t·ªß/tr√™n b√†n': 1.85, '3779 - B·∫øp ƒëi·ªán √¢m': 1.85, '4061 - ƒê·ªìng h·ªì Nam D√¢y kh√°c': 3, '4067 - ƒê·ªìng h·ªì Unisex D√¢y kh√°c': 3, '1411 - D·ªãch v·ª• l·∫Øp ƒë·∫∑t': 1, '4149 - B√¨nh th·ªßy ƒëi·ªán': 1.85, '4148 - B·∫øp ƒëi·ªán ƒë√¥i': 1.85, '955 - H√∫t m√πi/ h√∫t kh√≥i': 1.85, '4699 - Gia d·ª•ng kh√¥ng ƒëi·ªán kh√°c': 1.92, '4859 - Xe ƒë·∫°p ƒë∆∞·ªùng ph·ªë c·ªï ƒëi·ªÉn': 1, '4759 - Ph·ª• Ki·ªán Xe ƒê·∫°p': 1, '2471 - Thu h·ªô c∆∞·ªõc VinaPhone': 1, '3719 - Qu·∫ßn d√†i n·ªØ Th·ªÉ Thao': 1, '1051 - Khuy·∫øn m√£i ƒêi·ªán gia d·ª•ng': 1, '3721 - Qu·∫ßn ng·∫Øn & v√°y n·ªØ Th·ªÉ Thao': 1, '410 - Ph·ª• ki·ªán TT kh√°c': 3.37, '4155 - H√∫t b·ª•i c√¢y': 1.85, '3563 - M√°y t√≠nh nguy√™n b·ªô': 1, '894 - T·ªß m√°t': 1, '3639 - M√°y l·ªçc kh√¥ng kh√≠': 1.85, '611 - ·ª®ng d·ª•ng PC & Laptop': 1, '4089 - ƒê·ªìng h·ªì Unisex D√¢y kim lo·∫°i': 3, '4439 - H√∫t B·ª•i Robot': 1.85, '3740 - √Åo T-shirt nam Th·ªÉ Thao': 1, '4339 - ·ªîn √Åp': 1, '4459 - Qu·∫°t Tr·∫ßn': 1.85, '2351 - Router - Imei': 3.37, '3159 - DV Internet v√† Truy·ªÅn h√¨nh thu ti·ªÅn': 1, '3659 - M√°y s·∫•y l·ªìng ngang': 1, '3519 - √Åo Bra Th·ªÉ Thao': 1, '3479 - Thi·∫øt b·ªã m·∫°ng kh√°c': 3.37, '3859 - M√°y r·ª≠a ch√©n': 1 }
    }
};
<<< FILE_END: src/config.js

>>> FILE_START: src/services/action.service.js
import { get } from 'svelte/store';
import { viewingDetailFor } from '../stores.js';
import { captureService } from './capture.service.js';
import { excelService } from './excel.service.js';

export const actionService = {
    // Helper: X√°c ƒë·ªãnh tab ƒëang active v√† container ch·ª©a n·ªôi dung
    _getActiveTabInfo(sectionId) {
        const navIdMap = {
            'luyke': 'luyke-subtabs-nav',
            'sknv': 'employee-subtabs-nav',
            'realtime': 'realtime-subtabs-nav'
        };
        const contentIdMap = {
            'luyke': 'luyke-subtabs-content',
            'sknv': 'employee-subtabs-content',
            'realtime': 'realtime-subtabs-content'
        };

        const navId = navIdMap[sectionId];
        const contentContainerId = contentIdMap[sectionId];

        if (!navId || !contentContainerId) {
            console.warn(`[ActionService] Kh√¥ng t√¨m th·∫•y map ID cho section: ${sectionId}`);
            return null;
        }

        const navEl = document.getElementById(navId);
        if (!navEl) return null;

        const activeBtn = navEl.querySelector('.sub-tab-btn.active'); 
        if (!activeBtn) return null;

        // [SAFETY] Fallback title n·∫øu thi·∫øu
        const title = activeBtn.dataset.title || activeBtn.innerText.replace(/\s/g, '') || 'BaoCao';

        return {
            button: activeBtn,
            targetId: activeBtn.dataset.target,
            title: title,
            contentContainerId: contentContainerId
        };
    },

    // [FIX CRITICAL] H√†m Capture ƒë∆∞·ª£c vi·∫øt l·∫°i ƒë·ªÉ ch·ªëng treo v√† x·ª≠ l√Ω logic view ph·ª©c t·∫°p
    async handleCapture(sectionId) {
        console.log(`[ActionService] ‚û§ B·∫Øt ƒë·∫ßu ch·ª•p ·∫£nh section: ${sectionId}`);
        
        try {
            const tabInfo = this._getActiveTabInfo(sectionId);
            if (!tabInfo) {
                throw new Error('Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c Tab ƒëang m·ªü. Vui l√≤ng t·∫£i l·∫°i trang.');
            }

            // 1. Logic x√°c ƒë·ªãnh ph·∫ßn t·ª≠ c·∫ßn ch·ª•p (Element Resolution)
            const currentDetail = get(viewingDetailFor);
            let elementToCapture = null;
            let title = tabInfo.title;

            if (currentDetail) {
                // ∆Øu ti√™n 1: ƒêang xem chi ti·∫øt nh√¢n vi√™n
                console.log('[ActionService] Mode: Detail View');
                elementToCapture = document.getElementById('health-staff-detail-view');
                title = `${tabInfo.title}_ChiTiet_${currentDetail.maNV}`;
            } else {
                // ∆Øu ti√™n 2: X·ª≠ l√Ω c√°c view ƒë·∫∑c bi·ªát (V√≠ d·ª•: Tab Thi ƒêua c√≥ view switcher)
                if (sectionId === 'sknv' && tabInfo.targetId === 'subtab-thidua') {
                    const activeViewBtn = document.querySelector('#sknv-thidua-view-selector .view-switcher__btn.active');
                    const viewType = activeViewBtn ? activeViewBtn.dataset.view : 'program';
                    
                    console.log(`[ActionService] Mode: ThiDua View (${viewType})`);
                    
                    if (viewType === 'program') {
                        elementToCapture = document.getElementById('competition-report-container-lk');
                    } else {
                        elementToCapture = document.getElementById('pasted-competition-report-container');
                    }
                } else {
                    // ∆Øu ti√™n 3: View m·∫∑c ƒë·ªãnh theo tab
                    elementToCapture = document.getElementById(tabInfo.targetId);
                }
            }

            // 2. Validate Element
            if (!elementToCapture) {
                console.error(`[ActionService] Element not found. TargetID: ${tabInfo.targetId}`);
                throw new Error('Kh√¥ng t√¨m th·∫•y b·∫£ng d·ªØ li·ªáu ƒë·ªÉ ch·ª•p.');
            }

            // [SAFETY] Ki·ªÉm tra k√≠ch th∆∞·ªõc th·∫≠t (Tr√°nh ch·ª•p v√πng tr·∫Øng/·∫©n)
            if (elementToCapture.offsetWidth === 0 || elementToCapture.offsetHeight === 0) {
                console.warn('[ActionService] Element k√≠ch th∆∞·ªõc 0x0. ƒêang b·ªã ·∫©n?');
                throw new Error('B·∫£ng d·ªØ li·ªáu ƒëang b·ªã ·∫©n ho·∫∑c ch∆∞a t·∫£i xong.');
            }

            // 3. Th·ª±c thi ch·ª•p (Safe Call)
            console.log(`[ActionService] G·ªçi service ch·ª•p cho element:`, elementToCapture);
            
            // [DEBUG & FIX] Ki·ªÉm tra method n√†o kh·∫£ d·ª•ng trong captureService
            if (typeof captureService.captureDashboardInParts === 'function') {
                await captureService.captureDashboardInParts(elementToCapture, title);
            } 
            else if (typeof captureService.capture === 'function') {
                // Fallback n·∫øu code c≈© d√πng .capture
                console.warn('[ActionService] captureDashboardInParts kh√¥ng t·ªìn t·∫°i, d√πng fallback .capture()');
                await captureService.capture(elementToCapture, title);
            }
            else {
                console.error('[ActionService] Available methods:', Object.keys(captureService));
                throw new Error('Service ch·ª•p ·∫£nh l·ªói: Kh√¥ng t√¨m th·∫•y h√†m captureDashboardInParts ho·∫∑c capture.');
            }
            
            console.log('[ActionService] ‚û§ Ch·ª•p ·∫£nh ho√†n t·∫•t.');

        } catch (error) {
            console.error('[ActionService] L·ªói ch·ª•p ·∫£nh:', error);
            alert('L·ªói: ' + (error.message || 'Kh√¥ng th·ªÉ ch·ª•p ·∫£nh.'));
        } finally {
            // [QUAN TR·ªåNG] ƒê·∫£m b·∫£o lu√¥n ch·∫°y ƒë·ªÉ UI component t·∫Øt loading
            console.log('[ActionService] ‚û§ K·∫øt th√∫c lu·ªìng Capture.');
            return; // Resolve promise
        }
    },

    // H√†m Export gi·ªØ nguy√™n logic nh∆∞ng th√™m log safety
    async handleExport(sectionId) {
        console.log(`[ActionService] ‚û§ B·∫Øt ƒë·∫ßu xu·∫•t Excel section: ${sectionId}`);
        try {
            const tabInfo = this._getActiveTabInfo(sectionId);
            if (!tabInfo) return;

            let activeTabContent;
            
            // Logic t√¨m n·ªôi dung t∆∞∆°ng t·ª± capture
            if (sectionId === 'sknv' && tabInfo.targetId === 'subtab-thidua') {
                 const activeViewBtn = document.querySelector('#sknv-thidua-view-selector .view-switcher__btn.active');
                 const viewType = activeViewBtn ? activeViewBtn.dataset.view : 'program';
                 activeTabContent = viewType === 'program' ? 
                    document.getElementById('competition-report-container-lk') : 
                    document.getElementById('pasted-competition-report-container');
            } else {
                // Logic c≈©: t√¨m .sub-tab-content kh√¥ng hidden
                activeTabContent = document.querySelector(`#${tabInfo.contentContainerId} .sub-tab-content:not(.hidden)`);
                // Fallback n·∫øu logic tr√™n kh√¥ng t√¨m th·∫•y (ƒë√¥i khi active class n·∫±m ·ªü ch·ªó kh√°c)
                if (!activeTabContent && tabInfo.targetId) {
                    activeTabContent = document.getElementById(tabInfo.targetId);
                }
            }

            if (activeTabContent) {
                const timestamp = new Date().toLocaleDateString('vi-VN').replace(/\//g, '-');
                await excelService.exportTableToExcel(activeTabContent, `${tabInfo.title}_${timestamp}`);
            } else {
                 alert('Kh√¥ng t√¨m th·∫•y n·ªôi dung ƒë·ªÉ xu·∫•t Excel.');
            }
        } catch (error) {
            console.error('[ActionService] L·ªói xu·∫•t Excel:', error);
            alert('L·ªói xu·∫•t Excel: ' + error.message);
        }
    }
};
<<< FILE_END: src/services/action.service.js

>>> FILE_START: src/services/admin.service.js
// src/services/admin.service.js
// Version 4.0 - Refactored into 'declarations' sub-services to avoid name conflict

import { configService } from './declarations/config.service.js';
import { categoryService } from './declarations/category.service.js';
import { performanceService } from './declarations/performance.service.js';

export const adminService = {
    // --- 1. HELP CONTENT ---
    saveHelpContent: configService.saveHelpContent,

    // --- 2. HOME CONFIG ---
    saveHomeConfig: configService.saveHomeConfig,
    loadHomeConfig: configService.loadHomeConfig,

    // --- 3. CATEGORY & BRAND STRUCTURE ---
    saveCategoryDataToFirestore: categoryService.saveCategoryDataToFirestore,
    loadCategoryDataFromFirestore: categoryService.loadCategoryDataFromFirestore,

    // --- 4. SYSTEM REVENUE TABLES ---
    loadSystemRevenueTables: performanceService.loadSystemRevenueTables,
    saveSystemRevenueTables: performanceService.saveSystemRevenueTables,

    // --- 4.5. SYSTEM PERFORMANCE TABLES ---
    loadSystemPerformanceTables: performanceService.loadSystemPerformanceTables,
    saveSystemPerformanceTables: performanceService.saveSystemPerformanceTables,

    // --- 5. MAPPINGS & CONFIGS GLOBAL ---
    loadMappingsGlobal: categoryService.loadMappingsGlobal,
    
    saveMacroCategoryConfig: categoryService.saveMacroCategoryConfig,
    loadMacroCategoryConfig: categoryService.loadMacroCategoryConfig,

    saveMacroProductGroupConfig: categoryService.saveMacroProductGroupConfig,
    loadMacroProductGroupConfig: categoryService.loadMacroProductGroupConfig,

    saveNameMapping: categoryService.saveNameMapping,
    saveCompetitionNameMappings: categoryService.saveCompetitionNameMappings,

    // --- 6. LOGIC & CALCULATION ---
    loadDeclarationsFromFirestore: performanceService.loadDeclarationsFromFirestore,
    saveDeclarationsToFirestore: performanceService.saveDeclarationsToFirestore,

    // --- 7. COMPETITION CONFIGS ---
    saveGlobalCompetitionConfigs: performanceService.saveGlobalCompetitionConfigs,
    loadGlobalCompetitionConfigs: performanceService.loadGlobalCompetitionConfigs,

    // --- 8. SPECIAL PRODUCTS ---
    saveSpecialProductList: categoryService.saveSpecialProductList,
    loadSpecialProductList: categoryService.loadSpecialProductList,
    loadGlobalSpecialPrograms: categoryService.loadGlobalSpecialPrograms,

    // --- 9. EFFICIENCY & QDC CONFIGS ---
    saveEfficiencyConfig: performanceService.saveEfficiencyConfig,
    loadEfficiencyConfig: performanceService.loadEfficiencyConfig,
    
    saveQdcConfig: performanceService.saveQdcConfig,
    loadQdcConfig: performanceService.loadQdcConfig,

    // --- 10. UPLOAD ---
    uploadImage: configService.uploadImage
};
<<< FILE_END: src/services/admin.service.js

>>> FILE_START: src/services/analytics.service.js
// src/services/analytics.service.js
// Version 2.2 - Full code implementation (Added getSystemStats & trackAction)
import { get } from 'svelte/store';
import { collection, getDocs, doc, setDoc, serverTimestamp, increment } from "firebase/firestore";
import { firebaseStore, isAdmin, currentUser } from '../stores.js';

const getDB = () => {
    const fb = get(firebaseStore);
    return fb.db;
};

export const analyticsService = {
    // L·∫•y danh s√°ch to√†n b·ªô user ƒë·ªÉ t√≠nh to√°n th·ªëng k√™
    async getAllUsers() {
        const db = getDB();
        // Kh√¥ng y√™u c·∫ßu quy·ªÅn Admin ·ªü ƒë√¢y ƒë·ªÉ Home c√≥ th·ªÉ hi·ªÉn th·ªã s·ªë li·ªáu chung
        if (!db) return [];

        try {
            const usersCollection = collection(db, "users");
            const querySnapshot = await getDocs(usersCollection);
            const users = [];
            
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                users.push({
                    email: data.email,
                    loginCount: data.loginCount || 0,
                    lastLogin: data.lastLogin ? data.lastLogin.toDate() : null,
                    actionsTaken: data.actionsTaken || 0
                });
            });
            return users;
        } catch (error) {
            console.error("L·ªói khi l·∫•y danh s√°ch user:", error);
            return [];
        }
    },

    // C·∫≠p nh·∫≠t th√¥ng tin user khi ƒëƒÉng nh·∫≠p
    async upsertUserRecord(email) {
        const db = getDB();
        if (!db || !email) return;

        const userRef = doc(db, "users", email);
        try {
            await setDoc(userRef, {
                email: email,
                lastLogin: serverTimestamp(),
                loginCount: increment(1)
            }, { merge: true });
        } catch (error) {
            console.error("L·ªói c·∫≠p nh·∫≠t user record:", error);
        }
    },

    // H√†m tƒÉng counter th·ªß c√¥ng (Gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c n·∫øu c·∫ßn)
    async incrementCounter(fieldName, email = null) {
        const db = getDB();
        if (!db || !fieldName) return;

        if (!email) {
            const user = get(currentUser);
            if (user) email = user.email;
        }

        let docRef;
        const dataToUpdate = { [fieldName]: increment(1) };

        if (fieldName === 'actionsTaken' && email) {
            docRef = doc(db, "users", email);
        } else {
            docRef = doc(db, "analytics", "site_stats");
        }

        try {
            await setDoc(docRef, dataToUpdate, { merge: true });
        } catch (error) {
            console.error(`L·ªói tƒÉng counter ${fieldName}:`, error);
        }
    },

    // [M·ªöI] H√†m l·∫•y t·ªïng h·ª£p s·ªë li·ªáu to√†n h·ªá th·ªëng
    async getSystemStats() {
        const users = await this.getAllUsers();
        
        const stats = users.reduce((acc, user) => {
            acc.totalUsers += 1; // M·ªói user l√† 1 ng∆∞·ªùi d√πng
            acc.totalVisits += (user.loginCount || 0); // T·ªïng s·ªë l·∫ßn ƒëƒÉng nh·∫≠p
            acc.totalActions += (user.actionsTaken || 0); // T·ªïng s·ªë l·∫ßn upload/paste
            return acc;
        }, { totalUsers: 0, totalVisits: 0, totalActions: 0 });

        return stats;
    },

    // [M·ªöI] H√†m ghi nh·∫≠n h√†nh ƒë·ªông (d√πng cho upload/paste)
    async trackAction() {
        const user = get(currentUser);
        if (!user || !user.email) return; // Ch·ªâ t√≠nh khi ƒë√£ ƒëƒÉng nh·∫≠p
        
        const db = getDB();
        if (!db) return;

        const userRef = doc(db, "users", user.email);
        try {
            await setDoc(userRef, {
                actionsTaken: increment(1)
            }, { merge: true });
            console.log("[Analytics] ƒê√£ ghi nh·∫≠n 1 l∆∞·ª£t s·ª≠ d·ª•ng.");
        } catch (error) {
            console.error("L·ªói trackAction:", error);
        }
    }
};
<<< FILE_END: src/services/analytics.service.js

>>> FILE_START: src/services/auth.service.js
// Version 2.3 - Add Anonymous Auth to fix 403 error
import { get } from 'svelte/store';
import { currentUser, isAdmin } from '../stores.js';
import { analyticsService } from './analytics.service.js';
import { config } from '../config.js';
import { getAuth, signInAnonymously, onAuthStateChanged } from "firebase/auth";

export const authService = {
    /**
     * Ki·ªÉm tra ƒë·ªãnh d·∫°ng email
     * @param {string} email 
     * @returns {boolean}
     */
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return email && emailRegex.test(email);
    },

    /**
     * [QUAN TR·ªåNG] ƒê·∫£m b·∫£o ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p v√†o Firebase (·∫®n danh)
     * H√†m n√†y c·∫ßn ƒë∆∞·ª£c g·ªçi ngay khi App kh·ªüi ch·∫°y ƒë·ªÉ l·∫•y token.
     * @returns {Promise<User>} Firebase User object
     */
    async ensureAnonymousAuth() {
        const auth = getAuth();
        return new Promise((resolve, reject) => {
            // L·∫Øng nghe tr·∫°ng th√°i x√°c th·ª±c
            const unsubscribe = onAuthStateChanged(auth, (user) => {
                if (user) {
                    console.log("[AuthService] ƒê√£ x√°c th·ª±c Firebase (·∫®n danh):", user.uid);
                    unsubscribe(); // H·ªßy l·∫Øng nghe sau khi ƒë√£ c√≥ user
                    resolve(user);
                } else {
                    console.log("[AuthService] Ch∆∞a c√≥ user, ƒëang ƒëƒÉng nh·∫≠p ·∫©n danh...");
                    signInAnonymously(auth)
                        .catch((error) => {
                            console.error("[AuthService] L·ªói ƒëƒÉng nh·∫≠p ·∫©n danh:", error);
                            reject(error);
                        });
                }
            });
        });
    },

    /**
     * X·ª≠ l√Ω ƒë·ªãnh danh ng∆∞·ªùi d√πng qua Email (Application Layer)
     * @param {string} email 
     * @returns {Promise<boolean>} true n·∫øu th√†nh c√¥ng
     */
    async loginUser(email) {
        const cleanEmail = email.trim();
        if (!this.isValidEmail(cleanEmail)) {
            return false;
        }

        // 1. L∆∞u v√†o LocalStorage ƒë·ªÉ nh·ªõ cho l·∫ßn sau
        localStorage.setItem('userEmail', cleanEmail);

        // 2. C·∫≠p nh·∫≠t Store
        currentUser.set({ email: cleanEmail });

        // 3. G·ªçi Analytics (Upsert user record)
        analyticsService.upsertUserRecord(cleanEmail).catch(err => {
            console.error("[AuthService] L·ªói khi ghi nh·∫≠n user v√†o analytics:", err);
        });

        return true;
    },

    /**
     * Ki·ªÉm tra m·∫≠t kh·∫©u Admin
     * @param {string} password 
     * @returns {boolean}
     */
    checkAdminPassword(password) {
        if (!config || !config.ADMIN_PASSWORD) {
            console.error("[AuthService] Ch∆∞a c·∫•u h√¨nh m·∫≠t kh·∫©u Admin trong config.js");
            return false;
        }
        
        if (password === config.ADMIN_PASSWORD) {
            isAdmin.set(true);
            return true;
        }
        
        return false;
    },

    /**
     * Kh·ªüi t·∫°o: Ki·ªÉm tra xem ƒë√£ c√≥ email l∆∞u trong localStorage ch∆∞a
     * (Ch·ªâ ki·ªÉm tra logic Email, ph·∫ßn Firebase Auth s·∫Ω ch·∫°y ri√™ng)
     */
    initAuth() {
        const savedEmail = localStorage.getItem('userEmail');
        if (savedEmail && this.isValidEmail(savedEmail)) {
            console.log(`[AuthService] T√¨m th·∫•y email ƒë√£ l∆∞u: ${savedEmail}`);
            currentUser.set({ email: savedEmail });
            // Ghi nh·∫≠n phi√™n truy c·∫≠p
            analyticsService.upsertUserRecord(savedEmail);
            return true; // ƒê√£ c√≥ email ƒë·ªãnh danh
        }
        return false; // Ch∆∞a c√≥ email
    }
};
<<< FILE_END: src/services/auth.service.js

>>> FILE_START: src/services/capture/engine.js
import { notificationStore } from '../../stores.js';

// --- HELPER: CHUY·ªÇN TI·∫æNG VI·ªÜT C√ì D·∫§U TH√ÄNH KH√îNG D·∫§U ---
const removeVietnameseTones = (str) => {
    if (!str) return '';
    str = str.replace(/√†|√°|·∫°|·∫£|√£|√¢|·∫ß|·∫•|·∫≠|·∫©|·∫´|ƒÉ|·∫±|·∫Ø|·∫∑|·∫≥|·∫µ/g, "a");
    str = str.replace(/√®|√©|·∫π|·∫ª|·∫Ω|√™|·ªÅ|·∫ø|·ªá|·ªÉ|·ªÖ/g, "e");
    str = str.replace(/√¨|√≠|·ªã|·ªâ|ƒ©/g, "i");
    str = str.replace(/√≤|√≥|·ªç|·ªè|√µ|√¥|·ªì|·ªë|·ªô|·ªï|·ªó|∆°|·ªù|·ªõ|·ª£|·ªü|·ª°/g, "o");
    str = str.replace(/√π|√∫|·ª•|·ªß|≈©|∆∞|·ª´|·ª©|·ª±|·ª≠|·ªØ/g, "u");
    str = str.replace(/·ª≥|√Ω|·ªµ|·ª∑|·ªπ/g, "y");
    str = str.replace(/ƒë/g, "d");
    str = str.replace(/√Ä|√Å|·∫†|·∫¢|√É|√Ç|·∫¶|·∫§|·∫¨|·∫®|·∫™|ƒÇ|·∫∞|·∫Æ|·∫∂|·∫≤|·∫¥/g, "A");
    str = str.replace(/√à|√â|·∫∏|·∫∫|·∫º|√ä|·ªÄ|·∫æ|·ªÜ|·ªÇ|·ªÑ/g, "E");
    str = str.replace(/√å|√ç|·ªä|·ªà|ƒ®/g, "I");
    str = str.replace(/√í|√ì|·ªå|·ªé|√ï|√î|·ªí|·ªê|·ªò|·ªî|·ªñ|∆†|·ªú|·ªö|·ª¢|·ªû|·ª†/g, "O");
    str = str.replace(/√ô|√ö|·ª§|·ª¶|≈®|∆Ø|·ª™|·ª®|·ª∞|·ª¨|·ªÆ/g, "U");
    str = str.replace(/·ª≤|√ù|·ª¥|·ª∂|·ª∏/g, "Y");
    str = str.replace(/ƒê/g, "D");
    // K·∫øt h·ª£p th√™m normalize ƒë·ªÉ x·ª≠ l√Ω c√°c d·∫•u t·ªï h·ª£p n·∫øu c√≥
    return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
};

export const injectCaptureStyles = () => {
    const styleId = 'dynamic-capture-styles';
    document.getElementById(styleId)?.remove();

    const styles = `
        /* CORE CONTAINER */
        .capture-container { 
            padding: 20px; 
            background-color: #f3f4f6; 
            box-sizing: border-box; 
            width: fit-content !important; 
            height: fit-content !important;
            position: absolute;
            left: -9999px;
            top: 0;
            z-index: -1;
            font-family: 'Segoe UI', Roboto, sans-serif;
        }

        .capture-title { 
            font-size: 26px; 
            font-weight: 800; 
            color: #1e3a8a; 
            margin-bottom: 20px; 
            text-align: center; 
            text-transform: uppercase;
        }

        /* --- PRESETS C≈® --- */
        .prepare-for-kpi-capture {
            display: grid !important;
            grid-template-columns: repeat(2, 1fr) !important;
            gap: 16px !important;
        }
        .prepare-for-grid-4-capture .luyke-cat-grid {
            display: grid !important;
            grid-template-columns: repeat(4, 1fr) !important;
            gap: 12px !important;
        }
        .prepare-for-competition-grid {
            display: grid !important;
            grid-template-columns: repeat(2, 1fr) !important;
            gap: 16px !important;
        }
        .force-mobile-width {
            width: 800px !important;
            max-width: 800px !important;
        }

        /* --- [UPDATED] MOBILE VIEW --- */
        .preset-mobile-view {
            /* Width 1000px theo y√™u c·∫ßu */
            width: 1000px !important; 
            min-width: 1000px !important;
            max-width: 1000px !important;
        }
        
        /* FIX 1: KPI gi·ªØ 3 c·ªôt (3x2) */
        .preset-mobile-view .lg\\:grid-cols-6 {
            grid-template-columns: repeat(3, 1fr) !important;
        }

        /* FIX 2: Bi·ªÉu ƒë·ªì √©p v·ªÅ 2 c·ªôt ngang nhau */
        .preset-mobile-view .lg\\:grid-cols-2 {
            grid-template-columns: repeat(2, 1fr) !important;
        }

        /* ·∫®n c√°c th√†nh ph·∫ßn th·ª´a */
        .preset-mobile-view button, 
        .preset-mobile-view .feather,
        .preset-mobile-view i[data-feather] {
            display: none !important;
        }
    `;

    const styleElement = document.createElement('style');
    styleElement.id = styleId;
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
    return styleElement;
};

// H√†m copyCanvasState gi·ªØ nguy√™n
export const copyCanvasState = (originalEl, clonedEl) => {
    const originalCanvases = originalEl.querySelectorAll('canvas');
    const clonedCanvases = clonedEl.querySelectorAll('canvas');

    if (originalCanvases.length !== clonedCanvases.length) return;

    originalCanvases.forEach((origCanvas, index) => {
        try {
            const cloneCanvas = clonedCanvases[index];
            const img = document.createElement('img');
            img.src = origCanvas.toDataURL('image/png');
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.display = 'block';
            img.style.objectFit = 'contain';

            if (cloneCanvas.parentNode) {
                cloneCanvas.parentNode.insertBefore(img, cloneCanvas);
                cloneCanvas.remove();
            }
        } catch (e) {
            console.warn('Canvas copy failed:', e);
        }
    });
};

export const swapCanvasToImage = (container) => {
    const canvases = container.querySelectorAll('canvas');
    canvases.forEach(canvas => {
        if (canvas.style.display !== 'none') canvas.style.display = 'none';
    });
};

export const coreCapture = async (elementToCapture, title, presetClass = '', options = {}) => {
    const { isPreview = false, scale = 2, windowWidth = null } = options;
    if (typeof window.html2canvas === 'undefined') throw new Error("Th∆∞ vi·ªán html2canvas ch∆∞a t·∫£i xong.");

    const date = new Date();
    const dateString = date.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });
    const timeString = date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
    
    // Title hi·ªÉn th·ªã TRONG ·∫¢NH (V·∫´n gi·ªØ c√≥ d·∫•u cho ƒë·∫πp)
    const displayTitle = `${title.replace(/_/g, ' ')} - ${timeString} ${dateString}`;

    const captureWrapper = document.createElement('div');
    captureWrapper.className = 'capture-container';

    const titleEl = document.createElement('h2');
    titleEl.className = 'capture-title';
    titleEl.textContent = displayTitle;
    captureWrapper.appendChild(titleEl);
    
    const contentClone = elementToCapture.cloneNode(true);
    if (presetClass) {
        contentClone.classList.add(presetClass);
        captureWrapper.classList.add(presetClass);
    }
    
    captureWrapper.appendChild(contentClone);
    document.body.appendChild(captureWrapper);

    await new Promise(resolve => setTimeout(resolve, 300)); 

    try {
        const canvas = await window.html2canvas(captureWrapper, {
            scale: isPreview ? 1 : scale,
            useCORS: true,
            backgroundColor: '#f3f4f6',
            logging: false,
            windowWidth: windowWidth, 
            windowHeight: null
        });

        const imageDataUrl = canvas.toDataURL('image/png');
        if (isPreview) {
            return { title: displayTitle, url: imageDataUrl };
        } else {
            // [FIX NAME] X·ª≠ l√Ω ti·∫øng Vi·ªát th√†nh kh√¥ng d·∫•u tr∆∞·ªõc khi l∆∞u file
            const noToneTitle = removeVietnameseTones(displayTitle);
            
            // Ch·ªâ gi·ªØ l·∫°i ch·ªØ c√°i kh√¥ng d·∫•u, s·ªë v√† d·∫•u g·∫°ch d∆∞·ªõi
            const safeFileName = noToneTitle
                                    .replace(/[^a-zA-Z0-9]/g, '_')
                                    .replace(/_+/g, '_'); // Tr√°nh nhi·ªÅu d·∫•u _ li·ªÅn nhau

            const link = document.createElement('a');
            link.download = `${safeFileName}.png`;
            link.href = imageDataUrl;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            notificationStore.update(s => ({ ...s, visible: true, type: 'success', message: 'ƒê√£ t·∫£i ·∫£nh xu·ªëng th√†nh c√¥ng!' }));
            setTimeout(() => notificationStore.update(s => ({ ...s, visible: false })), 3000);
            return null;
        }
    } finally {
        if (document.body.contains(captureWrapper)) document.body.removeChild(captureWrapper);
    }
};
<<< FILE_END: src/services/capture/engine.js

>>> FILE_START: src/services/capture/processors/competition-grid.js
import { coreCapture } from '../engine.js';

export const processCompetitionGrid = async (elements, baseTitle, options = {}) => {
    // V·ªõi th·∫ª Thi ƒëua v√πng, ta c≈©ng √©p Grid 2 c·ªôt tr√™n n·ªÅn 720px
    // ƒêi·ªÅu n√†y gi√∫p ·∫£nh tr√¥ng g·ªçn g√†ng nh∆∞ xem tr√™n ƒëi·ªán tho·∫°i
    const presetClass = 'prepare-for-competition-grid';

    const container = document.createElement('div');
    
    elements.forEach(el => {
        const clone = el.cloneNode(true);
        // X√≥a c√°c class width c≈© c·ªßa Tailwind n·∫øu c√≥ (vd: w-1/4) ƒë·ªÉ tr√°nh xung ƒë·ªôt
        clone.style.width = 'auto';
        clone.classList.remove('w-full', 'w-screen'); 
        
        // T√¨m v√† x·ª≠ l√Ω ti√™u ƒë·ªÅ b√™n trong ƒë·ªÉ ch·∫Øc ch·∫Øn hi·ªán d·∫•u ...
        // (D√π engine ƒë√£ c√≥ CSS, nh∆∞ng th√™m class n√†y ƒë·ªÉ ch·∫Øc ch·∫Øn)
        const headers = clone.querySelectorAll('h3, h4, .font-bold');
        headers.forEach(h => h.classList.add('truncate-capture'));

        container.appendChild(clone);
    });

    return await coreCapture(container, baseTitle, presetClass, options);
};
<<< FILE_END: src/services/capture/processors/competition-grid.js

>>> FILE_START: src/services/capture/processors/default.js
import { coreCapture } from '../engine.js';

export const processDefault = async (elements, baseTitle, options = {}) => {
    // Logic g·ªôp d·ªçc ƒë∆°n gi·∫£n
    const container = document.createElement('div');
    container.className = 'capture-layout-container';
    
    elements.forEach(el => {
        container.appendChild(el.cloneNode(true));
    });

    return await coreCapture(container, baseTitle, '', options);
};
<<< FILE_END: src/services/capture/processors/default.js

>>> FILE_START: src/services/capture/processors/kpi-grid.js
import { coreCapture } from '../engine.js';

export const processKpiGrid = async (elements, baseTitle, options = {}) => {
    // X√°c ƒë·ªãnh ch·∫ø ƒë·ªô Grid (2 c·ªôt m·∫∑c ƒë·ªãnh ho·∫∑c 4 c·ªôt)
    const isGrid4 = options.mode === 'grid-4';
    
    // T√™n class ƒë·ªÉ √©p giao di·ªán (CSS n√†y ƒë√£ n·∫±m trong engine.js)
    let presetClass = 'prepare-for-kpi-capture'; 
    if (isGrid4) {
        presetClass = 'prepare-for-grid-4-capture';
        // Grid 4 c·ªôt c·∫ßn ƒë·ªô ph√¢n gi·∫£i cao h∆°n
        if (!options.isPreview) options.scale = 4;
    }

    // --- S·ª¨A L·ªñI LOGIC T·∫†I ƒê√ÇY ---
    let elementToCapture;
    let finalPresetClass = presetClass;

    if (elements.length === 1) {
        // TR∆Ø·ªúNG H·ª¢P 1: Ng∆∞·ªùi d√πng gom nh√≥m c·∫£ b·∫£ng (Container)
        // -> Clone tr·ª±c ti·∫øp, √°p d·ª•ng class √©p Grid th·∫≥ng v√†o n√≥.
        elementToCapture = elements[0].cloneNode(true);
        
        // L∆∞u √Ω: N·∫øu ph·∫ßn t·ª≠ g·ªëc ƒë√£ c√≥ class, ta ph·∫£i merge th√™m class preset v√†o
        elementToCapture.classList.add(...presetClass.split(' '));
        finalPresetClass = ''; // ƒê√£ add tr·ª±c ti·∫øp r·ªìi n√™n kh√¥ng c·∫ßn pass v√†o coreCapture n·ªØa
    } else {
        // TR∆Ø·ªúNG H·ª¢P 2: Ng∆∞·ªùi d√πng ch·ªçn t·ª´ng th·∫ª r·ªùi r·∫°c
        // -> T·∫°o container bao ngo√†i, √©p container th√†nh Grid.
        const container = document.createElement('div');
        // Class 'capture-layout-container' c≈© d√πng flex-col, ta kh√¥ng d√πng ·ªü ƒë√¢y ƒë·ªÉ tr√°nh conflict v·ªõi Grid
        container.className = presetClass; 
        
        elements.forEach(el => container.appendChild(el.cloneNode(true)));
        elementToCapture = container;
        finalPresetClass = ''; // Class ƒë√£ n·∫±m ·ªü container
    }

    // G·ªçi Core Engine
    return await coreCapture(elementToCapture, baseTitle, finalPresetClass, options);
};
<<< FILE_END: src/services/capture/processors/kpi-grid.js

>>> FILE_START: src/services/capture/processors/mobile-view.js
import { coreCapture, copyCanvasState } from '../engine.js';

export const processMobileView = async (elements, baseTitle, options = {}) => {
    const presetClass = 'preset-mobile-view';

    // L·∫•y t√™n file t·ª´ attribute
    const customFileName = elements[0]?.dataset?.captureFilename;
    const captureTitle = customFileName || baseTitle;

    const container = document.createElement('div');
    container.className = 'capture-layout-container ' + presetClass;
    
    elements.forEach(originalEl => {
        const clone = originalEl.cloneNode(true);
        
        // Copy Canvas state
        copyCanvasState(originalEl, clone);

        // Reset height chart
        const chartContainers = clone.querySelectorAll('.h-\\[300px\\]');
        chartContainers.forEach(el => {
            el.style.height = 'auto'; 
            el.style.minHeight = '300px';
        });

        container.appendChild(clone);
    });

    // [UPDATE] Truy·ªÅn windowWidth: 1000
    return await coreCapture(container, captureTitle, presetClass, { 
        ...options, 
        windowWidth: 1000 
    });
};
<<< FILE_END: src/services/capture/processors/mobile-view.js

>>> FILE_START: src/services/capture/registry.js
import { processDefault } from './processors/default.js';
import { processKpiGrid } from './processors/kpi-grid.js';
import { processCompetitionGrid } from './processors/competition-grid.js';
// Import Processor m·ªõi
import { processMobileView } from './processors/mobile-view.js';

export const getProcessor = (groupName) => {
    // 1. [M·ªöI] Nh√≥m Chi ti·∫øt nh√¢n vi√™n -> Mobile View (Grid 3 c·ªôt)
    if (groupName === 'revenue-detail-mobile') {
        return processMobileView;
    }

    // 2. Nh√≥m KPI M√†u (L≈©y k·∫ø) -> Grid C·ª©ng
    if (['kpi', 'supermarket-kpi'].includes(groupName)) {
        return (els, title, opts) => processKpiGrid(els, title, { ...opts, mode: 'normal' });
    }
    
    // 3. Nh√≥m Grid 4 C·ªôt (Tier 2)
    if (['tier2'].includes(groupName)) {
        return (els, title, opts) => processKpiGrid(els, title, { ...opts, mode: 'grid-4' });
    }

    // 4. Nh√≥m Thi ƒëua & Chi ti·∫øt (SKNV, Realtime) -> Grid Linh ho·∫°t
    if (['regional-competition', 'detail-category', 'competition-detail'].includes(groupName)) {
        return processCompetitionGrid;
    }

    // 5. M·∫∑c ƒë·ªãnh (G·ªôp d·ªçc)
    return processDefault;
};

export const SPLIT_GROUPS = [
    'category-revenue', 'competition-program', 'efficiency-program'
];
<<< FILE_END: src/services/capture/registry.js

>>> FILE_START: src/services/capture.config.js
// File: src/services/capture.config.js

// 1. Danh s√°ch c√°c nh√≥m c·∫ßn T√ÅCH ·∫¢NH (M·ªói b·∫£ng 1 ·∫£nh)
export const SPLIT_GROUPS = [
    'category-revenue',         
    'competition-program',      
    'competition-program-view', 
    'efficiency-program',       
    'efficiency-program-view',
    'regional-competition',
    'efficiency-luyke'
];

// 2. Danh s√°ch c√°c nh√≥m c·∫ßn G·ªòP D·∫†NG L∆Ø·ªöI (Grid) - D√†nh cho KPI
// QUAN TR·ªåNG: B·∫•t k·ª≥ nh√≥m n√†o n·∫±m trong list n√†y s·∫Ω ƒë∆∞·ª£c k√≠ch ho·∫°t Grid 2 c·ªôt
export const KPI_GROUPS = [
    'kpi',
    'supermarket-kpi' 
];

// 3. [NEW] Danh s√°ch nh√≥m c·∫ßn √©p GRID 4 C·ªòT
export const GRID_4_GROUPS = [
    'tier2' // Nh√≥m Chi ti·∫øt ng√†nh h√†ng
];

// 4. C·∫•u h√¨nh m·∫∑c ƒë·ªãnh: MERGE_VERTICAL (G·ªôp d·ªçc)
// D√†nh cho: Realtime, Doanh thu NV LK, Thu nh·∫≠p...
<<< FILE_END: src/services/capture.config.js

>>> FILE_START: src/services/capture.service.js
/* global Chart */
import { notificationStore, currentUser } from '../stores.js';
import { analyticsService } from './analytics.service.js';
import { get } from 'svelte/store';

// Import t·ª´ h·ªá th·ªëng Capture m·ªõi
import { injectCaptureStyles } from './capture/engine.js';
import { getProcessor, SPLIT_GROUPS } from './capture/registry.js';
import { processDefault } from './capture/processors/default.js';

export const captureService = {
    // 1. Ch·ª•p m·ªôt ph·∫ßn t·ª≠ ƒë∆°n l·∫ª (D√πng cho n√∫t ch·ª•p l·∫ª)
    async captureAndDownload(elementToCapture, title, presetClass = '') {
        const user = get(currentUser);
        analyticsService.incrementCounter('actionsTaken', user?.email);
        
        const styleElement = injectCaptureStyles();
        
        try {
            // D√πng processor m·∫∑c ƒë·ªãnh cho ch·ª•p l·∫ª
            await processDefault([elementToCapture], title, { 
                presetClass: presetClass 
            });
        } catch (error) {
            console.error('Capture Single Error:', error);
            alert('L·ªói khi ch·ª•p ·∫£nh: ' + error.message);
        } finally {
            styleElement.remove();
        }
    },
    
    // 2. Ch·ª•p to√†n b·ªô Dashboard (N√∫t ch·ª•p t·ªïng)
    async captureDashboardInParts(contentContainer, baseTitle) {
       if (!contentContainer) {
            alert('L·ªói: Kh√¥ng t√¨m th·∫•y n·ªôi dung ƒë·ªÉ ch·ª•p.');
            return;
        }

        const user = get(currentUser);
        analyticsService.incrementCounter('actionsTaken', user?.email);
        notificationStore.update(s => ({ ...s, visible: true, type: 'info', message: `ƒêang x·ª≠ l√Ω ·∫£nh: ${baseTitle}...` }));

        // Ph√¢n lo·∫°i c√°c nh√≥m (Grouping)
        const captureGroups = new Map();
        contentContainer.querySelectorAll('[data-capture-group]').forEach(el => {
            if (el.offsetParent !== null) { // Ch·ªâ l·∫•y element ƒëang hi·ªÉn th·ªã
                const group = el.dataset.captureGroup;
                if (!captureGroups.has(group)) {
                     captureGroups.set(group, []);
                }
                captureGroups.get(group).push(el);
            }
        });

        const styleElement = injectCaptureStyles();
        if (typeof Chart !== 'undefined') {
            Chart.defaults.animation = false;
        }
        
        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ style ƒÉn v√†o DOM
        await new Promise(resolve => setTimeout(resolve, 100));

        try {
            if (captureGroups.size === 0) {
                if (contentContainer.offsetParent !== null) {
                    // N·∫øu kh√¥ng c√≥ nh√≥m n√†o, ch·ª•p to√†n b·ªô container b·∫±ng processor m·∫∑c ƒë·ªãnh
                    await processDefault([contentContainer], baseTitle);
                } else {
                     alert('Kh√¥ng c√≥ n·ªôi dung hi·ªÉn th·ªã ƒë·ªÉ ch·ª•p.');
                }
                return;
            }

            // Duy·ªát qua t·ª´ng nh√≥m ƒë·ªÉ x·ª≠ l√Ω
            for (const [group, elements] of captureGroups.entries()) {
                // TR∆Ø·ªúNG H·ª¢P 1: Nh√≥m c·∫ßn t√°ch l·∫ª (Split)
                if (SPLIT_GROUPS.includes(group)) {
                    for (const el of elements) {
                        // [GENESIS FIX]: ∆Øu ti√™n l·∫•y t√™n file t·ª´ attribute data-capture-filename
                        let customName = el.dataset.captureFilename;

                        // L·∫•y ti√™u ƒë·ªÅ con t·ª´ th·∫ª h3/h4 n·∫øu c√≥
                        let subTitle = customName || el.querySelector('h3, h4')?.textContent?.trim() || baseTitle;
                        
                        // G·ªçi processor m·∫∑c ƒë·ªãnh cho t·ª´ng ph·∫ßn t·ª≠
                        await processDefault([el], subTitle);
                        // Delay nh·∫π ƒë·ªÉ tr√¨nh duy·ªát kh√¥ng b·ªã ƒë∆°
                        await new Promise(r => setTimeout(r, 300));
                    }
                    continue; 
                }

                // TR∆Ø·ªúNG H·ª¢P 2: Nh√≥m g·ªôp (Merge)
                const processor = getProcessor(group);
                if (processor) {
                    await processor(elements, baseTitle);
                } else {
                    // [GENESIS FIX FALLBACK]: N·∫øu kh√¥ng c√≥ processor (nh∆∞ group 'sknv-detail-view'), 
                    // d√πng processDefault ƒë·ªÉ ch·ª•p thay v√¨ b·ªè qua.
                    for (const el of elements) {
                         let customName = el.dataset.captureFilename;
                         let subTitle = customName || baseTitle;
                         await processDefault([el], subTitle);
                         await new Promise(r => setTimeout(r, 300));
                    }
                }
            }
        } catch (error) {
            console.error('Capture Dashboard Error:', error);
            alert('C√≥ l·ªói x·∫£y ra: ' + error.message);
        } finally {
            styleElement.remove();
            if (typeof Chart !== 'undefined') {
                Chart.defaults.animation = {};
            }
        }

        notificationStore.update(s => ({ ...s, visible: true, type: 'success', message: 'Ho√†n t·∫•t qu√° tr√¨nh ch·ª•p!' }));
        setTimeout(() => notificationStore.update(s => ({ ...s, visible: false })), 3000);
    },

    // 3. L·∫•y ·∫£nh xem tr∆∞·ªõc (Preview)
    async getPreviewImages(contentContainer, baseTitle) {
        if (!contentContainer) return [];

        const captureGroups = new Map();
        contentContainer.querySelectorAll('[data-capture-group]').forEach(el => {
            if (el.offsetParent !== null) {
                const group = el.dataset.captureGroup;
                if (!captureGroups.has(group)) captureGroups.set(group, []);
                captureGroups.get(group).push(el);
            }
        });

        const styleElement = injectCaptureStyles();
        if (typeof Chart !== 'undefined') Chart.defaults.animation = false;
        
        let previewImages = [];
        const options = { isPreview: true, scale: 1 }; 

        try {
            if (captureGroups.size === 0) {
                 const res = await processDefault([contentContainer], baseTitle, options);
                 if (res) previewImages.push(res);
            }

            for (const [group, elements] of captureGroups.entries()) {
                // X·ª≠ l√Ω SPLIT cho Preview
                if (SPLIT_GROUPS.includes(group)) {
                     for (const el of elements) {
                        let customName = el.dataset.captureFilename;
                        let subTitle = customName || el.querySelector('h3, h4')?.textContent?.trim() || baseTitle;
                        const res = await processDefault([el], subTitle, options);
                        if (res) previewImages.push(res);
                     }
                     continue;
                }
                
                // X·ª≠ l√Ω MERGE cho Preview
                const processor = getProcessor(group);
                if (processor) {
                    const result = await processor(elements, baseTitle, options);
                    if (result) {
                        if (Array.isArray(result)) {
                            previewImages = [...previewImages, ...result];
                        } else {
                            previewImages.push(result);
                        }
                    }
                } else {
                     // [GENESIS FIX FALLBACK PREVIEW]
                     for (const el of elements) {
                        let customName = el.dataset.captureFilename;
                        let subTitle = customName || baseTitle;
                        const res = await processDefault([el], subTitle, options);
                        if (res) previewImages.push(res);
                     }
                }
            }
        } catch (e) {
            console.error('Preview Error:', e);
        } finally {
            styleElement.remove();
            if (typeof Chart !== 'undefined') Chart.defaults.animation = {};
        }

        return previewImages;
    }
};
<<< FILE_END: src/services/capture.service.js

>>> FILE_START: src/services/capture.strategies.js
// File: src/services/capture.strategies.js
/* global Chart */
import { notificationStore } from '../stores.js';

// --- HELPER: Chuy·ªÉn Ti·∫øng Vi·ªát sang Kh√¥ng D·∫•u ---
const removeVietnameseTones = (str) => {
    if (!str) return '';
    str = str.replace(/√†|√°|·∫°|·∫£|√£|√¢|·∫ß|·∫•|·∫≠|·∫©|·∫´|ƒÉ|·∫±|·∫Ø|·∫∑|·∫≥|·∫µ/g, "a");
    str = str.replace(/√®|√©|·∫π|·∫ª|·∫Ω|√™|·ªÅ|·∫ø|·ªá|·ªÉ|·ªÖ/g, "e");
    str = str.replace(/√¨|√≠|·ªã|·ªâ|ƒ©/g, "i");
    str = str.replace(/√≤|√≥|·ªç|·ªè|√µ|√¥|·ªì|·ªë|·ªô|·ªï|·ªó|∆°|·ªù|·ªõ|·ª£|·ªü|·ª°/g, "o");
    str = str.replace(/√π|√∫|·ª•|·ªß|≈©|∆∞|·ª´|·ª©|·ª±|·ª≠|·ªØ/g, "u");
    str = str.replace(/·ª≥|√Ω|·ªµ|·ª∑|·ªπ/g, "y");
    str = str.replace(/ƒë/g, "d");
    str = str.replace(/√Ä|√Å|·∫†|·∫¢|√É|√Ç|·∫¶|·∫§|·∫¨|·∫®|·∫™|ƒÇ|·∫∞|·∫Æ|·∫∂|·∫≤|·∫¥/g, "A");
    str = str.replace(/√à|√â|·∫∏|·∫∫|·∫º|√ä|·ªÄ|·∫æ|·ªÜ|·ªÇ|·ªÑ/g, "E");
    str = str.replace(/√å|√ç|·ªä|·ªà|ƒ®/g, "I");
    str = str.replace(/√í|√ì|·ªå|·ªé|√ï|√î|·ªí|·ªê|·ªò|·ªî|·ªñ|∆†|·ªú|·ªö|·ª¢|·ªû|·ª†/g, "O");
    str = str.replace(/√ô|√ö|·ª§|·ª¶|≈®|∆Ø|·ª™|·ª®|·ª∞|·ª¨|·ªÆ/g, "U");
    str = str.replace(/·ª≤|√ù|·ª¥|·ª∂|·ª∏/g, "Y");
    str = str.replace(/ƒê/g, "D");
    return str;
};

// --- HELPER: CSS Injection ---
export const injectCaptureStyles = () => {
    const styleId = 'dynamic-capture-styles';
    document.getElementById(styleId)?.remove();

    // CSS n√†y √°p d·ª•ng chung cho to√†n b·ªô qu√° tr√¨nh ch·ª•p
    const styles = `
        /* Container g·ªëc */
        .capture-container { 
            padding: 24px; 
            background-color: #f3f4f6; 
            box-sizing: border-box; 
            width: fit-content; 
            position: absolute;
            left: -9999px;
            top: 0;
            z-index: -1;
        }
        
        /* Reset Table styles cho ƒë·∫πp khi ch·ª•p */
        .capture-container th, .capture-container td {
            padding-top: 8px !important;
            padding-bottom: 8px !important;
            line-height: 1.5 !important;
            height: auto !important;
        }
        .capture-container td > div, .capture-container td > span,
        .capture-container td > p, .capture-container th > div, .capture-container th > span {
            overflow: visible !important;
            padding-bottom: 4px !important;
            line-height: 1.5 !important;
            height: auto !important;
            white-space: normal !important;
        }
        .capture-container h3, .capture-container h4, .capture-container .font-bold {
            padding-bottom: 6px !important;
            line-height: 1.5 !important;
            overflow: visible !important;
        }

        /* Layout Grid */
        .capture-layout-container { 
            display: flex; 
            flex-direction: column; 
            gap: 24px; 
        }
        
        .prepare-for-kpi-capture {
            display: grid !important;
            grid-template-columns: repeat(2, 1fr) !important;
            gap: 16px !important;
            width: auto !important; 
        }

        .prepare-for-grid-4-capture {
            width: 800px !important;
            max-width: none !important;
        }
        .prepare-for-grid-4-capture .luyke-cat-grid {
            display: grid !important;
            grid-template-columns: repeat(4, 1fr) !important;
            gap: 16px !important;
        }

        .capture-title { 
            font-size: 28px; 
            font-weight: bold; 
            color: #1e3a8a; 
            margin-bottom: 20px; 
            text-align: center; 
            font-family: 'Segoe UI', sans-serif;
            text-transform: uppercase;
            line-height: 1.5 !important;
            padding-bottom: 10px !important;
        }

        .preset-mobile-portrait {
            width: 450px !important;
            min-width: 450px !important;
            max-width: 450px !important;
            padding: 10px !important;
            margin: 0 auto;
            transform: scale(5) !important;
            transform-origin: top center !important; 
        }
        .preset-mobile-portrait .capture-title {
            font-size: 18px !important;
        }
    `;

    const styleElement = document.createElement('style');
    styleElement.id = styleId;
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
    return styleElement;
};

export const swapCanvasToImage = (container) => {
    const canvases = container.querySelectorAll('canvas');
    canvases.forEach(canvas => {
        try {
            const img = document.createElement('img');
            img.src = canvas.toDataURL('image/png');
            img.style.width = canvas.style.width || '100%';
            img.style.height = canvas.style.height || 'auto';
            img.style.display = 'block';
            if (canvas.parentNode) {
                canvas.parentNode.insertBefore(img, canvas);
                canvas.style.display = 'none'; 
            }
        } catch (e) {
            console.warn('Cannot convert canvas to image:', e);
        }
    });
};

// --- CORE FUNCTION ---
const _coreCapture = async (elementToCapture, title, presetClass = '', options = {}) => {
    const { isPreview = false, scale = 2 } = options;

    if (typeof window.html2canvas === 'undefined') throw new Error("Th∆∞ vi·ªán html2canvas ch∆∞a t·∫£i xong.");

    const date = new Date();
    const dateString = date.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });
    const timeString = date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
    
    // [LOGIC TITLE]: Ti√™u ƒë·ªÅ hi·ªÉn th·ªã TRONG ·∫¢NH (v·∫´n gi·ªØ nguy√™n logic c≈©: Title + Time)
    const displayTitle = `${title.replace(/_/g, ' ')} - ${timeString} ${dateString}`;

    const captureWrapper = document.createElement('div');
    captureWrapper.className = 'capture-container';

    const titleEl = document.createElement('h2');
    titleEl.className = 'capture-title';
    titleEl.textContent = displayTitle;
    captureWrapper.appendChild(titleEl);
    
    const contentClone = elementToCapture.cloneNode(true);
    
    if (presetClass) { 
        const classes = presetClass.split(' ').filter(c => c);
        contentClone.classList.add(...classes); 
    }
    
    captureWrapper.appendChild(contentClone);
    document.body.appendChild(captureWrapper);

    if (typeof Chart !== 'undefined') Chart.defaults.animation = false;
    swapCanvasToImage(contentClone);
    await new Promise(resolve => setTimeout(resolve, 300)); 

    try {
        const canvas = await window.html2canvas(captureWrapper, {
            scale: isPreview ? 1 : scale,
            useCORS: true,
            backgroundColor: '#f3f4f6',
            logging: false,
            windowWidth: captureWrapper.scrollWidth, 
            windowHeight: captureWrapper.scrollHeight
        });

        const imageDataUrl = canvas.toDataURL('image/png');

        if (isPreview) {
            return { title: displayTitle, url: imageDataUrl };
        } else {
            // [LOGIC FILENAME]: X·ª≠ l√Ω t√™n file t·∫£i v·ªÅ
            const noToneTitle = removeVietnameseTones(title);
            const safeFileName = noToneTitle
                                    .replace(/[^a-zA-Z0-9]/g, '_')
                                    .replace(/_+/g, '_');
                                    
            const link = document.createElement('a');
            link.download = `${safeFileName}_${dateString.replace(/\//g, '-')}.png`;
            link.href = imageDataUrl;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            notificationStore.update(s => ({ ...s, visible: true, type: 'success', message: 'ƒê√£ t·∫£i ·∫£nh xu·ªëng th√†nh c√¥ng!' }));
            setTimeout(() => notificationStore.update(s => ({ ...s, visible: false })), 3000);
            return null;
        }
    } finally {
        if (document.body.contains(captureWrapper)) document.body.removeChild(captureWrapper);
        if (typeof Chart !== 'undefined') Chart.defaults.animation = {}; 
    }
};

export const strategySingle = async (element, baseTitle, options) => {
    // [FIX GENESIS]: ∆Øu ti√™n t√™n file t·ª´ attribute
    const manualFileName = element.dataset.captureFilename;
    const captureTitle = manualFileName || baseTitle;

    const preset = element.dataset.capturePreset;
    let presetClass = preset ? `preset-${preset}` : '';
    return await _coreCapture(element, captureTitle, presetClass, options);
};

export const strategySplit = async (elements, baseTitle, options) => {
    const results = [];
    for (const targetElement of elements) {
        // [FIX GENESIS]: ∆Øu ti√™n t√™n file t·ª´ attribute
        const manualFileName = targetElement.dataset.captureFilename;

        let foundTitle = targetElement.querySelector('h3, h4')?.textContent?.trim() || '';
        foundTitle = removeVietnameseTones(foundTitle); 
        
        // Logic m·ªõi: Manual Name > Found Tag > Base Title
        const captureTitle = manualFileName || (foundTitle || baseTitle);
        
        const preset = targetElement.dataset.capturePreset;
        let presetClass = (preset ? `preset-${preset}` : '');

        const res = await _coreCapture(targetElement, captureTitle, presetClass, options);
        if (res) results.push(res);
        
        const delay = (options && options.isPreview) ? 50 : 500;
        await new Promise(resolve => setTimeout(resolve, delay));
    }
    return results;
};

export const strategyMerge = async (elements, baseTitle, isKpiMode = false, options = {}) => {
    let elementToCapture;
    
    if (elements.length > 1) {
        const tempContainer = document.createElement('div');
        tempContainer.className = 'capture-layout-container'; 
        elements.forEach(el => tempContainer.appendChild(el.cloneNode(true)));
        elementToCapture = tempContainer;
    } else {
        elementToCapture = elements[0];
    }

    // [FIX GENESIS]: ∆Øu ti√™n l·∫•y t√™n t·ª´ ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n n·∫øu c√≥ attribute
    const manualFileName = elements[0]?.dataset?.captureFilename;

    let foundTitle = '';
    if (elements[0]) {
        foundTitle = elements[0].querySelector('h3, h4')?.textContent?.trim() || '';
    }
    foundTitle = removeVietnameseTones(foundTitle);
    
    // Logic m·ªõi: Manual Name > Found Tag > Base Title
    // [QUAN TR·ªåNG]: ƒê√¢y l√† d√≤ng s·ª≠a l·ªói t√™n file b·ªã default
    const captureTitle = manualFileName || (foundTitle || baseTitle);

    const preset = elements[0]?.dataset.capturePreset;
    let presetClass = '';

    if (isKpiMode === 'grid-4') {
        presetClass = 'prepare-for-grid-4-capture';
        if (!options.isPreview) options.scale = 4;
    } else if (isKpiMode === true) {
        presetClass = 'prepare-for-kpi-capture';
    } else if (preset) {
        presetClass = `preset-${preset}`;
    }

    const res = await _coreCapture(elementToCapture, captureTitle, presetClass, options);
    await new Promise(resolve => setTimeout(resolve, 300));
    return res ? [res] : [];
};

export const captureAndDownload = _coreCapture;
<<< FILE_END: src/services/capture.strategies.js

>>> FILE_START: src/services/cluster.service.js
// src/services/cluster.service.js
import { writable } from 'svelte/store';
import { clusterParser } from './processing/parsers/cluster.parser.js';
import { clusterProcessor } from './processing/logic/cluster.processor.js';

// Stores ƒë·ªÉ UI subscribe
export const clusterDataStore = writable({
    competition: null, // D·ªØ li·ªáu thi ƒëua
    cumulative: null,  // D·ªØ li·ªáu l≈©y k·∫ø (General + Details)
    isClusterMode: false,
    currentClusterCode: null
});

const STORAGE_PREFIX = 'cluster_data_';

export const clusterService = {
    /**
     * X·ª≠ l√Ω text paste t·ª´ √¥ "Thi ƒëua si√™u th·ªã l≈©y k·∫ø"
     */
    processCompetitionInput: (text, clusterCode) => {
        const parsed = clusterParser.parseCompetitionStr(text);
        const processed = clusterProcessor.processCompetitionData(parsed);
        
        // Update Store
        clusterDataStore.update(s => ({ ...s, competition: processed }));
        
        // Save to Local
        localStorage.setItem(`${STORAGE_PREFIX}comp_${clusterCode}`, JSON.stringify(processed));
        return processed;
    },

    /**
     * X·ª≠ l√Ω text paste t·ª´ √¥ "Data l≈©y k·∫ø" (Ch·∫ø ƒë·ªô C·ª•m)
     */
    processCumulativeInput: (text, clusterCode) => {
        const parsed = clusterParser.parseCumulativeStr(text);
        const report = clusterProcessor.createClusterReport(parsed);
        
        // Update Store
        clusterDataStore.update(s => ({ ...s, cumulative: report }));
        
        // Save to Local
        localStorage.setItem(`${STORAGE_PREFIX}cumul_${clusterCode}`, JSON.stringify(report));
        return report;
    },

    /**
     * Load d·ªØ li·ªáu ƒë√£ l∆∞u khi ng∆∞·ªùi d√πng ch·ªçn Kho/C·ª•m
     */
    loadSavedData: (clusterCode) => {
        if (!clusterCode) return;

        try {
            const savedComp = localStorage.getItem(`${STORAGE_PREFIX}comp_${clusterCode}`);
            const savedCumul = localStorage.getItem(`${STORAGE_PREFIX}cumul_${clusterCode}`);

            clusterDataStore.update(s => ({
                ...s,
                currentClusterCode: clusterCode,
                isClusterMode: true,
                competition: savedComp ? JSON.parse(savedComp) : null,
                cumulative: savedCumul ? JSON.parse(savedCumul) : null
            }));
        } catch (e) {
            console.error("L·ªói load d·ªØ li·ªáu c·ª•m:", e);
        }
    },

    /**
     * Reset store khi chuy·ªÉn v·ªÅ ch·∫ø ƒë·ªô kho ƒë∆°n
     */
    reset: () => {
        clusterDataStore.set({
            competition: null,
            cumulative: null,
            isClusterMode: false,
            currentClusterCode: null
        });
    }
};
<<< FILE_END: src/services/cluster.service.js

>>> FILE_START: src/services/composerService.js
// File: src/services/composerService.js
// M·ª§C ƒê√çCH: Logic Tr√¨nh t·∫°o Nh·∫≠n x√©t (Update: Th√™m % Tr·∫£ ch·∫≠m & Ranking Top 5)

import { get } from 'svelte/store';
import { masterReportData } from '../stores.js';
import { dataProcessing } from './dataProcessing.js';
import * as utils from '../utils.js'; 
import { formatters } from '../utils/formatters.js';

const composerServices = {
    // --- Helpers cho X·∫øp h·∫°ng ---
    getEmployeeRanking(reportData, key, direction = 'desc', count = 3, department = 'ALL') {
        if (!reportData || reportData.length === 0) return [];
        let filteredData = reportData;
        if (department !== 'ALL') {
            filteredData = reportData.filter(e => e.boPhan === department);
        }

        return [...filteredData]
            .filter(e => e[key] > 0 || (key === 'tyLeTraCham' && e[key] >= 0)) // Tr·∫£ ch·∫≠m c√≥ th·ªÉ = 0 v·∫´n x·∫øp h·∫°ng
            .sort((a, b) => direction === 'desc' ? (b[key] || 0) - (a[key] || 0) : (a[key] || 0) - (b[key] || 0))
            .slice(0, count);
    },

    getEmployeesBelowTarget(reportData, dataKey, goalKey, department = 'ALL') {
        if (!reportData || reportData.length === 0) return [];
        let filteredData = reportData;
        if (department !== 'ALL') {
            filteredData = reportData.filter(e => e.boPhan === department);
        }

        return filteredData.filter(employee => {
            const value = employee[dataKey] || 0;
            const target = (employee.mucTieu?.[goalKey] || 0) / 100;
            return target > 0 && value < target;
        }).sort((a, b) => (b[dataKey] || 0) - (a[dataKey] || 0));
    },

    formatEmployeeList(employeeArray, valueKey, valueType = 'number') {
        if (!Array.isArray(employeeArray) || employeeArray.length === 0) {
            return " (kh√¥ng c√≥)";
        }
        return "\n" + employeeArray.map((e, index) => {
            const value = e[valueKey];
            let formattedValue = '';
            if (valueType === 'percent') {
                formattedValue = formatters.formatPercentage(value);
            } else if (valueType === 'currency') {
                formattedValue = formatters.formatRevenue(value) + " tr";
            } else {
                formattedValue = formatters.formatNumberOrDash(value);
            }
            return `${index + 1}. ${formatters.getShortEmployeeName(e.hoTen, e.maNV)}: ${formattedValue} @${e.maNV}`;
        }).join("\n");
    },
    
    // --- LOGIC X·ª¨ L√ù CH√çNH ---
    processComposerTemplate(template, supermarketReport, goals, rankingReportData, competitionData, sectionId) {
        if (!template || !supermarketReport || !goals) {
            return "L·ªói: D·ªØ li·ªáu kh√¥ng ƒë·ªß ƒë·ªÉ t·∫°o nh·∫≠n x√©t.";
        }

        // [UPDATE] Th√™m TLTC (T·ª∑ l·ªá tr·∫£ ch·∫≠m) v√†o mapping ranking
        const tagMapping = {
            'DTQD': { key: 'doanhThuQuyDoi', format: 'currency' },
            'THUNHAP': { key: 'tongThuNhap', format: 'currency' },
            'TLQD': { key: 'hieuQuaQuyDoi', format: 'percent' },
            'TLTC': { key: 'tyLeTraCham', format: 'percent' } 
        };

        const botTargetMapping = {
            'TLQD': { dataKey: 'hieuQuaQuyDoi', goalKey: 'phanTramQD', format: 'percent' },
            'TLTC': { dataKey: 'tyLeTraCham', goalKey: 'phanTramTC', format: 'percent' },
            'PK': { dataKey: 'pctPhuKien', goalKey: 'phanTramPhuKien', format: 'percent' },
            'GD': { dataKey: 'pctGiaDung', goalKey: 'phanTramGiaDung', format: 'percent' },
            'MLN': { dataKey: 'pctMLN', goalKey: 'phanTramMLN', format: 'percent' },
            'SIM': { dataKey: 'pctSim', goalKey: 'phanTramSim', format: 'percent' },
            'VAS': { dataKey: 'pctVAS', goalKey: 'phanTramVAS', format: 'percent' },
            'BH': { dataKey: 'pctBaoHiem', goalKey: 'phanTramBaoHiem', format: 'percent' },
        };

        // --- B∆Ø·ªöC 1: CHU·∫®N B·ªä S·ªê LI·ªÜU ---
        let dtThuc = supermarketReport.doanhThu || 0;
        let dtQd = supermarketReport.doanhThuQuyDoi || 0;
        let tlQd = supermarketReport.hieuQuaQuyDoi || 0; 
        let tlTraCham = supermarketReport.tyLeTraCham || 0; // [NEW] Bi·∫øn tr·∫£ ch·∫≠m
        let comparisonPercentage = 'N/A';
        
        let dtThucDuKienFromPaste = 0; 
        let phanTramTargetQdFromPaste = null;

        // ∆Øu ti√™n l·∫•y d·ªØ li·ªáu Paste
        if (sectionId === 'luyke' && typeof localStorage !== 'undefined') {
            const pastedText = localStorage.getItem('daily_paste_luyke');
            if (pastedText) {
                const pastedData = dataProcessing.parseLuyKePastedData(pastedText);
                const { mainKpis, comparisonData, dtDuKien, tyLeTraCham } = pastedData;

                // X·ª≠ l√Ω DT & TLQƒê
                if (mainKpis && mainKpis['Th·ª±c hi·ªán DT th·ª±c']) {
                    const clean = (val) => parseFloat(String(val).replace(/,/g, '')) || 0;
                    
                    const dtThucPaste = clean(mainKpis['Th·ª±c hi·ªán DT th·ª±c']) * 1000000;
                    const dtQdPaste = clean(mainKpis['Th·ª±c hi·ªán DTQƒê']) * 1000000;

                    if (dtThucPaste > 0) {
                        dtThuc = dtThucPaste;
                        dtQd = dtQdPaste;
                        tlQd = (dtQd / dtThuc) - 1;
                    }

                    if (mainKpis['% HT Target D·ª± Ki·∫øn (Qƒê)']) {
                         const rawPct = String(mainKpis['% HT Target D·ª± Ki·∫øn (Qƒê)']).replace(/%|,/g, '');
                         phanTramTargetQdFromPaste = parseFloat(rawPct) / 100;
                    }
                }

                // [NEW] X·ª≠ l√Ω T·ª∑ l·ªá tr·∫£ ch·∫≠m t·ª´ paste (D·ªØ li·ªáu paste th∆∞·ªùng l√† s·ªë 10.5 -> c·∫ßn chia 100)
                if (tyLeTraCham !== undefined) {
                    tlTraCham = parseFloat(tyLeTraCham) / 100;
                }

                // DT D·ª± ki·∫øn
                if (dtDuKien) {
                    dtThucDuKienFromPaste = parseFloat(String(dtDuKien).replace(/,/g, '')) * 1000000;
                }

                // So s√°nh c√πng k·ª≥
                if (comparisonData && comparisonData.percentage) {
                    comparisonPercentage = comparisonData.percentage;
                }
            }
        }

        // --- B∆Ø·ªöC 2: T√çNH TO√ÅN D·ª∞ KI·∫æN FALLBACK ---
        const now = new Date();
        const currentDay = now.getDate() || 1;
        const totalDaysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();

        // --- B∆Ø·ªöC 3: THAY TH·∫æ TAG ---
        return template.replace(/\[(.*?)\]/g, (match, tag) => {
            
            if (tag === 'NGAY') return now.toLocaleDateString('vi-VN');
            if (tag === 'GIO') return now.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });

            if (tag === 'DT_THUC') return formatters.formatNumber(dtThuc / 1000000, 0) + " tr";
            if (tag === 'DTQD') return formatters.formatNumber(dtQd / 1000000, 0) + " tr";
            if (tag === 'TLQD') return formatters.formatPercentage(tlQd);
            if (tag === 'TLTC') return formatters.formatPercentage(tlTraCham); // [NEW] Tag TLTC
            
            if (tag === '%HT_DTQD') {
                if (phanTramTargetQdFromPaste !== null) {
                    return formatters.formatPercentage(phanTramTargetQdFromPaste);
                }
                const target = parseFloat(goals.doanhThuQD) || 0;
                if (target > 0) {
                    const currentRev = dtQd / 1000000;
                    const projectedRev = (currentRev / currentDay) * totalDaysInMonth;
                    return formatters.formatPercentage(projectedRev / target);
                }
                return '0%';
            }

            if (tag === '%HT_DTT') {
                const targetMillions = parseFloat(goals.doanhThuThuc) || 0;
                const targetFull = targetMillions * 1000000; 

                if (targetFull > 0) {
                    if (dtThucDuKienFromPaste > 0) {
                        return formatters.formatPercentage(dtThucDuKienFromPaste / targetFull);
                    }
                    const projectedRev = (dtThuc / currentDay) * totalDaysInMonth;
                    return formatters.formatPercentage(projectedRev / targetFull);
                }
                return '0%';
            }

            if (tag === 'DT_CHUAXUAT') return formatters.formatRevenue(supermarketReport.doanhThuQuyDoiChuaXuat || 0) + " tr";
            if (tag === 'SS_CUNGKY') return comparisonPercentage;

            if (tag.startsWith('TD_')) {
                const total = competitionData?.length || 0;
                const dat = (competitionData || []).filter(d => parseFloat(String(d.hoanThanh).replace('%','')) >= 100).length;
                if (tag === 'TD_TONG_CT') return total;
                if (tag === 'TD_CT_DAT') return dat;
                if (tag === 'TD_CT_CHUADAT') return total - dat;
                if (tag === 'TD_TYLE_DAT') return total > 0 ? formatters.formatPercentage(dat / total) : '0%';
            }

            if (tag === 'TOP_QDC_INFO') {
                if (!supermarketReport.qdc) return " (kh√¥ng c√≥)";
                const qdcArray = Object.values(supermarketReport.qdc).filter(item => item.sl > 0);
                const sortedQDC = qdcArray.sort((a,b) => b.dtqd - a.dtqd);
                return "\n" + sortedQDC.map(item => `  ‚Ä¢ ${item.name}: SL ${formatters.formatNumber(item.sl)}, TB ${formatters.formatNumber(item.sl / currentDay, 1)}/ng√†y`).join("\n");
            }
            if (tag === 'TOP_NGANHHANG_SL') {
                if (!supermarketReport.nganhHangChiTiet) return " (kh√¥ng c√≥)";
                const nganhHangArray = Object.values(supermarketReport.nganhHangChiTiet).filter(item => item.quantity > 0);
                const topNganhHang = nganhHangArray.sort((a,b) => b.quantity - a.quantity).slice(0, 10);
                return "\n" + topNganhHang.map(item => `  ‚Ä¢ ${utils.cleanCategoryName(item.name)}: ${formatters.formatNumber(item.quantity)}`).join("\n");
            }

            const rankingRegex = /^(TOP|BOT)(\d)_(\w+)_([\s\S]+)$/;
            const rankingMatch = tag.match(rankingRegex);
            if (rankingMatch && rankingReportData) {
                const [_, type, count, metric, department] = rankingMatch;
                const cleanDepartment = department.replace(/@msnv$/, '').trim();
                const direction = type === 'TOP' ? 'desc' : 'asc';
                const metricInfo = tagMapping[metric];
                if (metricInfo) {
                    let dataForRanking = rankingReportData;
                    if (metric === 'THUNHAP') {
                         const masterData = get(masterReportData);
                         if (masterData && masterData.sknv.length > 0) {
                            dataForRanking = masterData.sknv;
                         }
                    }
                    const ranking = composerServices.getEmployeeRanking(dataForRanking, metricInfo.key, direction, parseInt(count), cleanDepartment);
                    return composerServices.formatEmployeeList(ranking, metricInfo.key, metricInfo.format);
                }
            }

            const botTargetRegex = /^BOT_TARGET_(\w+)_([\s\S]+)$/;
            const botTargetMatch = tag.match(botTargetRegex);
            if(botTargetMatch && rankingReportData) {
                let [_, metric, department] = botTargetMatch;
                department = department.replace(/@msnv$/, '').trim();
                const metricInfo = botTargetMapping[metric];
                if (metricInfo) {
                    const employeeList = composerServices.getEmployeesBelowTarget(rankingReportData, metricInfo.dataKey, metricInfo.goalKey, department);
                    return composerServices.formatEmployeeList(employeeList, metricInfo.dataKey, metricInfo.format);
                }
            }

            const qdcInfoRegex = /^QDC_INFO_(.+)$/;
            const qdcMatch = tag.match(qdcInfoRegex);
            if(qdcMatch && supermarketReport.qdc){
                const itemName = qdcMatch[1];
                const itemData = Object.values(supermarketReport.qdc).find(i => i.name === itemName);
                return itemData ? `SL ${formatters.formatNumber(itemData.sl)}, TB ${formatters.formatNumber(itemData.sl / currentDay, 1)}/ng√†y` : '(N/A)';
            }

            const nhInfoRegex = /^NH_INFO_(.+)$/;
            const nhMatch = tag.match(nhInfoRegex);
            if(nhMatch && supermarketReport.nganhHangChiTiet){
                const itemName = nhMatch[1];
                 const itemData = Object.values(supermarketReport.nganhHangChiTiet).find(i => utils.cleanCategoryName(i.name) === itemName);
                return itemData ? `SL ${formatters.formatNumber(itemData.quantity)}, TB ${formatters.formatNumber(itemData.quantity / currentDay, 1)}/ng√†y` : '(N/A)';
            }

            return match;
        });
    },
};

export const composerService = composerServices;
<<< FILE_END: src/services/composerService.js

>>> FILE_START: src/services/data/cacheHandler.js
import { get } from 'svelte/store';
import { danhSachNhanVien, competitionData, pastedThiDuaReportData, thuongERPData, thuongERPDataThangTruoc } from '../../stores.js';
import { storage } from '../storage.service.js';
import { dataProcessing } from '../dataProcessing.js';
import { adminService } from '../admin.service.js';
import { FILE_MAPPING, LOCAL_DSNV_FILENAME_KEY } from './constants.js';
import { updateSyncState } from './syncHandler.js';

export const cacheHandler = {
    async loadAllFromCache() {
        try { await storage.openDB(); } catch (err) { console.error("L·ªói DB:", err); }

        adminService.loadMappingsGlobal();

        console.log("[DataService] B·∫Øt ƒë·∫ßu t·∫£i DSNV t·ª´ cache...");
        const dsnvData = await storage.getItem('saved_danhsachnv');
        if (dsnvData && dsnvData.length > 0) {
            danhSachNhanVien.set(dsnvData);
            const fileName = localStorage.getItem(LOCAL_DSNV_FILENAME_KEY) || 'DSNV (Cache)';
            updateSyncState('saved_danhsachnv', 'cached', `‚úì ƒê√£ t·∫£i ${dsnvData.length} d√≤ng (Ch·ªâ l∆∞u m√°y n√†y)`, { fileName });
        } else {
            updateSyncState('saved_danhsachnv', 'error', 'Ch∆∞a c√≥ DSNV. Vui l√≤ng t·∫£i file.', null);
        }
        
        const otherFiles = ['saved_giocong', 'saved_ycx', 'saved_thuongnong', 'saved_ycx_thangtruoc', 'saved_thuongnong_thangtruoc'];
        await Promise.all(otherFiles.map(async (key) => {
            const data = await storage.getItem(key);
            if (data && data.length > 0) {
                FILE_MAPPING[key].store.set(data);
                updateSyncState(key, 'cached', `‚úì ƒê√£ t·∫£i ${data.length} d√≤ng (Local)`, null);
             }
        }));

        console.log("[DataService] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω d·ªØ li·ªáu Paste...");
        try {
            const luykeText = localStorage.getItem('daily_paste_luyke');
            if (luykeText) {
                dataProcessing.parseLuyKePastedData(luykeText);
                dataProcessing.parseCompetitionDataFromLuyKe(luykeText);
                updateSyncState('daily_paste_luyke', 'cached', `(Local)`, null);
            }
            const erpText = localStorage.getItem('daily_paste_thuongerp');
            if (erpText) {
                const data = dataProcessing.processThuongERP(erpText);
                thuongERPData.set(data);
                updateSyncState('daily_paste_thuongerp', 'cached', `(Local)`, null);
            }
            const rawThiDua = localStorage.getItem('raw_paste_thiduanv');
            if (rawThiDua) {
                const parsedData = dataProcessing.parsePastedThiDuaTableData(rawThiDua);
                if (parsedData.success) {
                    const $competitionData = get(competitionData);
                    const processedData = dataProcessing.processThiDuaNhanVienData(parsedData, $competitionData);
                    pastedThiDuaReportData.set(processedData);
                    updateSyncState('daily_paste_thiduanv', 'cached', `(Local)`, null);
                }
            }
            const erpTTText = localStorage.getItem('saved_thuongerp_thangtruoc');
            if (erpTTText) {
                 const data = dataProcessing.processThuongERP(erpTTText);
                 thuongERPDataThangTruoc.set(data);
                 updateSyncState('saved_thuongerp_thangtruoc', 'cached', `(Local)`, null);
            }
        } catch (err) { console.error("L·ªói t·∫£i cache paste:", err); }
    }
};
<<< FILE_END: src/services/data/cacheHandler.js

>>> FILE_START: src/services/data/constants.js
import { 
    danhSachNhanVien, rawGioCongData, ycxData, thuongNongData,
    ycxDataThangTruoc, thuongNongDataThangTruoc, thuongERPData, 
    thuongERPDataThangTruoc, competitionData, pastedThiDuaReportData
} from '../../stores.js';
import { dataProcessing } from '../dataProcessing.js';

export const LOCAL_DSNV_FILENAME_KEY = '_localDsnvFilename';

export const FILE_MAPPING = {
    'saved_danhsachnv': { store: danhSachNhanVien, normalizeType: 'danhsachnv', name: 'DS Nh√¢n vi√™n', localOnly: true },
    'saved_giocong': { store: rawGioCongData, normalizeType: 'giocong', name: 'Gi·ªù c√¥ng' },
    'saved_ycx': { store: ycxData, normalizeType: 'ycx', name: 'YCX L≈©y k·∫ø' },
    'saved_thuongnong': { store: thuongNongData, normalizeType: 'thuongnong', name: 'Th∆∞·ªüng n√≥ng' },
    'saved_ycx_thangtruoc': { store: ycxDataThangTruoc, normalizeType: 'ycx', name: 'YCX Th√°ng tr∆∞·ªõc' },
    'saved_thuongnong_thangtruoc': { store: thuongNongDataThangTruoc, normalizeType: 'thuongnong', name: 'Th∆∞·ªüng n√≥ng TT' }
};

export const PASTE_MAPPING = {
    'daily_paste_luyke': { 
        processFunc: dataProcessing.parseCompetitionDataFromLuyKe, 
        store: competitionData,
        isThiDuaNV: false,
        name: 'Data L≈©y K·∫ø'
    },
    'daily_paste_thuongerp': { 
        processFunc: dataProcessing.processThuongERP, 
        store: thuongERPData,
        isThiDuaNV: false,
        name: 'Th∆∞·ªüng ERP'
    },
    'saved_thuongerp_thangtruoc': { 
        processFunc: dataProcessing.processThuongERP, 
        store: thuongERPDataThangTruoc,
        isThiDuaNV: false,
        name: 'Th∆∞·ªüng ERP (TT)'
    },
    'daily_paste_thiduanv': { 
        processFunc: dataProcessing.processThiDuaNhanVienData, 
        store: pastedThiDuaReportData,
        isThiDuaNV: true,
        name: 'Thi ƒëua NV'
    }
};
<<< FILE_END: src/services/data/constants.js

>>> FILE_START: src/services/data/fileHandler.js
/* global XLSX */
import { get } from 'svelte/store';
import { 
    selectedWarehouse, 
    currentUser, 
    realtimeYCXData, 
    categoryStructure, 
    brandList, 
    specialProductList 
} from '../../stores.js';
import { dataProcessing } from '../dataProcessing.js';
import { storage, storageService } from '../storage.service.js';
import { datasyncService } from '../datasync.service.js';
import { analyticsService } from '../analytics.service.js';
import { FILE_MAPPING, LOCAL_DSNV_FILENAME_KEY } from './constants.js';
import { updateSyncState } from './syncHandler.js';

// H√†m ƒë·ªçc file Excel th√†nh Workbook
async function _handleFileRead(fileBlob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = new Uint8Array(event.target.result);
                const workbook = XLSX.read(data, { type: 'array', cellDates: true, cellText: true });
                resolve(workbook);
            } catch (err) { reject(err); }
        };
        reader.onerror = (err) => reject(new Error("Kh√¥ng th·ªÉ ƒë·ªçc file."));
        reader.readAsArrayBuffer(fileBlob);
    });
}

export const fileHandler = {
    // 1. X·ª≠ l√Ω c√°c file d·ªØ li·ªáu ch√≠nh (DSNV, Gi·ªù c√¥ng, YCX, Th∆∞·ªüng n√≥ng...)
    async handleFileChange(file, saveKey) {
        const mapping = FILE_MAPPING[saveKey];
        if (!mapping) return { success: false, message: `L·ªói mapping: ${saveKey}` };
        
        updateSyncState(saveKey, 'uploading', 'ƒêang ƒë·ªçc & chu·∫©n h√≥a...');
        
        try {
            const workbook = await _handleFileRead(file);
            const sheetName = workbook.SheetNames[0];
            const rawData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { raw: false, defval: null });
            
            const { normalizedData, success, missingColumns } = dataProcessing.normalizeData(rawData, mapping.normalizeType);
            
            if (!success) {
                updateSyncState(saveKey, 'error', `Thi·∫øu c·ªôt: ${missingColumns.join(', ')}`);
                return { success: false, message: `Thi·∫øu c·ªôt b·∫Øt bu·ªôc: ${missingColumns.join(', ')}` };
            }

            // L∆∞u v√†o Store
            mapping.store.set(normalizedData);
            
            // L∆∞u v√†o IndexedDB (Cache Local)
            await storage.setItem(saveKey, normalizedData); 
            
            // X·ª≠ l√Ω ri√™ng cho DSNV (ch·ªâ l∆∞u local)
            if (saveKey === 'saved_danhsachnv') {
                localStorage.setItem(LOCAL_DSNV_FILENAME_KEY, file.name);
                updateSyncState(saveKey, 'cached', `‚úì ƒê√£ t·∫£i ${normalizedData.length} d√≤ng (Local)`, null);
                return { success: true, count: normalizedData.length, message: `Th√†nh c√¥ng` };
            }

            // X·ª≠ l√Ω Upload l√™n Cloud (n·∫øu ƒë√£ ch·ªçn kho)
            const warehouse = get(selectedWarehouse);
            if (warehouse && !mapping.localOnly) {
                updateSyncState(saveKey, 'uploading', 'ƒêang t·∫£i l√™n Cloud...');
                try {
                    const path = `warehouse_data/${warehouse}/${saveKey}_${Date.now()}_${file.name}`;
                    const downloadUrl = await storageService.uploadFileToStorage(file, path);
                    const now = Date.now();
                    
                    const metadata = {
                        downloadURL: downloadUrl,
                        fileName: file.name,
                        fileType: 'excel',
                        rowCount: normalizedData.length,
                        updatedAt: new Date(now),
                        timestamp: now, // [FIX] Th√™m timestamp ƒë·ªÉ so s√°nh ch√≠nh x√°c
                        updatedBy: get(currentUser)?.email || 'T√¥i'
                    };
                    
                    await datasyncService.saveWarehouseMetadata(warehouse, saveKey, metadata);
                    
                    // [FIX] C·∫≠p nh·∫≠t ngay metadata v√†o LocalStorage ƒë·ªÉ tr√°nh conflict phi√™n b·∫£n
                    localStorage.setItem(`_meta_${warehouse}_${saveKey}`, JSON.stringify(metadata));

                    updateSyncState(saveKey, 'synced', `‚úì ƒê√£ ƒë·ªìng b·ªô`, metadata);
                } catch (e) {
                    console.error("L·ªói upload cloud:", e);
                    updateSyncState(saveKey, 'error', `L·ªói l∆∞u Cloud: ${e.message}`, null);
                    // Kh√¥ng return false ·ªü ƒë√¢y v√¨ d·ªØ li·ªáu local ƒë√£ ok
                }
            } else {
                 updateSyncState(saveKey, 'synced', `‚úì ƒê√£ t·∫£i ${normalizedData.length} d√≤ng`, null);
            }
            
            analyticsService.trackAction();
            return { success: true, count: normalizedData.length, message: `Th√†nh c√¥ng` };

        } catch (err) {
            console.error(err);
            updateSyncState(saveKey, 'error', `L·ªói: ${err.message}`, null);
            return { success: false, message: `L·ªói x·ª≠ l√Ω file: ${err.message}` };
        }
    },

    // 2. X·ª≠ l√Ω file Realtime (T∆∞∆°ng t·ª± YCX nh∆∞ng l∆∞u v√†o store ri√™ng)
    async handleRealtimeFileInput(event) {
        const file = event.target.files[0];
        if (!file) return;

        console.log("[FileHandler] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω Realtime:", file.name);
        
        try {
            const workbook = await _handleFileRead(file);
            const sheetName = workbook.SheetNames[0];
            const rawData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { raw: false, defval: null });

            // T√°i s·ª≠ d·ª•ng logic chu·∫©n h√≥a c·ªßa 'ycx' v√¨ c·∫•u tr√∫c file gi·ªëng nhau
            const { normalizedData, success, missingColumns } = dataProcessing.normalizeData(rawData, 'ycx');

            if (!success) {
                alert(`File thi·∫øu c·ªôt: ${missingColumns.join(', ')}`);
                return;
            }

            // C·∫≠p nh·∫≠t store
            realtimeYCXData.set(normalizedData);
            
            // Ghi nh·∫≠n analytics
            analyticsService.trackAction();
            
            console.log(`[FileHandler] ƒê√£ n·∫°p ${normalizedData.length} d√≤ng realtime.`);
            // Reset input
            event.target.value = null;

        } catch (error) {
            console.error("L·ªói x·ª≠ l√Ω Realtime:", error);
            alert("L·ªói ƒë·ªçc file Realtime: " + error.message);
        }
    },

    // 3. X·ª≠ l√Ω file C·∫•u tr√∫c Ng√†nh h√†ng (Admin)
    async handleCategoryFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const workbook = await _handleFileRead(file);
            const sheetName = workbook.SheetNames[0];
            const rawData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { raw: false, defval: null });

            const { success, normalizedData, error } = dataProcessing.normalizeCategoryStructureData(rawData);
            
            if (!success) {
                throw new Error(error);
            }

            // C·∫≠p nh·∫≠t Store
            categoryStructure.set(normalizedData);
            
            // T√°ch danh s√°ch H√£ng (Brand) t·ª´ d·ªØ li·ªáu
            const brands = [...new Set(normalizedData.map(i => i.nhaSanXuat).filter(Boolean))].sort();
            brandList.set(brands);

            console.log(`[FileHandler] ƒê√£ n·∫°p ${normalizedData.length} d√≤ng c·∫•u tr√∫c & ${brands.length} h√£ng.`);
            
            // Reset input
            event.target.value = null;
            return { success: true, count: normalizedData.length };

        } catch (err) {
            console.error("L·ªói file c·∫•u tr√∫c:", err);
            throw err;
        }
    },

    // 4. X·ª≠ l√Ω file S·∫£n ph·∫©m ƒê·∫∑c quy·ªÅn (Admin)
    async handleSpecialProductFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const workbook = await _handleFileRead(file);
            const sheetName = workbook.SheetNames[0];
            const rawData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { raw: false, defval: null });

            const { success, normalizedData, error } = dataProcessing.normalizeSpecialProductData(rawData);

            if (!success) {
                throw new Error(error);
            }

            specialProductList.set(normalizedData);
            console.log(`[FileHandler] ƒê√£ n·∫°p ${normalizedData.length} SPƒêQ.`);
            
            event.target.value = null;
            return { success: true, count: normalizedData.length };

        } catch (err) {
            console.error("L·ªói file SPƒêQ:", err);
            throw err;
        }
    },

    // 5. T·∫£i file m·∫´u
    async handleTemplateDownload() {
        try {
            const url = await storageService.getTemplateDownloadURL();
            if (url) {
                const a = document.createElement('a');
                a.href = url;
                a.target = "_blank";
                a.download = "Template_DSNV.xlsx";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } else {
                alert("Kh√¥ng t√¨m th·∫•y link t·∫£i m·∫´u.");
            }
        } catch (e) {
            console.error("L·ªói t·∫£i template:", e);
            alert("L·ªói khi l·∫•y link t·∫£i m·∫´u: " + e.message);
        }
    }
};
<<< FILE_END: src/services/data/fileHandler.js

>>> FILE_START: src/services/data/pasteHandler.js
import { get } from 'svelte/store';
import { selectedWarehouse, currentUser, competitionData, pastedThiDuaReportData } from '../../stores.js';
import { dataProcessing } from '../dataProcessing.js';
import { storageService } from '../storage.service.js';
import { datasyncService } from '../datasync.service.js';
import { analyticsService } from '../analytics.service.js';
import { PASTE_MAPPING } from './constants.js';
import { updateSyncState } from './syncHandler.js';

export const pasteHandler = {
    async handlePasteChange(pastedText, saveKeyPaste, saveKeyRaw, saveKeyProcessed) {
        const primaryKey = saveKeyProcessed || saveKeyPaste;
        const mapping = PASTE_MAPPING[primaryKey];
        if (!mapping) return { success: false, message: `L·ªói mapping paste` };
        
        updateSyncState(saveKeyPaste, 'uploading', 'ƒêang x·ª≠ l√Ω...');
        try {
            let processedData;
            let processedCount = 0;
            if (mapping.isThiDuaNV) {
                const parsedData = dataProcessing.parsePastedThiDuaTableData(pastedText);
                if (!parsedData.success) throw new Error(parsedData.error);
                dataProcessing.updateCompetitionNameMappings(parsedData.mainHeaders);
                const $competitionData = get(competitionData);
                processedData = dataProcessing.processThiDuaNhanVienData(parsedData, $competitionData);
                mapping.store.set(processedData);
                localStorage.setItem(saveKeyRaw, pastedText);
                localStorage.setItem(saveKeyProcessed, JSON.stringify(processedData));
                processedCount = processedData.length;
            } else if (mapping.processFunc) {
                processedData = mapping.processFunc(pastedText);
                mapping.store.set(processedData);
                localStorage.setItem(saveKeyPaste, pastedText);
                processedCount = processedData?.length || 0;
                if (saveKeyPaste === 'daily_paste_luyke') {
                     const comps = dataProcessing.parseCompetitionDataFromLuyKe(pastedText);
                     dataProcessing.parseLuyKePastedData(pastedText);
                     processedCount = comps.length;
                }
            }
            const warehouse = get(selectedWarehouse);
            if (warehouse) {
                try {
                    updateSyncState(saveKeyPaste, 'uploading', 'ƒêang l∆∞u Cloud...');
                    const blob = new Blob([pastedText], { type: 'text/plain' });
                    const path = `warehouse_data/${warehouse}/${primaryKey}_${Date.now()}.txt`;
                    const downloadUrl = await storageService.uploadFileToStorage(blob, path);
                    const now = Date.now();
                    const metadata = {
                        downloadURL: downloadUrl,
                        fileName: 'du_lieu_dan.txt',
                        fileType: 'text',
                        rowCount: processedCount, 
                        updatedAt: new Date(now),
                        timestamp: now, // [FIX] Th√™m timestamp
                        updatedBy: get(currentUser)?.email || 'T√¥i'
                    };
                    await datasyncService.saveWarehouseMetadata(warehouse, primaryKey, metadata);
                    
                    // [FIX] C·∫≠p nh·∫≠t metadata local ngay l·∫≠p t·ª©c
                    localStorage.setItem(`_meta_${warehouse}_${primaryKey}`, JSON.stringify(metadata));

                    updateSyncState(saveKeyPaste, 'synced', `‚úì ƒê√£ ƒë·ªìng b·ªô`, metadata);
                } catch (e) {
                    console.error("Cloud paste upload error:", e);
                    updateSyncState(saveKeyPaste, 'error', `L·ªói ƒë·ªìng b·ªô Cloud: ${e.message}`);
                }
            } else {
                 updateSyncState(saveKeyPaste, 'cached', `‚úì ƒê√£ x·ª≠ l√Ω (Local)`, null);
            }
            analyticsService.trackAction();
            return { success: true, message: `Th√†nh c√¥ng` };
        } catch (err) {
            updateSyncState(saveKeyPaste, 'error', `L·ªói: ${err.message}`);
            return { success: false, message: `L·ªói: ${err.message}` };
        }
    }
};
<<< FILE_END: src/services/data/pasteHandler.js

>>> FILE_START: src/services/data/syncHandler.js
/* global XLSX */
import { get } from 'svelte/store';
import { fileSyncState, selectedWarehouse, currentUser, competitionData, pastedThiDuaReportData, thuongERPData, thuongERPDataThangTruoc } from '../../stores.js';
import { datasyncService } from '../datasync.service.js';
import { storage } from '../storage.service.js';
import { dataProcessing } from '../dataProcessing.js';
import { FILE_MAPPING, PASTE_MAPPING } from './constants.js';

export function updateSyncState(key, status, message, metadata = null) {
    fileSyncState.update(s => ({
        ...s,
        [key]: { status, message, metadata, timestamp: Date.now() }
    }));
}

export function formatTimeAgo(dateInput) {
    if (!dateInput) return '';
    try {
        const date = dateInput.toDate ? dateInput.toDate() : new Date(dateInput);
        if (isNaN(date.getTime())) return ''; // Check ng√†y l·ªói
        const seconds = Math.floor((new Date() - date) / 1000);
        
        let interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " gi·ªù tr∆∞·ªõc";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " ph√∫t tr∆∞·ªõc";
        return "v·ª´a xong";
    } catch (e) {
        return '';
    }
}

// --- [DEBUG] H√ÄM CHU·∫®N H√ìA TH·ªúI GIAN C·ª∞C M·∫†NH ---
function getMetaTimestamp(meta, sourceName) {
    if (!meta) return 0;
    
    let ts = 0;
    let method = 'none';

    // 1. ∆Øu ti√™n Timestamp s·ªë h·ªçc (Do code m·ªõi th√™m v√†o)
    if (typeof meta.timestamp === 'number') {
        ts = meta.timestamp;
        method = 'prop_timestamp';
    }
    // 2. X·ª≠ l√Ω updatedAt
    else if (meta.updatedAt) {
        // Tr∆∞·ªùng h·ª£p A: Firestore Timestamp Object (c√≥ h√†m toMillis)
        if (typeof meta.updatedAt.toMillis === 'function') {
            ts = meta.updatedAt.toMillis();
            method = 'firestore_fn';
        }
        // Tr∆∞·ªùng h·ª£p B: Object { seconds, nanoseconds } (JSON t·ª´ Firestore)
        else if (typeof meta.updatedAt.seconds === 'number') {
            ts = meta.updatedAt.seconds * 1000;
            method = 'firestore_json';
        }
        // Tr∆∞·ªùng h·ª£p C: Chu·ªói ISO String ho·∫∑c Date Object
        else {
            const d = new Date(meta.updatedAt);
            if (!isNaN(d.getTime())) {
                ts = d.getTime();
                method = 'date_parse';
            }
        }
    }

    // Log debug ƒë·ªÉ ki·ªÉm tra
    console.log(`[SYNC-DEBUG] ${sourceName} | Method: ${method} | TS: ${ts} | Time: ${new Date(ts).toLocaleString()}`);
    return ts;
}

export const syncHandler = {
    async syncDownFromCloud(warehouse) {
        if (!warehouse) return { success: false, message: "Ch∆∞a ch·ªçn kho." };
        console.group(`[SYNC-DEBUG] B·∫Øt ƒë·∫ßu ki·ªÉm tra kho: ${warehouse}`);
        
        // Set tr·∫°ng th√°i "Checking"
        [...Object.keys(FILE_MAPPING), ...Object.keys(PASTE_MAPPING)].forEach(key => {
            const mapping = FILE_MAPPING[key] || PASTE_MAPPING[key];
            if (mapping && !mapping.localOnly) updateSyncState(key, 'checking', 'ƒêang so s√°nh d·ªØ li·ªáu...', null);
        });

        try {
            // L·∫•y d·ªØ li·ªáu m·ªõi nh·∫•t t·ª´ Cloud (Server)
            const cloudData = await datasyncService.loadWarehouseData(warehouse);
            if (!cloudData) {
                 console.groupEnd();
                 return { success: true, message: "Kho ch∆∞a c√≥ d·ªØ li·ªáu tr√™n Cloud." };
            }
            const userEmail = get(currentUser)?.email;

            // H√†m x·ª≠ l√Ω chung cho c·∫£ File v√† Paste
            const processKey = async (key, mapping) => {
                const cloudMeta = cloudData[key];
                
                // L·∫•y Local Meta
                const localMetaStr = localStorage.getItem(`_meta_${warehouse}_${key}`);
                const localMeta = localMetaStr ? JSON.parse(localMetaStr) : {};
                
                if (!cloudMeta) return;

                console.groupCollapsed(`üîç Ki·ªÉm tra: ${key}`);
                
                const timeAgo = formatTimeAgo(cloudMeta.updatedAt);
                const isMyUpload = cloudMeta.updatedBy === userEmail;

                // --- SO S√ÅNH TH·ªúI GIAN ---
                const cloudTs = getMetaTimestamp(cloudMeta, 'CLOUD');
                const localTs = getMetaTimestamp(localMeta, 'LOCAL');
                
                // Logic: Cloud ph·∫£i l·ªõn h∆°n Local √≠t nh·∫•t 2 gi√¢y (tr√°nh sai s·ªë m·∫°ng)
                const isNewer = cloudTs > (localTs + 2000); 

                console.log(`K·∫øt qu·∫£: Cloud ${isNewer ? '>' : '<='} Local. Ch√™nh l·ªách: ${(cloudTs - localTs)/1000}s`);

                const currentStoreData = get(mapping.store);
                const isStoreEmpty = !currentStoreData || currentStoreData.length === 0;

                if (isNewer) {
                    const msg = isMyUpload ? `C√≥ b·∫£n m·ªõi t·ª´ b·∫°n ${timeAgo}` : `C√≥ c·∫≠p nh·∫≠t m·ªõi t·ª´ ${cloudMeta.updatedBy} ${timeAgo}`;
                    
                    // [T√ôY CH·ªåN M·∫†NH TAY] N·∫øu Store ƒëang tr·ªëng HO·∫∂C Local qu√° c≈©, t·ª± ƒë·ªông t·∫£i lu√¥n
                    // Hi·ªán t·∫°i: Ch·ªâ b√°o Update Available (ƒë·ªÉ an to√†n). 
                    // N·∫øu b·∫°n mu·ªën t·ª± t·∫£i lu√¥n khi F5, b·ªè comment d√≤ng d∆∞·ªõi:
                    // if (isStoreEmpty) { 
                        updateSyncState(key, 'update_available', msg, cloudMeta);
                    // } else { ... logic auto download ... }
                    
                    console.log("-> Tr·∫°ng th√°i: UPDATE AVAILABLE");
                } else {
                    if (isStoreEmpty) {
                        console.log("-> Local r·ªóng -> Auto Download.");
                        updateSyncState(key, 'downloading', 'ƒêang t·ª± ƒë·ªông t·∫£i v·ªÅ...', cloudMeta);
                        await this.downloadFileFromCloud(key);
                    } else {
                        console.log("-> ƒê√£ ƒë·ªìng b·ªô (Local m·ªõi h∆°n ho·∫∑c b·∫±ng).");
                        updateSyncState(key, 'synced', `‚úì ƒê√£ ƒë·ªìng b·ªô ${timeAgo}`, cloudMeta);
                    }
                }
                console.groupEnd();
            };

            // Ch·∫°y v√≤ng l·∫∑p ki·ªÉm tra
            for (const [key, mapping] of Object.entries(FILE_MAPPING)) {
                if (mapping.localOnly) continue;
                await processKey(key, mapping);
            }
            for (const [key, mapping] of Object.entries(PASTE_MAPPING)) {
                await processKey(key, mapping);
            }

            console.log("‚úÖ Ho√†n t·∫•t ki·ªÉm tra ƒë·ªìng b·ªô.");
            console.groupEnd();
            return { success: true, message: `ƒê√£ ki·ªÉm tra d·ªØ li·ªáu kho ${warehouse}.` };

        } catch (error) {
            console.error("Sync error:", error);
            console.groupEnd();
            return { success: false, message: "L·ªói k·∫øt n·ªëi Cloud: " + error.message };
        }
    },

    async downloadFileFromCloud(key) {
        const state = get(fileSyncState)[key];
        const warehouse = get(selectedWarehouse);
        
        // [FIX] N·∫øu kh√¥ng c√≥ metadata trong state (do b·∫•m n√∫t t·∫£i khi ch∆∞a check xong), 
        // th·ª≠ l·∫•y t·ª´ cloudData (c·∫ßn load l·∫°i ho·∫∑c truy·ªÅn v√†o). 
        // ·ªû ƒë√¢y ta gi·∫£ ƒë·ªãnh state ƒë√£ c√≥ meta t·ª´ b∆∞·ªõc syncDownFromCloud
        if (!state?.metadata?.downloadURL || !warehouse) {
            console.error(`[Download] Kh√¥ng t√¨m th·∫•y URL t·∫£i cho ${key}`);
            return;
        }
        
        updateSyncState(key, 'downloading', 'ƒêang t·∫£i xu·ªëng...', state.metadata);
        console.log(`[Download] B·∫Øt ƒë·∫ßu t·∫£i ${key} t·ª´ ${state.metadata.downloadURL}`);
        
        try {
            // Th√™m timestamp v√†o URL ƒë·ªÉ tr√°nh Cache tr√¨nh duy·ªát (Browser Caching)
            const cacheBusterUrl = `${state.metadata.downloadURL}${state.metadata.downloadURL.includes('?') ? '&' : '?'}t=${Date.now()}`;
            const response = await fetch(cacheBusterUrl);
            
            if (FILE_MAPPING[key]) {
                const blob = await response.blob();
                const workbook = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                         const data = new Uint8Array(e.target.result);
                         resolve(XLSX.read(data, { type: 'array', cellDates: true, cellText: true }));
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(blob);
                });
                const rawData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]], { raw: false, defval: null });
                const mapping = FILE_MAPPING[key];
                const { normalizedData } = dataProcessing.normalizeData(rawData, mapping.normalizeType);
                mapping.store.set(normalizedData);
                await storage.setItem(key, normalizedData);
                
                // [FIX] L∆∞u Timestamp chu·∫©n
                const savedTimestamp = getMetaTimestamp(state.metadata, 'SAVE_FILE');
                const metaToSave = { ...state.metadata, timestamp: savedTimestamp || Date.now() };
                
                localStorage.setItem(`_meta_${warehouse}_${key}`, JSON.stringify(metaToSave));
                updateSyncState(key, 'synced', `‚úì ƒê√£ ƒë·ªìng b·ªô (${normalizedData.length} d√≤ng)`, metaToSave);
            
            } else if (PASTE_MAPPING[key]) {
                const textContent = await response.text();
                const mapping = PASTE_MAPPING[key];
                let processedCount = 0;
                
                if (mapping.isThiDuaNV) {
                     localStorage.setItem('raw_paste_thiduanv', textContent);
                    const parsedData = dataProcessing.parsePastedThiDuaTableData(textContent);
                    if (parsedData.success) {
                        dataProcessing.updateCompetitionNameMappings(parsedData.mainHeaders);
                        const $competitionData = get(competitionData);
                        const processedData = dataProcessing.processThiDuaNhanVienData(parsedData, $competitionData);
                        mapping.store.set(processedData);
                        processedCount = processedData.length;
                        localStorage.setItem('daily_paste_thiduanv', JSON.stringify(processedData)); 
                    }
                } else if (mapping.processFunc) {
                    const processedData = mapping.processFunc(textContent);
                    mapping.store.set(processedData);
                    processedCount = processedData?.length || 0;
                    localStorage.setItem(key, textContent);
                    
                    if (key === 'daily_paste_luyke') {
                         const comps = dataProcessing.parseCompetitionDataFromLuyKe(textContent);
                         dataProcessing.parseLuyKePastedData(textContent);
                         processedCount = comps.length;
                    }
                }
                
                // [FIX] L∆∞u Timestamp chu·∫©n
                const savedTimestamp = getMetaTimestamp(state.metadata, 'SAVE_PASTE');
                const metaToSave = { 
                    ...state.metadata, 
                    timestamp: savedTimestamp || Date.now(),
                    rowCount: processedCount 
                };
                
                localStorage.setItem(`_meta_${warehouse}_${key}`, JSON.stringify(metaToSave));
                updateSyncState(key, 'synced', `‚úì ƒê√£ ƒë·ªìng b·ªô`, metaToSave);
                window.dispatchEvent(new CustomEvent('cloud-paste-loaded', { detail: { key, text: textContent } }));
            }
            console.log(`[Download] Th√†nh c√¥ng ${key}`);
            return { success: true };
        } catch (e) {
            console.error(e);
            updateSyncState(key, 'error', 'L·ªói t·∫£i file: ' + e.message, state.metadata);
            return { success: false, message: e.message };
        }
    }
};
<<< FILE_END: src/services/data/syncHandler.js

>>> FILE_START: src/services/dataProcessing.js
// src/services/dataProcessing.js
// Version 3.0 - Modular Facade
// File n√†y ƒë√≥ng vai tr√≤ t·∫≠p h·ª£p c√°c h√†m t·ª´ th∆∞ m·ª•c processing/
// Gi√∫p gi·ªØ nguy√™n API c≈© ƒë·ªÉ kh√¥ng l√†m h·ªèng c√°c component ƒëang s·ª≠ d·ª•ng.

import { helpers } from './processing/helpers.js';
import { normalizers } from './processing/normalizers.js';
import { parsers } from './processing/parsers.js';
import { processors } from './processing/processors.js';

export const dataProcessing = {
    // --- Helpers ---
    findColumnName: helpers.findColumnName,
    getHinhThucXuatTinhDoanhThu: helpers.getHinhThucXuatTinhDoanhThu,
    getHinhThucXuatTraGop: helpers.getHinhThucXuatTraGop,
    getHeSoQuyDoi: helpers.getHeSoQuyDoi,
    _cleanCompetitionName: helpers.cleanCompetitionName,
    classifyInsurance: helpers.classifyInsurance,
    _findHeaderAndProcess: helpers.findHeaderAndProcess, // Public alias cho processors d√πng

    // --- Normalizers ---
    normalizeData: normalizers.normalizeData,
    normalizeCategoryStructureData: normalizers.normalizeCategoryStructureData,
    normalizeSpecialProductData: normalizers.normalizeSpecialProductData,
    normalizeBrandData: normalizers.normalizeBrandData,

    // --- Parsers ---
    processThuongERP: parsers.processThuongERP,
    parseLuyKePastedData: parsers.parseLuyKePastedData,
    parseCompetitionDataFromLuyKe: parsers.parseCompetitionDataFromLuyKe,
    parsePastedThiDuaTableData: parsers.parsePastedThiDuaTableData,

    // --- Processors ---
    debugCompetitionFiltering: processors.debugCompetitionFiltering,
    updateCompetitionNameMappings: processors.updateCompetitionNameMappings,
    processThiDuaNhanVienData: processors.processThiDuaNhanVienData,
    processGioCongData: processors.processGioCongData,
    processThiDuaVungFile: processors.processThiDuaVungFile
};
<<< FILE_END: src/services/dataProcessing.js

>>> FILE_START: src/services/dataService.js
// src/services/dataService.js
import { fileHandler } from './data/fileHandler.js';
import { pasteHandler } from './data/pasteHandler.js';
import { syncHandler } from './data/syncHandler.js';
import { cacheHandler } from './data/cacheHandler.js';
// [NEW] Import th√™m ƒë·ªÉ x·ª≠ l√Ω load config
import { datasyncService } from './datasync.service.js';
import { localCompetitionConfigs, specialProductList } from '../stores.js';

export const dataService = {
    appController: null,
    init(controller) { this.appController = controller; },

    // --- File Handlers ---
    handleFileChange: (file, key) => fileHandler.handleFileChange(file, key),
    handleRealtimeFileInput: (event) => fileHandler.handleRealtimeFileInput(event),
    handleCategoryFile: (event) => fileHandler.handleCategoryFile(event),
    handleSpecialProductFileUpload: (event) => fileHandler.handleSpecialProductFileUpload(event),
    handleTemplateDownload: () => fileHandler.handleTemplateDownload(),

    // --- Paste Handlers ---
    handlePasteChange: (text, key1, key2, key3) => pasteHandler.handlePasteChange(text, key1, key2, key3),

    // --- Sync & Cache ---
    syncDownFromCloud: (wh) => syncHandler.syncDownFromCloud(wh),
    downloadFileFromCloud: (key) => syncHandler.downloadFileFromCloud(key),
    loadAllFromCache: () => cacheHandler.loadAllFromCache(),

    _getSavedMetadata(warehouse, dataType) { return null; },

    // [NEW] H√†m t·∫£i to√†n b·ªô c·∫•u h√¨nh ph·ª• tr·ª£ c·ªßa Kho (Thi ƒëua, SPƒêQ...)
    // H√†m n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi khi ch·ªçn Kho
    async loadWarehouseSettings(warehouse) {
        if (!warehouse) return;
        console.log(`[DataService] Loading settings for warehouse: ${warehouse}`);
        
        try {
            // 1. T·∫£i c·∫•u h√¨nh Thi ƒëua (User)
            const competitions = await datasyncService.loadCompetitionConfigs(warehouse);
            if (competitions) {
                localCompetitionConfigs.set(competitions);
                console.log(`[DataService] Loaded ${competitions.length} competitions.`);
            } else {
                localCompetitionConfigs.set([]);
            }

            // 2. T·∫£i danh s√°ch SPƒêQ (n·∫øu c√≥ l∆∞u theo kho - logic m·ªü r·ªông)
            // const spList = await datasyncService.loadSpecialPrograms(warehouse);
            // ...

        } catch (error) {
            console.error("[DataService] Error loading warehouse settings:", error);
        }
    }
};
<<< FILE_END: src/services/dataService.js

>>> FILE_START: src/services/datasync.service.js
// src/services/datasync.service.js
import { doc, setDoc, getDoc, serverTimestamp } from "firebase/firestore"; 
import { firebaseStore, currentUser } from '../stores.js'; 
import { get } from 'svelte/store';

const getDB = () => {
    const fb = get(firebaseStore);
    return fb.db;
};

const getCurrentUserEmail = () => {
    const user = get(currentUser);
    return user ? user.email : 'unknown';
};

export const datasyncService = {
    // --- M·ª§C TI√äU (GOALS) ---
    // L∆∞u c·∫•u h√¨nh m·ª•c ti√™u (L≈©y k·∫ø + Realtime) cho kho
    async saveGoalSettings(kho, type, settings) {
        const db = getDB();
        if (!db || !kho) return;

        // type: 'luyke' ho·∫∑c 'realtime'
        const fieldName = type === 'luyke' ? 'luykeGoals' : 'realtimeGoals';

        const khoRef = doc(db, "warehouseData", kho);
        try {
            await setDoc(khoRef, {
                [fieldName]: settings,
                [`${fieldName}UpdatedAt`]: serverTimestamp(),
                [`${fieldName}UpdatedBy`]: getCurrentUserEmail()
            }, { merge: true });
            console.log(`[DataSync] ƒê√£ l∆∞u m·ª•c ti√™u ${type} cho kho ${kho}`);
        } catch (error) {
            console.error(`[DataSync] L·ªói l∆∞u m·ª•c ti√™u ${type}:`, error);
        }
    },

    // T·∫£i c·∫•u h√¨nh m·ª•c ti√™u
    async loadGoalSettings(kho) {
        const db = getDB();
        if (!db || !kho) return { luyke: {}, realtime: {} };

        const khoRef = doc(db, "warehouseData", kho);
        try {
            const docSnap = await getDoc(khoRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                return {
                    luyke: data.luykeGoals || {},
                    realtime: data.realtimeGoals || {}
                };
            }
            return { luyke: {}, realtime: {} };
        } catch (e) {
            console.error("[DataSync] L·ªói t·∫£i m·ª•c ti√™u:", e);
            return { luyke: {}, realtime: {} };
        }
    },

    // --- C√ÅC H√ÄM KH√ÅC (GI·ªÆ NGUY√äN) ---
    async saveQdcConfig(kho, config) {
        const db = getDB();
        if (!db || !kho) return;
        const khoRef = doc(db, "warehouseData", kho);
        try {
            await setDoc(khoRef, {
                qdcConfig: config,
                qdcConfigUpdatedAt: serverTimestamp(),
                qdcConfigUpdatedBy: getCurrentUserEmail()
            }, { merge: true });
        } catch (error) { console.error(error); }
    },

    async loadQdcConfig(kho) {
        const db = getDB();
        if (!db || !kho) return null;
        const khoRef = doc(db, "warehouseData", kho);
        try {
            const docSnap = await getDoc(khoRef);
            return (docSnap.exists() && docSnap.data().qdcConfig) ? docSnap.data().qdcConfig : null;
        } catch (e) { return null; }
    },

    async saveRealtimeHiddenCategories(kho, hiddenList) {
        const db = getDB();
        if (!db || !kho) return;
        const khoRef = doc(db, "warehouseData", kho);
        try {
            await setDoc(khoRef, {
                realtimeConfig: { hiddenCategories: hiddenList, updatedAt: serverTimestamp(), updatedBy: getCurrentUserEmail() }
            }, { merge: true });
        } catch (error) { console.error(error); }
    },

    async loadRealtimeHiddenCategories(kho) {
        const db = getDB();
        if (!db || !kho) return [];
        const khoRef = doc(db, "warehouseData", kho);
        try {
            const docSnap = await getDoc(khoRef);
            return (docSnap.exists() && docSnap.data().realtimeConfig) ? docSnap.data().realtimeConfig.hiddenCategories || [] : [];
        } catch (e) { return []; }
    },

    async savePersonalRevenueTables(kho, tables) {
        const db = getDB();
        if (!db || !kho) return;
        const personalTables = tables.filter(t => !t.isSystem);
        const khoRef = doc(db, "warehouseData", kho);
        try { await setDoc(khoRef, { personalRevenueTables: personalTables, updatedAt: serverTimestamp() }, { merge: true }); } catch (error) { throw error; }
    },

    async loadPersonalRevenueTables(kho) {
        const db = getDB();
        if (!db || !kho) return [];
        const khoRef = doc(db, "warehouseData", kho);
        try { const docSnap = await getDoc(khoRef); return docSnap.exists() ? (docSnap.data().personalRevenueTables || []) : []; } catch(e) { return []; }
    },

    // --- [NEW] B·∫¢NG HI·ªÜU QU·∫¢ C√Å NH√ÇN ---
    async savePersonalPerformanceTables(kho, tables) {
        const db = getDB();
        if (!db || !kho) return;
        const personalTables = tables.filter(t => !t.isSystem);
        const khoRef = doc(db, "warehouseData", kho);
        try { 
            await setDoc(khoRef, { 
                personalPerformanceTables: personalTables, 
                updatedAt: serverTimestamp() 
            }, { merge: true }); 
        } catch (error) { throw error; }
    },

    async loadPersonalPerformanceTables(kho) {
        const db = getDB();
        if (!db || !kho) return [];
        const khoRef = doc(db, "warehouseData", kho);
        try { 
            const docSnap = await getDoc(khoRef); 
            return docSnap.exists() ? (docSnap.data().personalPerformanceTables || []) : []; 
        } catch(e) { 
            console.error("L·ªói t·∫£i b·∫£ng hi·ªáu qu·∫£ c√° nh√¢n:", e);
            return []; 
        }
    },
    // --- END NEW ---

    async saveCustomMetrics(kho, metrics) {
        const db = getDB();
        if (!db || !kho) return;
        const khoRef = doc(db, "warehouseData", kho);
        try { await setDoc(khoRef, { customMetrics: metrics, updatedAt: serverTimestamp() }, { merge: true }); } catch (error) { throw error; }
    },

    async loadCustomMetrics(kho) {
        const db = getDB();
        if (!db || !kho) return [];
        const khoRef = doc(db, "warehouseData", kho);
        try { const docSnap = await getDoc(khoRef); return docSnap.exists() ? (docSnap.data().customMetrics || []) : []; } catch(e) { return []; }
    },

    async saveMetadataToFirestore(kho, dataType, metadata) {
        const db = getDB();
        if (!db || !kho) throw new Error("Invalid parameters.");
        const khoRef = doc(db, "warehouseData", kho);
        const dataToSave = { [dataType]: { ...metadata, updatedAt: serverTimestamp(), updatedBy: getCurrentUserEmail() } };
        try { await setDoc(khoRef, dataToSave, { merge: true }); } catch(e) { throw e; }
    },

    async savePastedDataToFirestore(kho, dataType, content, versionInfo) {
        const db = getDB();
        if (!db || !kho) throw new Error("Invalid parameters.");
        const khoRef = doc(db, "warehouseData", kho);
        const dataToSave = { [dataType]: { content, ...versionInfo, updatedAt: serverTimestamp(), updatedBy: getCurrentUserEmail() } };
        try { await setDoc(khoRef, dataToSave, { merge: true }); } catch(e) { throw e; }
    },

    async saveCompetitionConfigs(kho, configs) {
        const db = getDB();
        if (!db || !kho) return;
        const khoRef = doc(db, "warehouseData", kho);
        try { await setDoc(khoRef, { competitionConfigs: configs, updatedAt: serverTimestamp() }, { merge: true }); } catch (error) { throw error; }
    },

    async loadCompetitionConfigs(kho) {
        const db = getDB();
        if (!db || !kho) return [];
        const khoRef = doc(db, "warehouseData", kho);
        try { const docSnap = await getDoc(khoRef); return docSnap.exists() ? (docSnap.data().competitionConfigs || []) : []; } catch(e) { return []; }
    },

    async saveSpecialPrograms(kho, programs) {
        const db = getDB();
        if (!db || !kho) return;
        const khoRef = doc(db, "warehouseData", kho);
        try { await setDoc(khoRef, { specialPrograms: programs, updatedAt: serverTimestamp() }, { merge: true }); } catch (error) { throw error; }
    },

    async saveWarehouseMetadata(kho, key, metadata) {
        const db = getDB();
        if (!db || !kho) return;
        const khoRef = doc(db, "warehouseData", kho);
        const dataToSave = { [key]: { ...metadata, updatedAt: serverTimestamp(), updatedBy: getCurrentUserEmail() } };
        try { await setDoc(khoRef, dataToSave, { merge: true }); } catch (error) { throw error; }
    },

    async loadWarehouseData(kho) {
        const db = getDB();
        if (!db || !kho) return null;
        const khoRef = doc(db, "warehouseData", kho);
        try { const docSnap = await getDoc(khoRef); return docSnap.exists() ? docSnap.data() : null; } catch (error) { throw error; }
    }
};
<<< FILE_END: src/services/datasync.service.js

>>> FILE_START: src/services/declarations/category.service.js
import { doc, setDoc, getDoc } from "firebase/firestore";
import { 
    macroCategoryConfig, 
    macroProductGroupConfig, 
    categoryNameMapping, 
    groupNameMapping,
    brandNameMapping,
    categoryStructure, 
    brandList,
    efficiencyConfig,
    qdcConfigStore,
    competitionNameMappings
} from '../../stores.js';
import { getDB, notify, sanitizeForFirestore, checkAdmin } from './utils.js';

export const categoryService = {
    // --- CATEGORY & BRAND STRUCTURE ---
    async saveCategoryDataToFirestore(data) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        try {
            const categoryRef = doc(db, "declarations", "categoryStructure");
            await setDoc(categoryRef, { data: sanitizeForFirestore(data.categories || []) });
            const brandRef = doc(db, "declarations", "brandList");
            await setDoc(brandRef, { data: sanitizeForFirestore(data.brands || []) });
            notify('ƒê·ªìng b·ªô d·ªØ li·ªáu khai b√°o th√†nh c√¥ng!', 'success');
        } catch (error) { 
            console.error("Error saving category data:", error);
            notify('L·ªói khi ƒë·ªìng b·ªô d·ªØ li·ªáu l√™n cloud.', 'error'); 
        }
    },

    async loadCategoryDataFromFirestore() {
        const db = getDB();
        if (!db) return { categories: [], brands: [] };
        
        try {
            const catRef = doc(db, "declarations", "categoryStructure");
            const brandRef = doc(db, "declarations", "brandList");
            const [catSnap, brandSnap] = await Promise.all([getDoc(catRef), getDoc(brandRef)]);
            const getArray = (snap) => {
                if (!snap.exists()) return [];
                const d = snap.data();
                return d.data || d.items || d.list || [];
            };
            const categories = getArray(catSnap);
            const brands = getArray(brandSnap);
            
            categoryStructure.set(categories);
            brandList.set(brands);
            return { categories, brands };
        } catch (error) {
            console.error("Error loading category data:", error);
            return { categories: [], brands: [] };
        }
    },

    // --- MAPPINGS & CONFIGS GLOBAL (LOAD ALL) ---
    async loadMappingsGlobal() {
        const db = getDB();
        if (!db) return;
        try {
            console.log("[declarations.category] ƒêang t·∫£i c·∫•u h√¨nh Mapping & Data t·ª´ Cloud...");
            const safeGet = (docSnap, defaultVal = []) => {
                if (!docSnap.exists()) return defaultVal;
                const d = docSnap.data();
                return d.data || d.items || d.mappings || d.configs || d.list || defaultVal;
            };
            const docsToLoad = [
                "macroCategoryConfig", "macroProductGroupConfig", "categoryNameMapping", 
                "groupNameMapping", "brandNameMapping", "efficiencyConfig", 
                "qdcConfig", "competitionNameMappings", "categoryStructure", "brandList"
            ];
            const promises = docsToLoad.map(id => getDoc(doc(db, "declarations", id)));
            const results = await Promise.all(promises);
            
            macroCategoryConfig.set(safeGet(results[0]));
            macroProductGroupConfig.set(safeGet(results[1]));
            categoryNameMapping.set(safeGet(results[2], {}));
            groupNameMapping.set(safeGet(results[3], {}));
            brandNameMapping.set(safeGet(results[4], {}));
            efficiencyConfig.set(safeGet(results[5])); 
            qdcConfigStore.set(safeGet(results[6]));
            competitionNameMappings.set(safeGet(results[7], {}));
            categoryStructure.set(safeGet(results[8]));
            brandList.set(safeGet(results[9]));

            console.log("[declarations.category] ƒê√£ t·∫£i xong Mapping & Configs.");
        } catch (error) {
            console.error("Error loading mappings:", error);
        }
    },

    // --- MACRO CONFIGS ---
    async saveMacroCategoryConfig(data) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        try {
            const docRef = doc(db, "declarations", "macroCategoryConfig");
            await setDoc(docRef, { data: sanitizeForFirestore(data) });
            notify('ƒê√£ l∆∞u C·∫•u h√¨nh Nh√≥m Ng√†nh H√†ng l·ªõn!', 'success');
        } catch (error) { console.error(error); notify('L·ªói l∆∞u c·∫•u h√¨nh: ' + error.message, 'error'); }
    },

    async loadMacroCategoryConfig() {
        const db = getDB();
        const defaultData = [
            { id: 'macro_dt', name: 'ƒêI·ªÜN T·ª¨', items: ['dt_tivi', 'dt_loa', 'Tivi', 'Loa', 'D√†n √¢m thanh', 'Tivi - Loa - D√†n m√°y'] },
            { id: 'macro_dl', name: 'ƒêI·ªÜN L·∫†NH', items: ['dl_maylanh', 'dl_tulanh', 'dl_maygiat', 'T·ªß l·∫°nh', 'M√°y l·∫°nh', 'M√°y gi·∫∑t', 'T·ªß ƒë√¥ng', 'T·ªß m√°t'] },
            { id: 'macro_gd', name: 'GIA D·ª§NG', items: ['gd_quat', 'gd_noi', 'Gia d·ª•ng', 'Qu·∫°t', 'N·ªìi c∆°m', 'B·∫øp', 'M√°y xay', 'M√°y √©p'] },
            { id: 'macro_ict', name: 'ICT', items: ['ict_laptop', 'ict_phone', 'Laptop', 'ƒêi·ªán tho·∫°i', 'Tablet', 'Ph·ª• ki·ªán', 'M√°y t√≠nh b·∫£ng'] }
        ];
        if (!db) return defaultData;
        try {
            const docRef = doc(db, "declarations", "macroCategoryConfig");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const d = docSnap.data();
                const data = d.data || d.items || d.config || [];
                if (data.length > 0) return data;
            }
            return defaultData;
        } catch (e) { console.error("L·ªói t·∫£i macroCategoryConfig:", e); return defaultData; }
    },

    async saveMacroProductGroupConfig(data) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        try {
            const docRef = doc(db, "declarations", "macroProductGroupConfig");
            await setDoc(docRef, { data: sanitizeForFirestore(data) });
            notify('ƒê√£ l∆∞u C·∫•u h√¨nh Nh√≥m H√†ng L·ªõn!', 'success');
        } catch (error) { console.error(error); notify('L·ªói l∆∞u c·∫•u h√¨nh: ' + error.message, 'error'); }
    },

    async loadMacroProductGroupConfig() {
        const db = getDB();
        const defaultData = [];
        if (!db) return defaultData;
        try {
            const docRef = doc(db, "declarations", "macroProductGroupConfig");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const d = docSnap.data();
                const data = d.data || d.items || d.config || [];
                if (data.length > 0) return data;
            }
            return defaultData;
        } catch (e) { console.error("L·ªói t·∫£i macroProductGroupConfig:", e); return defaultData; }
    },

    // --- NAME MAPPINGS ---
    async saveNameMapping(type, data) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        let docId = '';
        if (type === 'category') docId = 'categoryNameMapping';
        else if (type === 'group') docId = 'groupNameMapping';
        else if (type === 'brand') docId = 'brandNameMapping';
        try {
            const docRef = doc(db, "declarations", docId);
            await setDoc(docRef, { data: sanitizeForFirestore(data) });
            notify(`ƒê√£ l∆∞u Mapping t√™n ${type}!`, 'success');
        } catch (error) { console.error(error); notify('L·ªói l∆∞u mapping: ' + error.message, 'error'); }
    },

    async saveCompetitionNameMappings(mappings) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        try {
            const docRef = doc(db, "declarations", "competitionNameMappings");
            await setDoc(docRef, { mappings: sanitizeForFirestore(mappings) });
            notify('ƒê√£ l∆∞u B·∫£ng √Ånh X·∫° T√™n Thi ƒêua th√†nh c√¥ng!', 'success');
        } catch (error) {
            console.error("L·ªói khi l∆∞u B·∫£ng √Ånh X·∫° T√™n Thi ƒêua:", error);
            notify('L·ªói khi l∆∞u t√™n r√∫t g·ªçn l√™n cloud.', 'error');
        }
    },

    // --- SPECIAL PRODUCTS ---
    async saveSpecialProductList(products) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        try {
            const docRef = doc(db, "declarations", "specialProductList");
            await setDoc(docRef, { products: sanitizeForFirestore(products) });
            notify('ƒê√£ l∆∞u Danh s√°ch SPƒêQ th√†nh c√¥ng!', 'success');
        } catch (error) { console.error("Error saving special product list:", error); notify('L·ªói khi l∆∞u danh s√°ch SPƒêQ.', 'error'); }
    },

    async loadSpecialProductList() {
        const db = getDB();
        if (!db) return [];
        try {
            const docRef = doc(db, "declarations", "specialProductList");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const d = docSnap.data();
                return d.products || d.data || [];
            }
            return [];
        } catch (error) { console.error("Error loading SPƒêQ:", error); return []; }
    },

    async loadGlobalSpecialPrograms() {
        const db = getDB();
        if (!db) return [];
        try {
            const docRef = doc(db, "declarations", "globalSpecialPrograms");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const d = docSnap.data();
                return d.programs || d.configs || d.data || [];
            }
            return [];
        } catch (error) { return []; }
    },
};
<<< FILE_END: src/services/declarations/category.service.js

>>> FILE_START: src/services/declarations/config.service.js
import { doc, setDoc, getDoc } from "firebase/firestore";
import { ref, uploadBytes, getDownloadURL } from "firebase/storage";
import { get } from 'svelte/store';
import { firebaseStore, homeConfig } from '../../stores.js';
import { getDB, notify, sanitizeForFirestore, checkAdmin } from './utils.js';

export const configService = {
    // --- HELP CONTENT ---
    async saveHelpContent(contents) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;

        try {
            await Promise.all([
                setDoc(doc(db, "help_content", "data"), { content: contents.data }),
                setDoc(doc(db, "help_content", "luyke"), { content: contents.luyke }),
                setDoc(doc(db, "help_content", "sknv"), { content: contents.sknv }),
                setDoc(doc(db, "help_content", "realtime"), { content: contents.realtime })
            ]);
            notify('ƒê√£ c·∫≠p nh·∫≠t n·ªôi dung h∆∞·ªõng d·∫´n th√†nh c√¥ng!', 'success');
        } catch (error) { 
            console.error("Error saving help content:", error);
            notify('L·ªói khi l∆∞u n·ªôi dung h∆∞·ªõng d·∫´n.', 'error'); 
        }
    },

    // --- HOME CONFIG ---
    async saveHomeConfig(configData) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;

        try {
            const docRef = doc(db, "declarations", "homeConfig");
            await setDoc(docRef, { data: sanitizeForFirestore(configData) });
            homeConfig.set(configData);
            notify('ƒê√£ l∆∞u c·∫•u h√¨nh Trang ch·ªß th√†nh c√¥ng!', 'success');
        } catch (error) { 
            console.error("Error saving home config:", error);
            notify('L·ªói khi l∆∞u c·∫•u h√¨nh trang ch·ªß: ' + error.message, 'error');
        }
    },

    async loadHomeConfig() {
        const db = getDB();
        if (!db) return;
        try {
            const docRef = doc(db, "declarations", "homeConfig");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const raw = docSnap.data();
                const data = raw.data || raw.config || raw;
                if (data) homeConfig.set(data);
            }
        } catch (error) { console.error("Error loading home config:", error); }
    },

    // --- UPLOAD IMAGE ---
    async uploadImage(file, folder = 'slides') {
        const fb = get(firebaseStore);
        if (!fb.storage) {
            console.warn("Firebase Storage ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o trong firebaseStore.");
            return null;
        }

        try {
            const fileName = `${Date.now()}_${file.name}`;
            const storageRef = ref(fb.storage, `${folder}/${fileName}`);
            
            const snapshot = await uploadBytes(storageRef, file);
            const downloadURL = await getDownloadURL(snapshot.ref);
            return downloadURL;
        } catch (error) {
            console.error("Upload failed:", error);
            throw error;
        }
    }
};
<<< FILE_END: src/services/declarations/config.service.js

>>> FILE_START: src/services/declarations/performance.service.js
import { doc, setDoc, getDoc, serverTimestamp } from "firebase/firestore";
import { efficiencyConfig, qdcConfigStore } from '../../stores.js';
import { getDB, notify, sanitizeForFirestore, checkAdmin } from './utils.js';

export const performanceService = {
    // --- SYSTEM REVENUE TABLES ---
    async loadSystemRevenueTables() {
        const db = getDB();
        if (!db) return [];
        try {
            const docRef = doc(db, "declarations", "systemRevenueTables");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const d = docSnap.data();
                const tables = d.tables || d.data || d.items || [];
                console.log(`[PerformanceService] Loaded ${tables.length} system revenue tables.`);
                return tables;
            }
            return [];
        } catch (e) {
            console.error("L·ªói t·∫£i b·∫£ng h·ªá th·ªëng:", e);
            return [];
        }
    },

    async saveSystemRevenueTables(tables) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        const systemTables = tables.filter(t => t.isSystem).map(t => sanitizeForFirestore(t));
        try {
            const docRef = doc(db, "declarations", "systemRevenueTables");
            await setDoc(docRef, { tables: systemTables, updatedAt: serverTimestamp() });
            notify(`ƒê√£ l∆∞u ${systemTables.length} b·∫£ng doanh thu h·ªá th·ªëng l√™n Cloud!`, 'success');
        } catch (error) { 
            console.error("Firebase Error Full:", error);
            notify('L·ªói l∆∞u b·∫£ng h·ªá th·ªëng: ' + error.message, 'error'); 
        }
    },

    // --- SYSTEM PERFORMANCE TABLES ---
    async loadSystemPerformanceTables() {
        const db = getDB();
        if (!db) return [];
        try {
            const docRef = doc(db, "declarations", "systemPerformanceTables");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const d = docSnap.data();
                const tables = d.tables || d.data || [];
                console.log(`[PerformanceService] Loaded ${tables.length} system performance tables.`);
                return tables;
            }
            return [];
        } catch (e) {
            console.error("L·ªói t·∫£i b·∫£ng hi·ªáu qu·∫£ h·ªá th·ªëng:", e);
            return [];
        }
    },

    async saveSystemPerformanceTables(tables) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        
        const systemTables = tables.filter(t => t.isSystem).map(t => sanitizeForFirestore(t));
        try {
            const docRef = doc(db, "declarations", "systemPerformanceTables");
            await setDoc(docRef, { tables: systemTables, updatedAt: serverTimestamp() });
            notify(`ƒê√£ l∆∞u ${systemTables.length} b·∫£ng hi·ªáu qu·∫£ h·ªá th·ªëng l√™n Cloud!`, 'success');
        } catch (error) { 
            console.error("L·ªói l∆∞u b·∫£ng hi·ªáu qu·∫£ h·ªá th·ªëng:", error);
            notify('L·ªói l∆∞u b·∫£ng hi·ªáu qu·∫£ h·ªá th·ªëng: ' + error.message, 'error');
        }
    },

    // --- LOGIC & CALCULATION ---
    async loadDeclarationsFromFirestore() {
        const db = getDB();
        if (!db) return {}; 
        try {
            const declarationIds = ['hinhThucXuat', 'hinhThucXuatGop', 'heSoQuyDoi'];
            const declarations = {};
            await Promise.all(declarationIds.map(async (id) => {
                const docRef = doc(db, "declarations", id);
                const docSnap = await getDoc(docRef);
                declarations[id] = docSnap.exists() ? (docSnap.data().content || '') : '';
            }));
            return declarations;
        } catch (error) { console.error("Error loading declarations:", error); return {}; }
    },

    async saveDeclarationsToFirestore(declarations) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        try {
            await Promise.all([
                setDoc(doc(db, "declarations", "hinhThucXuat"), { content: declarations.ycx }),
                setDoc(doc(db, "declarations", "hinhThucXuatGop"), { content: declarations.ycxGop }),
                setDoc(doc(db, "declarations", "heSoQuyDoi"), { content: declarations.heSo })
            ]);
            notify('ƒê·ªìng b·ªô khai b√°o t√≠nh to√°n th√†nh c√¥ng!', 'success');
        } catch (error) { console.error("Error saving declarations:", error); notify('L·ªói khi ƒë·ªìng b·ªô khai b√°o t√≠nh to√°n.', 'error'); }
    },

    // --- GLOBAL COMPETITION CONFIGS ---
    async saveGlobalCompetitionConfigs(configs) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        try {
            const docRef = doc(db, "declarations", "globalCompetitionConfigs");
            await setDoc(docRef, { configs: sanitizeForFirestore(configs) });
        } catch (error) { console.error("Error saving global comps:", error); }
    },

    async loadGlobalCompetitionConfigs() {
        const db = getDB();
        if (!db) return [];
        try {
            const docRef = doc(db, "declarations", "globalCompetitionConfigs");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const d = docSnap.data();
                return d.configs || d.data || [];
            }
            return [];
        } catch (error) { return []; }
    },

    // --- EFFICIENCY & QDC CONFIGS ---
    async saveEfficiencyConfig(config) {
        const db = getDB();
        if (!db) { notify("L·ªói k·∫øt n·ªëi CSDL!", "error"); return; }
        if (!checkAdmin()) return;
        try {
            const docRef = doc(db, "declarations", "efficiencyConfig");
            await setDoc(docRef, { data: sanitizeForFirestore(config), updatedAt: serverTimestamp() });
            efficiencyConfig.set(config);
            notify('ƒê√£ l∆∞u c·∫•u h√¨nh B·∫£ng Hi·ªáu qu·∫£ h·ªá th·ªëng!', 'success');
        } catch (e) { console.error(e); notify('L·ªói l∆∞u config: ' + e.message, 'error'); }
    },

    async loadEfficiencyConfig() {
        const db = getDB();
        if (!db) return [];
        try {
            const docRef = doc(db, "declarations", "efficiencyConfig");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const d = docSnap.data();
                const data = d.data || d.items || d.config || [];
                // [FIX CRITICAL] C·∫≠p nh·∫≠t store ngay sau khi t·∫£i v·ªÅ
                efficiencyConfig.set(data);
                console.log(`[PerformanceService] ƒê√£ c·∫≠p nh·∫≠t Store EfficiencyConfig v·ªõi ${data.length} d√≤ng.`);
                return data;
            }
            return [];
        } catch (e) { console.error("L·ªói t·∫£i efficiency config:", e); return []; }
    },
    
    async saveQdcConfig(selectedGroups) {
         const db = getDB();
        if (!db || !checkAdmin()) return;
        try {
            const docRef = doc(db, "declarations", "qdcConfig");
            await setDoc(docRef, { data: sanitizeForFirestore(selectedGroups) });
            qdcConfigStore.set(selectedGroups);
        } catch (e) { console.error(e); }
    },
    
    async loadQdcConfig() {
        const db = getDB();
        if (!db) return [];
        try {
            const docRef = doc(db, "declarations", "qdcConfig");
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const d = docSnap.data();
                return d.data || d.config || d.items || [];
            }
            return [];
        } catch (e) { return []; }
    },
};
<<< FILE_END: src/services/declarations/performance.service.js

>>> FILE_START: src/services/declarations/utils.js
import { get } from 'svelte/store';
import { firebaseStore, isAdmin } from '../../stores.js'; // L∆∞u √Ω: ../../ v√¨ ƒëang ·ªü trong services/declarations

export const getDB = () => {
    const fb = get(firebaseStore);
    if (!fb.db) {
        console.warn("Firestore ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.");
        return null;
    }
    return fb.db;
};

export const notify = (msg, type='info') => {
    console.log(`[${type.toUpperCase()}] ${msg}`);
    if(type === 'success' || type === 'error') alert(msg);
};

export const sanitizeForFirestore = (obj) => {
    return JSON.parse(JSON.stringify(obj, (key, value) => {
        return value === undefined ? null : value;
    }));
};

export const checkAdmin = () => {
    if (!get(isAdmin)) {
        notify("B·∫°n c·∫ßn quy·ªÅn Admin ƒë·ªÉ th·ª±c hi·ªán thao t√°c n√†y!", "error");
        return false;
    }
    return true;
};

<<< FILE_END: src/services/declarations/utils.js

>>> FILE_START: src/services/demo.service.js
// src/services/demo.service.js
import { get } from 'svelte/store';
import { 
    danhSachNhanVien, 
    realtimeYCXData, 
    ycxData,
    masterReportData, 
    declarations, 
    categoryStructure, 
    kpiStore, 
    efficiencyConfig, 
    customRevenueTables, 
    customPerformanceTables,
    isDemoMode,
    selectedWarehouse,
    activeTab
} from '../stores.js';

export const demoService = {
    // 1. CH·ª®C NƒÇNG CH·ª§P ·∫¢NH D·ªÆ LI·ªÜU (D√πng cho Admin)
    createSnapshot: () => {
        const snapshot = {
            timestamp: new Date().toISOString(),
            version: '2.0',
            data: {
                danhSachNhanVien: get(danhSachNhanVien),
                realtimeYCXData: get(realtimeYCXData), // D·ªØ li·ªáu th√¥ Realtime
                ycxData: get(ycxData),                 // D·ªØ li·ªáu th√¥ L≈©y k·∫ø
                masterReportData: get(masterReportData), // [QUAN TR·ªåNG] B√°o c√°o ƒê√É X·ª¨ L√ù
                declarations: get(declarations),
                categoryStructure: get(categoryStructure),
                kpiStore: get(kpiStore),
                efficiencyConfig: get(efficiencyConfig),
                customRevenueTables: get(customRevenueTables),
                customPerformanceTables: get(customPerformanceTables)
            }
        };
        return snapshot;
    },

    // H√†m t·∫£i xu·ªëng file JSON
    downloadSnapshot: () => {
        try {
            const data = demoService.createSnapshot();
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `demo_snapshot_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            return true;
        } catch (e) {
            console.error("L·ªói xu·∫•t d·ªØ li·ªáu Demo:", e);
            return false;
        }
    },

    // 2. CH·ª®C NƒÇNG N·∫†P D·ªÆ LI·ªÜU (D√πng cho User Demo)
    loadSnapshot: async (snapshotData) => {
        if (!snapshotData || !snapshotData.data) {
            console.error("D·ªØ li·ªáu Snapshot kh√¥ng h·ª£p l·ªá");
            return false;
        }

        const d = snapshotData.data;

        // B·∫≠t ch·∫ø ƒë·ªô Demo
        isDemoMode.set(true);

        // N·∫°p d·ªØ li·ªáu v√†o t·ª´ng Store
        if (d.danhSachNhanVien) danhSachNhanVien.set(d.danhSachNhanVien);
        if (d.realtimeYCXData) realtimeYCXData.set(d.realtimeYCXData);
        if (d.ycxData) ycxData.set(d.ycxData);
        if (d.masterReportData) masterReportData.set(d.masterReportData); // Quan tr·ªçng nh·∫•t
        if (d.declarations) declarations.set(d.declarations);
        if (d.categoryStructure) categoryStructure.set(d.categoryStructure);
        if (d.kpiStore) kpiStore.set(d.kpiStore);
        if (d.efficiencyConfig) efficiencyConfig.set(d.efficiencyConfig);
        if (d.customRevenueTables) customRevenueTables.set(d.customRevenueTables);
        if (d.customPerformanceTables) customPerformanceTables.set(d.customPerformanceTables);

        return true;
    }
};
<<< FILE_END: src/services/demo.service.js

>>> FILE_START: src/services/employeeService.js
import { get } from 'svelte/store';
import { currentCluster } from '../stores.js';

// ==========================================
// CONFIGURATION
// ==========================================
const API_BASE_URL = 'http://localhost:3000/api'; 
const NETWORK_DELAY = 500; // Gi·∫£ l·∫≠p ƒë·ªô tr·ªÖ m·∫°ng (ms)

// ==========================================
// HELPER FUNCTIONS (H√†m h·ªó tr·ª£)
// ==========================================

// H√†m check an to√†n: Lu√¥n ƒë·∫£m b·∫£o ƒë√£ ch·ªçn Cluster tr∆∞·ªõc khi g·ªçi API
const getClusterIdOrThrow = () => {
    const cluster = get(currentCluster);
    if (!cluster || !cluster.id) {
        throw new Error("MISSING_CLUSTER_ID: Vui l√≤ng ch·ªçn Cluster tr∆∞·ªõc.");
    }
    return cluster.id;
};

// H√†m x·ª≠ l√Ω l·ªói chung cho to√†n b·ªô service
const handleApiError = (error, context) => {
    console.error(`[EmployeeService] Error in ${context}:`, error);
    // C√≥ th·ªÉ th√™m logic g·ª≠i log l√™n server ho·∫∑c hi·ªÉn th·ªã Toast th√¥ng b√°o l·ªói ·ªü ƒë√¢y
    throw error;
};

// ==========================================
// MAIN SERVICE FUNCTIONS (CRUD)
// ==========================================

/**
 * 1. GET ALL: L·∫•y danh s√°ch nh√¢n vi√™n theo Cluster hi·ªán t·∫°i
 */
export const fetchEmployees = async () => {
    try {
        const clusterId = getClusterIdOrThrow();
        console.log(`[GET] Fetching employees for Cluster ${clusterId}...`);

        // --- REAL API CODE (Uncomment khi c√≥ Server) ---
        // const res = await fetch(`${API_BASE_URL}/clusters/${clusterId}/employees`);
        // if (!res.ok) throw new Error(`HTTP Error ${res.status}`);
        // return await res.json();

        // --- MOCK DATA (D·ªØ li·ªáu gi·∫£) ---
        await new Promise(r => setTimeout(r, NETWORK_DELAY));
        return [
            { id: 1, code: 'NV001', name: 'Nguy·ªÖn VƒÉn A', position: 'Frontend Dev', clusterId },
            { id: 2, code: 'NV002', name: 'Tr·∫ßn Th·ªã B', position: 'Backend Dev', clusterId },
            { id: 3, code: 'NV003', name: 'L√™ VƒÉn C', position: 'Tester', clusterId },
            { id: 4, code: 'NV004', name: 'Ph·∫°m Th·ªã D', position: 'Product Owner', clusterId },
            { id: 5, code: 'NV005', name: 'Ho√†ng VƒÉn E', position: 'Designer', clusterId },
        ];
    } catch (error) {
        handleApiError(error, 'fetchEmployees');
        return []; // Tr·∫£ v·ªÅ m·∫£ng r·ªóng ƒë·ªÉ UI kh√¥ng b·ªã crash
    }
};

/**
 * 2. GET DETAILS: L·∫•y chi ti·∫øt 1 nh√¢n vi√™n
 */
export const getEmployeeById = async (employeeId) => {
    try {
        const clusterId = getClusterIdOrThrow();
        console.log(`[GET] Fetching details for employee ${employeeId}...`);

        // Call API...
        await new Promise(r => setTimeout(r, NETWORK_DELAY));
        return { 
            id: employeeId, 
            name: 'Nguy·ªÖn VƒÉn A', 
            email: 'a.nguyen@example.com', 
            phone: '0909123456',
            clusterId 
        };
    } catch (error) {
        handleApiError(error, 'getEmployeeById');
    }
};

/**
 * 3. CREATE: Th√™m nh√¢n vi√™n m·ªõi v√†o Cluster hi·ªán t·∫°i
 */
export const createEmployee = async (payload) => {
    try {
        const clusterId = getClusterIdOrThrow();
        const dataToSend = { ...payload, clusterId }; // G·∫Øn ID cluster v√†o data

        console.log(`[POST] Creating employee in Cluster ${clusterId}:`, dataToSend);

        // Call API...
        // const res = await fetch(`${API_BASE_URL}/employees`, {
        //     method: 'POST',
        //     headers: { 'Content-Type': 'application/json' },
        //     body: JSON.stringify(dataToSend)
        // });
        
        await new Promise(r => setTimeout(r, NETWORK_DELAY));
        return { success: true, newId: Math.floor(Math.random() * 1000) };
    } catch (error) {
        handleApiError(error, 'createEmployee');
    }
};

/**
 * 4. UPDATE: C·∫≠p nh·∫≠t th√¥ng tin nh√¢n vi√™n
 */
export const updateEmployee = async (id, payload) => {
    try {
        getClusterIdOrThrow(); // V·∫´n check cluster cho ch·∫Øc ch·∫Øn
        console.log(`[PUT] Updating employee ${id}:`, payload);

        // Call API...
        await new Promise(r => setTimeout(r, NETWORK_DELAY));
        return { success: true };
    } catch (error) {
        handleApiError(error, 'updateEmployee');
    }
};

/**
 * 5. DELETE: X√≥a nh√¢n vi√™n
 */
export const deleteEmployee = async (id) => {
    try {
        getClusterIdOrThrow();
        console.log(`[DELETE] Removing employee ${id}...`);

        // Call API...
        await new Promise(r => setTimeout(r, NETWORK_DELAY));
        return { success: true };
    } catch (error) {
        handleApiError(error, 'deleteEmployee');
    }
};
<<< FILE_END: src/services/employeeService.js

>>> FILE_START: src/services/excel.service.js
/* global XLSX */
import { notificationStore } from '../stores.js'; // [FIX] D√πng Store thay v√¨ file l·∫ª

export const excelService = {
    /**
     * Xu·∫•t b·∫£ng HTML ra file Excel
     * @param {HTMLElement} tableElement - Element b·∫£ng ho·∫∑c container ch·ª©a b·∫£ng
     * @param {string} fileName - T√™n file mu·ªën l∆∞u
     */
    exportTableToExcel(tableElement, fileName) {
        if (!tableElement) {
            notificationStore.show('Kh√¥ng t√¨m th·∫•y n·ªôi dung ƒë·ªÉ xu·∫•t.', 'error'); // [FIX]
            return;
        }

        // T√¨m th·∫ª table b√™n trong n·∫øu element truy·ªÅn v√†o l√† container
        let table = tableElement.tagName === 'TABLE' 
            ? tableElement 
            : tableElement.querySelector('table');

        if (!table) {
            table = tableElement.querySelector('.department-block table, #sknv-summary-container table, #luyke-competition-content table');
        }

        if (!table) {
            notificationStore.show('Kh√¥ng t√¨m th·∫•y b·∫£ng d·ªØ li·ªáu trong khu v·ª±c n√†y ƒë·ªÉ xu·∫•t.', 'error'); // [FIX]
            return;
        }

        try {
            const wb = XLSX.utils.table_to_book(table, { sheet: "Sheet1" });
            XLSX.writeFile(wb, `${fileName}.xlsx`);
            notificationStore.show(`ƒê√£ xu·∫•t file ${fileName}.xlsx th√†nh c√¥ng!`, 'success'); // [FIX]
        } catch (e) {
            console.error('[ExcelService] L·ªói xu·∫•t Excel:', e);
            notificationStore.show('C√≥ l·ªói x·∫£y ra khi xu·∫•t file Excel.', 'error'); // [FIX]
        }
    }
};
<<< FILE_END: src/services/excel.service.js

>>> FILE_START: src/services/firebase.service.js
// src/services/firebase.service.js
// Version 3.0 - Switch to Legacy Firebase Project (qlst-9e6bd)
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";
import { getStorage } from "firebase/storage";
import { firebaseStore } from '../stores.js';

// Config t·ª´ d·ª± √°n g·ªëc "qlst-9e6bd"
const firebaseConfig = {
  apiKey: "AIzaSyAQ3TWcpa4AnTN-32igGseYDlXrCf1BVew",
  authDomain: "qlst-9e6bd.firebaseapp.com",
  projectId: "qlst-9e6bd",
  storageBucket: "qlst-9e6bd.firebasestorage.app",
  messagingSenderId: "2316705291",
  appId: "1:2316705291:web:ebec2963816aea7585b10e",
  measurementId: "G-M0SM0XHCEK"
};

export const firebaseService = {
    initCore() {
        try {
            console.log("[FirebaseService] Initializing Legacy Firebase (qlst-9e6bd)...");
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);
            const storage = getStorage(app);

            // C·∫≠p nh·∫≠t store ƒë·ªÉ c√°c service kh√°c s·ª≠ d·ª•ng
            firebaseStore.set({
                app,
                auth,
                db,
                storage
            });

            console.log("[FirebaseService] Firebase initialized successfully!");
            return { app, auth, db, storage };
        } catch (error) {
            console.error("[FirebaseService] Initialization failed:", error);
            return null;
        }
    }
};
<<< FILE_END: src/services/firebase.service.js

>>> FILE_START: src/services/modal.service.js
// Version 1.0 - Initial Svelte refactor
// MODULE: UI MODAL MANAGER
// Ch·ª©a c√°c h√†m thu·∫ßn t√∫y ƒë·ªÉ qu·∫£n l√Ω tr·∫°ng th√°i hi·ªÉn th·ªã c·ªßa Modals v√† Drawers.
// T√°i c·∫•u tr√∫c t·ª´ file ui-modal-manager.js g·ªëc

export const modalManager = {
    /**
     * B·∫≠t ho·∫∑c t·∫Øt m·ªôt modal.
     * @param {string} modalId - ID c·ªßa modal (v√≠ d·ª•: 'login-modal').
     * @param {boolean} show - True ƒë·ªÉ hi·ªán, false ƒë·ªÉ ·∫©n.
     */
    toggleModal(modalId, show) {
        const modal = document.getElementById(modalId);
        if (!modal) return;
        modal.classList.toggle('hidden', !show);
    },

    /**
     * B·∫≠t ho·∫∑c t·∫Øt m·ªôt drawer (thanh c√†i ƒë·∫∑t b√™n).
     * @param {string} drawerId - ID c·ªßa drawer (v√≠ d·ª•: 'interface-drawer').
     * @param {boolean} show - True ƒë·ªÉ hi·ªán, false ƒë·ªÉ ·∫©n.
     */
    toggleDrawer(drawerId, show) {
        const drawer = document.getElementById(drawerId);
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('drawer-overlay');

        if (!drawer || !sidebar || !overlay) return;
        if (show) {
            drawer.classList.remove('hidden');
            setTimeout(() => {
                drawer.classList.add('open');
                 sidebar.classList.add('menu-locked');
                 overlay.classList.remove('hidden');
            }, 10);
        } else {
            drawer.classList.remove('open');
            sidebar.classList.remove('menu-locked');
            overlay.classList.add('hidden');
            setTimeout(() => {
                 if (!drawer.classList.contains('open')) {
                     drawer.classList.add('hidden');
                 }
             }, 300);
        }
    },

    /**
     * ƒê√≥ng t·∫•t c·∫£ c√°c drawer ƒëang m·ªü.
     */
    closeAllDrawers() {
        // Ch√∫ng ta g·ªçi h√†m `toggleDrawer` n·ªôi b·ªô
        this.toggleDrawer('interface-drawer', false);
        this.toggleDrawer('goal-drawer', false);
    },
};
<<< FILE_END: src/services/modal.service.js

>>> FILE_START: src/services/processing/helpers.js
/* global XLSX */
import { get } from 'svelte/store';
import { config } from '../../config.js';
// [FIX] Import th√™m efficiencyConfig
import { declarations, efficiencyConfig } from '../../stores.js';

export const helpers = {
    findColumnName(header, aliases) {
        for (const colName of header) {
            const processedColName = String(colName || '').trim().toLowerCase();
            if (aliases.includes(processedColName)) {
                return colName;
            }
        }
        return null;
    },

    getHinhThucXuatTinhDoanhThu: () => {
        const declarationData = get(declarations).hinhThucXuat;
        if (declarationData) return new Set(declarationData.split('\n').map(l => l.trim()).filter(Boolean));
        return new Set(config.DEFAULT_DATA.HINH_THUC_XUAT_TINH_DOANH_THU);
    },

    getHinhThucXuatTraGop: () => {
        const declarationData = get(declarations).hinhThucXuatGop;
        if (declarationData) return new Set(declarationData.split('\n').map(l => l.trim()).filter(Boolean));
        return new Set(config.DEFAULT_DATA.HINH_THUC_XUAT_TRA_GOP);
    },

    getHeSoQuyDoi: () => {
        const heSoMap = {};
        let sourceUsed = 'DEFAULT'; // Bi·∫øn ƒë·ªÉ debug xem ƒëang l·∫•y d·ªØ li·ªáu t·ª´ ngu·ªìn n√†o

        // ∆ØU TI√äN 1: L·∫•y t·ª´ C·∫•u h√¨nh Hi·ªáu qu·∫£ (Giao di·ªán Admin m·ªõi)
        const dynamicConfig = get(efficiencyConfig);
        if (dynamicConfig && dynamicConfig.length > 0) {
            sourceUsed = 'ADMIN_CONFIG_STORE';
            dynamicConfig.forEach(item => {
                // item c·∫•u tr√∫c: { id: "1491 - Smartphone", heSo: 1.5, ... }
                if (item.id && item.heSo !== undefined && item.heSo !== null) {
                    heSoMap[item.id.trim()] = parseFloat(item.heSo);
                }
            });
        }

        // ∆ØU TI√äN 2: L·∫•y t·ª´ Khai b√°o Text (C≈© - n·∫øu Priority 1 kh√¥ng ƒë·ªß ho·∫∑c r·ªóng)
        // Logic merge: Ch·ªâ th√™m n·∫øu ch∆∞a c√≥ trong map
        const declarationData = get(declarations).heSoQuyDoi;
        if (declarationData) {
            declarationData.split('\n').filter(l => l.trim()).forEach(line => {
                const parts = line.split(',');
                if (parts.length >= 2) {
                    const key = parts[0].trim();
                    const value = parseFloat(parts[1].trim());
                    if (key && !isNaN(value)) {
                         // N·∫øu ch∆∞a c√≥ th√¨ m·ªõi th√™m (∆Øu ti√™n Config m·ªõi ƒë√® l√™n c≈©)
                         if (heSoMap[key] === undefined) {
                             heSoMap[key] = value;
                         }
                    }
                }
            });
        }

        // ∆ØU TI√äN 3: M·∫∑c ƒë·ªãnh (Fallback cu·ªëi c√πng)
        const defaultData = config.DEFAULT_DATA.HE_SO_QUY_DOI;
        Object.entries(defaultData).forEach(([key, value]) => {
             if (heSoMap[key] === undefined) {
                 heSoMap[key] = value;
             }
        });

        // --- [DEBUG LOG THEO Y√äU C·∫¶U] ---
        // Ch·ªâ log khi map c√≥ d·ªØ li·ªáu ƒë·ªÉ tr√°nh spam
        if (Object.keys(heSoMap).length > 0) {
            // console.log(`[Helpers] ƒê√£ n·∫°p ${Object.keys(heSoMap).length} h·ªá s·ªë quy ƒë·ªïi. Ngu·ªìn ch√≠nh: ${sourceUsed}`);
            // M·ªü comment d√≤ng d∆∞·ªõi n·∫øu mu·ªën soi chi ti·∫øt map khi c·∫ßn
            // console.log("Chi ti·∫øt Map Quy ƒê·ªïi:", heSoMap);
        }
        // -------------------------------

        return heSoMap;
    },

    cleanCompetitionName(name) {
        return name.replace(/thi ƒëua doanh thu b√°n h√†ng|thi ƒëua doanh thu|thi ƒëua s·ªë l∆∞·ª£ng/gi, "").trim();
    },

    classifyInsurance: (productName) => {
        if (!productName || typeof productName !== 'string') return null;
        const name = productName.trim().toLowerCase();
        if (name.includes('b·∫£o h√†nh m·ªü r·ªông')) return 'BHMR';
        if (name.includes('1 ƒë·ªïi 1')) return 'BH1d1';
        if (name.includes('kho·∫£n vay')) return 'BHKV';
        if (name.includes('r∆°i v·ª°')) return 'BHRV';
        if (name.includes('samsung care+')) return 'BHSC';
        if (name.includes('√¥ t√¥') || name.includes('v·∫≠t ch·∫•t √¥ t√¥')) return 'BHOTO';
        if (name.includes('xe m√°y') || name.includes('xe moto')) return 'BHXM';
        if (name.includes('x√£ h·ªôi') || name.includes('y t·∫ø')) return 'BHYT';
        return null;
    },

    findHeaderAndProcess(sheet, requiredKeywords) {
        if (!sheet) return [];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: null });
        if (rows.length === 0) return [];

        let headerRowIndex = -1;
        let foundHeaders = [];

        for (let i = 0; i < Math.min(rows.length, 10); i++) {
            const row = rows[i];
            const lowerCaseRow = row.map(cell => String(cell || '').trim().toLowerCase());

            const allKeywordsFound = requiredKeywords.every(keyword =>
                lowerCaseRow.some(cell => cell.includes(keyword))
            );

            if (allKeywordsFound) {
                headerRowIndex = i;
                foundHeaders = rows[i].map(cell => String(cell || '').trim());
                break;
            }
        }

        if (headerRowIndex === -1) {
            throw new Error(`Kh√¥ng t√¨m th·∫•y d√≤ng ti√™u ƒë·ªÅ ch·ª©a ƒë·ªß c√°c t·ª´ kh√≥a: ${requiredKeywords.join(', ')}.`);
        }

        const dataRows = rows.slice(headerRowIndex + 1);
        const jsonData = dataRows.map(row => {
            const obj = {};
            foundHeaders.forEach((header, index) => {
                if (header) {
                    const value = row[index];
                    const upperKey = header.toUpperCase();
                    if (upperKey.includes('K√äNH') || upperKey.includes('SI√äU TH·ªä') || upperKey.includes('NG√ÄNH H√ÄNG') || upperKey.includes('T·ªàNH') || upperKey.includes('BOSS')) {
                        obj[header] = value;
                    } else if (typeof value === 'string' && value.includes('%')) {
                        obj[header] = parseFloat(value.replace(/%|,/g, '')) / 100 || 0;
                    } else if (value !== null && value !== undefined) {
                        obj[header] = parseFloat(String(value).replace(/,/g, '')) || 0;
                    } else {
                        obj[header] = 0;
                    }
                }
            });
            return obj;
        }).filter(obj => {
            const supermarketKey = Object.keys(obj).find(k => k.toLowerCase().includes('si√™u th·ªã'));
            return supermarketKey && obj[supermarketKey];
        });

        return jsonData;
    }
};
<<< FILE_END: src/services/processing/helpers.js

>>> FILE_START: src/services/processing/logic/cluster.processor.js
// src/services/processing/logic/cluster.processor.js

export const clusterProcessor = {
    /**
     * Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu thi ƒëua th√¥ th√†nh ƒë·ªãnh d·∫°ng hi·ªÉn th·ªã cho Table
     */
    processCompetitionData: (parsedData) => {
        if (!parsedData) return [];
        
        // Flatten d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã b·∫£ng: M·ªói d√≤ng l√† 1 ng√†nh h√†ng c·ªßa 1 si√™u th·ªã?
        // Ho·∫∑c tr·∫£ v·ªÅ c·∫•u tr√∫c Group ƒë·ªÉ UI render (Si√™u th·ªã -> List Ng√†nh h√†ng)
        
        // ·ªû ƒë√¢y t√¥i tr·∫£ v·ªÅ c·∫•u tr√∫c nguy√™n b·∫£n ƒë√£ s·∫°ch ƒë·ªÉ UI d·ªÖ loop
        return parsedData.stores.map(store => {
            return {
                storeName: store.name,
                metrics: store.data, // [{ category, percent, revenue }]
                totalRevenue: store.data.reduce((acc, curr) => acc + curr.revenue, 0)
            };
        });
    },

    /**
     * T·∫°o d·ªØ li·ªáu b√°o c√°o t·ªïng h·ª£p cho C·ª•m
     */
    createClusterReport: (cumulativeData) => {
        if (!cumulativeData) return null;

        const { generalStats, storeDetails } = cumulativeData;

        // T√≠nh t·ªïng th·ª±c t·∫ø t·ª´ c√°c store chi ti·∫øt (ƒë·ªÉ ƒë·ªëi chi·∫øu v·ªõi generalStats n·∫øu c·∫ßn)
        const calculatedTotalDT = storeDetails.reduce((acc, s) => acc + s.dtLuyKe, 0);

        return {
            kpiCards: generalStats, // D·ªØ li·ªáu cho 4 √¥ th·∫ª b√†i tr√™n c√πng
            detailTable: storeDetails, // D·ªØ li·ªáu cho b·∫£ng chi ti·∫øt b√™n d∆∞·ªõi
            debug: {
                scannedTotal: generalStats.dtThuc,
                calcTotal: calculatedTotalDT
            }
        };
    }
};
<<< FILE_END: src/services/processing/logic/cluster.processor.js

>>> FILE_START: src/services/processing/logic/competition.processor.js
// src/services/processing/logic/competition.processor.js
import { get } from 'svelte/store';
import { 
    danhSachNhanVien, 
    employeeMaNVMap, 
    competitionNameMappings, 
    debugInfo 
} from '../../../stores.js';
import { helpers } from '../helpers.js';
import { normalizers } from '../normalizers.js';

export const competitionProcessor = {
    // 1. Ki·ªÉm tra logic l·ªçc (Debug)
    debugCompetitionFiltering(rawTestData) {
        if (!rawTestData || rawTestData.length === 0) return [];

        const { normalizedData } = normalizers.normalizeData(rawTestData, 'ycx');
        if (normalizedData.length === 0) return [];

        const hinhThucXuatTinhDoanhThu = helpers.getHinhThucXuatTinhDoanhThu();
        const debugResults = normalizedData.map(row => {
            const checks = {
                isDoanhThuHTX: hinhThucXuatTinhDoanhThu.has(row.hinhThucXuat),
                isThuTien: (row.trangThaiThuTien || "").trim() === 'ƒê√£ thu',
                isChuaHuy: (row.trangThaiHuy || "").trim() === 'Ch∆∞a h·ªßy',
                isChuaTra: (row.tinhTrangTra || "").trim() === 'Ch∆∞a tr·∫£',
                isDaXuat: (row.trangThaiXuat || "").trim() === 'ƒê√£ xu·∫•t'
            };
            const isOverallValid = checks.isDoanhThuHTX && checks.isThuTien && checks.isChuaHuy && checks.isChuaTra && checks.isDaXuat;
            return { rowData: row, checks: checks, isOverallValid: isOverallValid };
        });
        return debugResults;
    },

    // 2. C·∫≠p nh·∫≠t mapping t√™n thi ƒëua
    updateCompetitionNameMappings(mainHeaders) {
        if (!mainHeaders || mainHeaders.length === 0) return;
        
        const oldMappings = get(competitionNameMappings) || {};
        const newMappings = { ...oldMappings };
        let hasChanges = false;

        mainHeaders.forEach(originalName => {
            // Ch·ªâ th√™m n·∫øu t√™n n√†y ch∆∞a t·ªìn t·∫°i trong mapping
            if (!newMappings.hasOwnProperty(originalName)) {
                // [Y√äU C·∫¶U] M·∫∑c ƒë·ªãnh ƒëi·ªÅn t√™n r√∫t g·ªçn = t√™n g·ªëc
                newMappings[originalName] = originalName; 
                hasChanges = true;
            }
        });

        if (hasChanges) {
            console.log("[Processors] Ph√°t hi·ªán t√™n thi ƒëua m·ªõi, c·∫≠p nh·∫≠t store mapping.");
            competitionNameMappings.set(newMappings);
        }
    },

    // 3. X·ª≠ l√Ω d·ªØ li·ªáu thi ƒëua nh√¢n vi√™n (Core Logic)
    processThiDuaNhanVienData(parsedData, luykeCompetitionData) {
        const { mainHeaders, subHeaders, dataRows } = parsedData;
        const newDebugInfo = { required: [], found: [], status: 'ƒêang x·ª≠ l√Ω...' };
        
        const $danhSachNhanVien = get(danhSachNhanVien);
        if ($danhSachNhanVien.length === 0) {
            newDebugInfo.status = 'L·ªói: Danh s√°ch nh√¢n vi√™n (DSNV) ch∆∞a ƒë∆∞·ª£c t·∫£i l√™n.';
            debugInfo.update(current => ({ ...current, 'thiduanv-pasted': newDebugInfo }));
            return [];
        }
        if (mainHeaders.length === 0 || dataRows.length === 0 || subHeaders.length === 0) {
            newDebugInfo.status = 'L·ªói: D·ªØ li·ªáu d√°n v√†o kh√¥ng h·ª£p l·ªá.';
            debugInfo.update(current => ({ ...current, 'thiduanv-pasted': newDebugInfo }));
            return [];
        }

        // [QUAN TR·ªåNG] G·ªçi h√†m c·∫≠p nh·∫≠t mapping ngay khi x·ª≠ l√Ω d·ªØ li·ªáu
        this.updateCompetitionNameMappings(mainHeaders);

        const nameMappings = get(competitionNameMappings) || {};
        const competitionTargets = (luykeCompetitionData || []).map(comp => ({
            ...comp,
            cleanedName: helpers.cleanCompetitionName(comp.name)
        }));
        
        const finalReport = [];
        const totalEmployeesInDSNV = $danhSachNhanVien.length;
        const $employeeMaNVMap = get(employeeMaNVMap);

        dataRows.forEach(row => {
            const nameParts = row.name.split(' - ');
            const msnv = nameParts.length > 1 ? nameParts[nameParts.length - 1].trim() : null;

            let employee;
            if (msnv) {
                employee = $employeeMaNVMap.get(msnv);
            }

            if (!employee) {
                employee = { hoTen: row.name, maNV: msnv || 'N/A', boPhan: 'Nh√¢n vi√™n kh√¥ng t√¨m th·∫•y' };
            }

            const employeeResult = {
                maNV: employee.maNV,
                hoTen: employee.hoTen,
                boPhan: employee.boPhan,
                completedCount: 0,
                totalCompetitions: mainHeaders.length,
                competitions: []
            };

            for (let i = 0; i < mainHeaders.length; i++) {
                const originalName = mainHeaders[i];
                const loaiSoLieu = subHeaders[i];
                
                // [Y√äU C·∫¶U] L·∫•y t√™n r√∫t g·ªçn t·ª´ mapping, fallback v·ªÅ t√™n g·ªëc
                const shortName = nameMappings[originalName] || originalName;
                
                const cleanedName = helpers.cleanCompetitionName(originalName);
                const matchedTarget = competitionTargets.find(t => t.cleanedName === cleanedName);
                const groupTarget = matchedTarget ? matchedTarget.target : 0;
                const individualTarget = totalEmployeesInDSNV > 0 ? groupTarget / totalEmployeesInDSNV : 0;

                const giaTri = parseFloat(String(row.values[i] || '0').replace(/,/g, '')) || 0;
                const actualSales = giaTri;
                const percentExpected = individualTarget > 0 ? actualSales / individualTarget : (actualSales > 0 ? Infinity : 0);
                
                if (percentExpected >= 1) employeeResult.completedCount++;

                employeeResult.competitions.push({
                    tenNganhHang: shortName, // D√πng t√™n r√∫t g·ªçn cho hi·ªÉn th·ªã
                    tenGoc: originalName,    // Gi·ªØ t√™n g·ªëc ƒë·ªÉ ƒë·ªëi chi·∫øu
                    loaiSoLieu: loaiSoLieu,
                    giaTri: giaTri,
                    thucHien: actualSales,
                    mucTieu: individualTarget,
                    percentExpected: percentExpected,
                });
            }

            employeeResult.completionRate = employeeResult.totalCompetitions > 0 ? employeeResult.completedCount / employeeResult.totalCompetitions : 0;
            finalReport.push(employeeResult);
        });

        newDebugInfo.status = `Th√†nh c√¥ng: ƒê√£ x·ª≠ l√Ω b√°o c√°o cho ${finalReport.length} nh√¢n vi√™n.`;
        debugInfo.update(current => ({ ...current, 'thiduanv-pasted': newDebugInfo }));
        return finalReport;
    }
};
<<< FILE_END: src/services/processing/logic/competition.processor.js

>>> FILE_START: src/services/processing/logic/dynamicTable.processor.js
/* src/services/processing/logic/dynamicTable.processor.js */
import { get } from 'svelte/store';
import { formatters } from '../../../utils/formatters.js';
import { parseIdentity } from '../../../utils.js';
import { macroCategoryConfig, macroProductGroupConfig } from '../../../stores.js';

// Helper: L√†m s·∫°ch v√† √©p ki·ªÉu s·ªë an to√†n
const getSafeNumber = (value) => {
    if (typeof value === 'number') return value;
    if (!value) return 0;
    if (typeof value === 'string') {
        const cleanStr = value.replace(/[^0-9.-]+/g, ""); 
        return parseFloat(cleanStr) || 0;
    }
    return 0;
};

const getValueFromMultiKeys = (obj, keys) => {
    if (!obj) return 0;
    for (const key of keys) {
        if (obj[key] !== undefined && obj[key] !== null) {
            return getSafeNumber(obj[key]);
        }
    }
    return 0;
};

export const dynamicTableProcessor = {
    findItemData(employee, targetId) {
        if (!employee || !targetId) return null;
        const parsed = parseIdentity(targetId);
        const searchKey = (parsed.id !== 'unknown' ? parsed.id : targetId).toString().trim();
        if (employee.doanhThuTheoNhomHang && employee.doanhThuTheoNhomHang[searchKey]) {
            return employee.doanhThuTheoNhomHang[searchKey];
        }
        if (employee.doanhThuTheoNganhHang && employee.doanhThuTheoNganhHang[searchKey]) {
            return employee.doanhThuTheoNganhHang[searchKey];
        }
        return null;
    },

    /**
     * T√≠nh t·ªïng gi√° tr·ªã (C√ì LOG CHI TI·∫æT)
     * @param logger: M·∫£ng ƒë·ªÉ l∆∞u log truy v·∫øt
     */
    calculateGroupValue(employee, items, type = 'DT', logger = null) {
        if (!items || items.length === 0) return 0;

        const macroCats = get(macroCategoryConfig) || [];
        const macroGroups = get(macroProductGroupConfig) || [];

        let total = 0;
        const processedIds = new Set();

        const processId = (id) => {
            const safeId = id ? id.toString().trim() : '';
            if (!safeId || processedIds.has(safeId)) return;
            
            // 1. Check Macro Category
            const macroCat = macroCats.find(m => m.id == safeId || m.name === safeId);
            if (macroCat && macroCat.items) {
                processedIds.add(safeId);
                if (logger) logger.push(`   üìÇ [MACRO CAT] ${safeId}:`);
                macroCat.items.forEach(childId => processId(childId));
                return;
            }

            // 2. Check Macro Product Group
            const macroGroup = macroGroups.find(m => m.id == safeId || m.name === safeId);
            if (macroGroup && macroGroup.items) {
                processedIds.add(safeId);
                if (logger) logger.push(`   üìÇ [MACRO GROUP] ${safeId}:`);
                macroGroup.items.forEach(childId => processId(childId));
                return;
            }

            // 3. Raw ID
            const data = this.findItemData(employee, safeId);
            let val = 0;
            if (data) {
                processedIds.add(safeId);
                if (type === 'SL') {
                    val = getValueFromMultiKeys(data, ['quantity', 'soLuong', 'sl', 'count']);
                } else if (type === 'DTQD') {
                    val = getValueFromMultiKeys(data, ['revenueQuyDoi', 'doanhThuQuyDoi', 'dtqd']);
                } else {
                    val = getValueFromMultiKeys(data, ['revenue', 'doanhThu', 'thanhTien', 'totalPrice', 'dt']);
                }
                
                total += val;
                
                // Ch·ªâ log nh·ªØng m·ª•c c√≥ gi√° tr·ªã ƒë·ªÉ ƒë·ª° r·ªëi
                if (logger && val !== 0) {
                    logger.push(`      üîπ ${safeId} (${type}): ${formatters.formatNumber(val)}`);
                }
            }
        };

        items.forEach(id => processId(id));
        return total;
    },

    processTableData(reportData, config) {
        if (!reportData || !config) return { processedData: [], totals: {} };

        const mainColConfig = config.mainColumn ? { ...config.mainColumn, id: 'mainValue', isMain: true } : null;
        const subColsConfig = config.subColumns || [];
        const effectiveSubCols = config.columns || subColsConfig;
        
        const allColumnsToProcess = mainColConfig ? [mainColConfig, ...effectiveSubCols] : [...effectiveSubCols];

        const totalRow = {
            maNV: 'TOTAL',
            hoTen: 'T·ªîNG C·ªòNG',
            isTotal: true,
            cells: {} 
        };

        const processedData = reportData.map(employee => {
            const row = {
                maNV: employee.maNV,
                hoTen: employee.hoTen,
                mucTieu: employee.mucTieu || {},
                cells: {}
            };

            let hasAnyData = false;

            allColumnsToProcess.forEach(col => {
                const colId = col.id || col.header;
                const cellData = { sl: 0, dt: 0, dtqd: 0, value: 0, display: '', config: col };

                if (col.type === 'PERCENT') {
                    // Logic % (B·∫£ng hi·ªáu qu·∫£)
                    
                    // --- üîç TRACE DEBUG START ---
                    let traceLog = [];
                    // Ch·ªâ debug cho m·ªôt v√†i nh√¢n vi√™n m·∫´u ƒë·ªÉ ƒë·ª° spam
                    const isTargetDebug = employee.hoTen.includes('T√∫ Ph∆∞∆°ng') || employee.hoTen.includes('Tien'); 
                    
                    // [LOGIC M·ªöI] L·∫•y lo·∫°i Metric t·ª´ c·∫•u h√¨nh (∆Øu ti√™n percentMetric -> m·∫∑c ƒë·ªãnh DT)
                    const metricType = col.percentMetric || 'DT';

                    const numVal = this.calculateGroupValue(employee, col.numerator, metricType, isTargetDebug ? traceLog : null);
                    // M·∫´u s·ªë d√πng chung lo·∫°i Metric v·ªõi T·ª≠ s·ªë (tr·ª´ khi c√≥ config ri√™ng typeB - m√† hi·ªán t·∫°i UI ch∆∞a h·ªó tr·ª£ separate config n√™n c·ª© d√πng chung)
                    const denVal = this.calculateGroupValue(employee, col.denominator, metricType, isTargetDebug ? traceLog : null);

                    if (isTargetDebug) { 
                         // ƒêi·ªÅu ki·ªán l·ªçc log: In ra n·∫øu c√≥ m·∫´u s·ªë > 0 ƒë·ªÉ ki·ªÉm tra
                         if (denVal > 0) {
                             console.groupCollapsed(`üïµÔ∏è [TRACE] ${employee.hoTen} - ${col.header} (% ${metricType})`);
                             console.log(`%c T·ª≠ s·ªë (${metricType}): ${formatters.formatNumber(numVal)}`, 'color: green');
                             console.log(`%c M·∫´u s·ªë (${metricType}): ${formatters.formatNumber(denVal)}`, 'color: red; font-weight: bold');
                             console.log(`üëá CHI TI·∫æT C√ÅC M√ìN C·ªòNG V√ÄO:`);
                             traceLog.forEach(log => console.log(log));
                             console.groupEnd();
                         }
                    }
                    // --- TRACE DEBUG END ---

                    const val = denVal > 0 ? numVal / denVal : 0;
                    cellData.value = val;
                    cellData.display = formatters.formatPercentage(val);
                    
                    if (numVal > 0 || denVal > 0) hasAnyData = true;

                    if (!totalRow.cells[colId]) totalRow.cells[colId] = { num: 0, den: 0, type: 'PERCENT' };
                    totalRow.cells[colId].num += numVal;
                    totalRow.cells[colId].den += denVal;

                } else {
                    // Logic C·ªôt th∆∞·ªùng (DT, SL, DTQD)
                    cellData.sl = this.calculateGroupValue(employee, col.items, 'SL');
                    cellData.dt = this.calculateGroupValue(employee, col.items, 'DT');
                    cellData.dtqd = this.calculateGroupValue(employee, col.items, 'DTQD');

                    if (col.type === 'SL') {
                        cellData.value = cellData.sl;
                        cellData.display = formatters.formatNumber(cellData.sl);
                    } else if (col.type === 'DTQD') {
                        cellData.value = cellData.dtqd;
                        cellData.display = formatters.formatRevenue(cellData.dtqd);
                    } else {
                        cellData.value = cellData.dt;
                        cellData.display = formatters.formatRevenue(cellData.dt);
                    }

                    if (cellData.value > 0 || cellData.sl > 0 || cellData.dt > 0 || cellData.dtqd > 0) hasAnyData = true;

                    if (!totalRow.cells[colId]) totalRow.cells[colId] = { sl: 0, dt: 0, dtqd: 0, val: 0, type: col.type || 'DT' };
                    totalRow.cells[colId].sl += cellData.sl;
                    totalRow.cells[colId].dt += cellData.dt;
                    totalRow.cells[colId].dtqd += cellData.dtqd;
                    totalRow.cells[colId].val += cellData.value;
                }

                row.cells[colId] = cellData;
                if (col.isMain) {
                    row.mainValue = cellData.value;
                    row.mainValue_sl = cellData.sl;
                    row.mainValue_dtqd = cellData.dtqd;
                }
            });

            return hasAnyData ? row : null;
        }).filter(Boolean);

        Object.keys(totalRow.cells).forEach(key => {
            const cell = totalRow.cells[key];
            if (cell.type === 'PERCENT') {
                const val = cell.den > 0 ? cell.num / cell.den : 0;
                cell.value = val;
                cell.display = formatters.formatPercentage(val);
            } else {
                if (cell.type === 'SL') cell.display = formatters.formatNumber(cell.val);
                else cell.display = formatters.formatRevenue(cell.val);
                cell.value = cell.val;
                
                if (key === 'mainValue') {
                    totalRow.mainValue = cell.val;
                    totalRow.mainValue_sl = cell.sl;
                    totalRow.mainValue_dtqd = cell.dtqd;
                }
            }
        });

        return { processedData, totals: totalRow };
    },

    sortTableData(data, key, direction) {
        return [...data].sort((a, b) => {
            if (key === 'hoTen') {
                return direction === 'asc' ? a.hoTen.localeCompare(b.hoTen) : b.hoTen.localeCompare(a.hoTen);
            }
            const valA = a.cells[key]?.value ?? a[key] ?? 0;
            const valB = b.cells[key]?.value ?? b[key] ?? 0;
            return direction === 'asc' ? valA - valB : valB - valA;
        });
    }
};
<<< FILE_END: src/services/processing/logic/dynamicTable.processor.js

>>> FILE_START: src/services/processing/logic/regional.processor.js
import { helpers } from '../helpers.js';

// --- HELPER FUNCTIONS ---
const evaluatePerformance = (dat, tong) => {
    if (tong === 0) return 'N/A';
    const tyLe = dat / tong;
    if (tyLe >= 1) return 'Xu·∫•t s·∫Øc'; 
    if (tyLe >= 0.8) return 'G·∫ßn ƒë·∫°t'; 
    return 'C·∫ßn c·ªë g·∫Øng';
};

export const regionalProcessor = {
    // X·ª≠ l√Ω file Excel Thi ƒêua V√πng
    processThiDuaVungFile(workbook) {
        console.group('üöÄ [RegionalProcessor] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω file...');

        if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
            throw new Error('File Excel kh√¥ng ch·ª©a sheet d·ªØ li·ªáu n√†o.');
        }

        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];

        // 2. KHAI B√ÅO T·ª™ KH√ìA
        const KEYWORDS = {
            tinh: 't·ªânh',
            boss: 'boss',
            kenh: 'k√™nh',
            sieuThi: 'si√™u th·ªã',
            nganhHang: 'ng√†nh h√†ng thi ƒëua',
            
            // C√°c ch·ªâ s·ªë KPI
            duKienHoanThanh: 'd·ª± ki·∫øn ho√†n th√†nh', 
            duKienVuot: 'd·ª± ki·∫øn dt/sl v∆∞·ª£t', 
            
            // C√°c lo·∫°i H·∫°ng
            rankTop10: 'top 10% k√™nh', 
            rankVuotTroi: 'h·∫°ng v∆∞·ª£t tr·ªôi dt/sl theo k√™nh', 
            rankTarget: 'h·∫°ng h.t target theo k√™nh', 
            
            // Th∆∞·ªüng (L·∫•y th√™m c√°c c·ªôt th∆∞·ªüng ti·ªÅm nƒÉng)
            tongThuong: 't·ªïng th∆∞·ªüng',
            thuongVuotTroi: 'th∆∞·ªüng top v∆∞·ª£t tr·ªôi', // C·ªôt th∆∞·ªüng ti·ªÅm nƒÉng 1
            thuongTarget: 'th∆∞·ªüng top ho√†n th√†nh'   // C·ªôt th∆∞·ªüng ti·ªÅm nƒÉng 2
        };

        const REQUIRED_MATCHES = [KEYWORDS.sieuThi, KEYWORDS.nganhHang, KEYWORDS.tongThuong];

        let headerRowIndex = -1;
        let columnMap = {}; 
        let maxRowIndex = 0;

        // 3. QU√âT SHEET T√åM HEADER
        const cellKeys = Object.keys(sheet).filter(k => !k.startsWith('!'));
        cellKeys.forEach(key => {
            const match = key.match(/^([A-Z]+)(\d+)$/);
            if (match) {
                const row = parseInt(match[2]);
                if (row > maxRowIndex) maxRowIndex = row;
            }
        });

        for (let r = 1; r <= Math.min(50, maxRowIndex); r++) {
            const rowTexts = [];
            const colToText = {}; 

            cellKeys.forEach(key => {
                const match = key.match(/^([A-Z]+)(\d+)$/);
                if (match && parseInt(match[2]) === r) {
                    const cellVal = sheet[key].v;
                    if (typeof cellVal === 'string') {
                        const cleanText = cellVal.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim().toLowerCase();
                        rowTexts.push(cleanText);
                        colToText[match[1]] = cleanText;
                    }
                }
            });

            const isHeader = REQUIRED_MATCHES.every(req => rowTexts.includes(req));

            if (isHeader) {
                headerRowIndex = r;
                // MAP C·ªòT
                Object.entries(colToText).forEach(([colLetter, text]) => {
                    for (const [keyId, keyText] of Object.entries(KEYWORDS)) {
                        if (text === keyText) { 
                            columnMap[keyId] = colLetter;
                            continue;
                        }
                        if (text.includes(keyText) && !columnMap[keyId]) {
                            columnMap[keyId] = colLetter;
                        }
                    }
                });
                break;
            }
        }

        if (headerRowIndex === -1) {
            throw new Error(`Kh√¥ng t√¨m th·∫•y d√≤ng ti√™u ƒë·ªÅ h·ª£p l·ªá.`);
        }

        // 4. TR√çCH XU·∫§T DATA
        const rawData = [];
        const supermarketMap = new Map();
        let skippedRows = 0;

        for (let r = headerRowIndex + 1; r <= maxRowIndex; r++) {
            const getVal = (keyId) => {
                const col = columnMap[keyId];
                if (!col) return null;
                const cell = sheet[`${col}${r}`];
                return cell ? cell.v : null;
            };

            let sieuThiName = getVal('sieuThi');
            
            if (!sieuThiName || typeof sieuThiName !== 'string') {
                skippedRows++; continue;
            }
            
            sieuThiName = sieuThiName.replace(/\s+/g, ' ').trim(); 
            if (sieuThiName === '') {
                skippedRows++; continue;
            }

            // ƒê·ªçc d·ªØ li·ªáu th∆∞·ªüng ti·ªÅm nƒÉng
            const thuongVuotTroi = parseFloat(getVal('thuongVuotTroi')) || 0;
            const thuongTarget = parseFloat(getVal('thuongTarget')) || 0;

            const rowItem = {
                id: `${r}`,
                sieuThi: sieuThiName,
                kenh: getVal('kenh') || '',
                nganhHang: getVal('nganhHang') || '',
                
                // S·ªë li·ªáu
                duKienHoanThanh: parseFloat(getVal('duKienHoanThanh')) || 0, 
                duKienVuot: parseFloat(getVal('duKienVuot')) || 0, 
                tongThuong: parseFloat(getVal('tongThuong')) || 0,
                
                // Ti·ªÅm nƒÉng (L·∫•y s·ªë l·ªõn nh·∫•t trong c√°c c∆° h·ªôi th∆∞·ªüng)
                potentialPrize: Math.max(thuongVuotTroi, thuongTarget),

                // H·∫°ng (Rank)
                rankCutoff: parseFloat(getVal('rankTop10')) || 0, 
                rankVuotTroi: parseFloat(getVal('rankVuotTroi')) || 9999,
                rankTarget: parseFloat(getVal('rankTarget')) || 9999,
            };

            rowItem.bestRank = Math.min(rowItem.rankVuotTroi, rowItem.rankTarget);
            
            rawData.push(rowItem);

            if (!supermarketMap.has(sieuThiName)) {
                supermarketMap.set(sieuThiName, {
                    sieuThi: sieuThiName, 
                    kenh: rowItem.kenh, 
                    tongThuong: 0,
                    soNganhHang: 0,
                    soNganhHangDat: 0,
                    rankCutoff: rowItem.rankCutoff,
                    details: []
                });
            }

            const stData = supermarketMap.get(sieuThiName);
            stData.tongThuong += rowItem.tongThuong;
            stData.soNganhHang += 1;
            
            if (rowItem.duKienHoanThanh >= 1.0) {
                stData.soNganhHangDat += 1;
            }
            if (stData.rankCutoff === 0 && rowItem.rankCutoff > 0) {
                stData.rankCutoff = rowItem.rankCutoff;
            }

            stData.details.push(rowItem);
        }

        const aggregatedData = Array.from(supermarketMap.values())
            .map(item => {
                item.evaluation = evaluatePerformance(item.soNganhHangDat, item.soNganhHang);
                return item;
            })
            .sort((a, b) => a.sieuThi.localeCompare(b.sieuThi));

        console.log(`‚úÖ ƒê√£ x·ª≠ l√Ω ${aggregatedData.length} si√™u th·ªã.`);
        console.groupEnd();

        return {
            chiTietData: rawData, 
            tongData: aggregatedData 
        };
    }
};
<<< FILE_END: src/services/processing/logic/regional.processor.js

>>> FILE_START: src/services/processing/logic/salesVelocity.helper.js
// File: src/services/processing/logic/salesVelocity.helper.js

// [GENESIS HELPER] Chu·∫©n h√≥a key (b·ªè d·∫•u, vi·∫øt th∆∞·ªùng, b·ªè kho·∫£ng tr·∫Øng)
const normalizeKey = (key) => {
    if (!key) return '';
    return key.toString().toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // B·ªè d·∫•u
        .replace(/\s+/g, ""); // B·ªè kho·∫£ng tr·∫Øng
};

// [GENESIS HELPER] Parse ng√†y Vi·ªát Nam (dd/mm/yyyy) an to√†n
const parseDateVN = (dateStr) => {
    if (!dateStr) return null;
    // N·∫øu l√† object Date s·∫µn
    if (dateStr instanceof Date && !isNaN(dateStr)) return dateStr.getTime();

    const str = String(dateStr).trim();
    
    // Th·ª≠ regex dd/mm/yyyy
    const parts = str.match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{4})/);
    if (parts) {
        const day = parseInt(parts[1], 10);
        const month = parseInt(parts[2], 10) - 1; // JS month 0-11
        const year = parseInt(parts[3], 10);
        return new Date(year, month, day).getTime();
    }
    
    // Fallback cho format chu·∫©n (yyyy-mm-dd ho·∫∑c ISO)
    const timestamp = Date.parse(str);
    return isNaN(timestamp) ? null : timestamp;
};

export const filterDataByDate = (data, fromDate, toDate) => {
    if (!data || data.length === 0) return [];
    if (!fromDate && !toDate) return data;

    // Chuy·ªÉn m·ªëc th·ªùi gian l·ªçc v·ªÅ timestamp (ƒë·∫ßu ng√†y v√† cu·ªëi ng√†y)
    const from = fromDate ? new Date(fromDate).setHours(0,0,0,0) : null;
    const to = toDate ? new Date(toDate).setHours(23,59,59,999) : null;

    // Cache key ng√†y th√°ng t√¨m ƒë∆∞·ª£c ƒë·ªÉ kh√¥ng ph·∫£i loop keys m·ªói d√≤ng
    let foundDateKey = null;

    return data.filter(row => {
        let dateVal = null;

        // 1. N·∫øu ƒë√£ t√¨m ƒë∆∞·ª£c key ng√†y tr∆∞·ªõc ƒë√≥, d√πng lu√¥n cho nhanh
        if (foundDateKey) {
            dateVal = row[foundDateKey];
        } else {
            // 2. N·∫øu ch∆∞a, qu√©t keys ƒë·ªÉ t√¨m c·ªôt "Ng√†y t·∫°o"
            const keys = Object.keys(row);
            for (const key of keys) {
                const cleanKey = normalizeKey(key);
                // ∆Øu ti√™n c√°c t·ª´ kh√≥a: ngaytao, ngaychungtu, date
                if (cleanKey === 'ngaytao' || cleanKey === 'ngaychungtu' || cleanKey === 'date' || cleanKey === 'ngay') {
                    foundDateKey = key;
                    dateVal = row[key];
                    break;
                }
            }
        }

        // N·∫øu kh√¥ng c√≥ ng√†y, m·∫∑c ƒë·ªãnh gi·ªØ l·∫°i (an to√†n)
        if (!dateVal) return true;

        const rowTime = parseDateVN(dateVal);
        if (rowTime === null) return true; // Parse l·ªói th√¨ gi·ªØ l·∫°i

        if (from && rowTime < from) return false;
        if (to && rowTime > to) return false;
        return true;
    });
};

export const transformVelocityTree = (nodes, divisor) => {
    if (!nodes || nodes.length === 0) return [];
    if (divisor <= 1) return nodes;

    return nodes.map(node => {
        const newNode = { ...node };
        const divide = (val) => parseFloat(((val || 0) / divisor).toFixed(1));

        newNode.quantity = divide(node.quantity);
        newNode.revenue = divide(node.revenue);
        newNode.revenueQD = divide(node.revenueQD);
        newNode.revenueTraCham = divide(node.revenueTraCham);

        if (newNode.children && newNode.children.length > 0) {
            newNode.children = transformVelocityTree(newNode.children, divisor);
        }
        return newNode;
    });
};
<<< FILE_END: src/services/processing/logic/salesVelocity.helper.js

>>> FILE_START: src/services/processing/logic/timekeeping.processor.js
// src/services/processing/logic/timekeeping.processor.js
import { get } from 'svelte/store';
import { rawGioCongData, employeeNameToMaNVMap } from '../../../stores.js';

export const timekeepingProcessor = {
    // X·ª≠ l√Ω d·ªØ li·ªáu gi·ªù c√¥ng
    processGioCongData() {
        const gioCongByMSNV = {};
        let currentMaNV = null;
        if (!get(rawGioCongData) || get(rawGioCongData).length === 0) return gioCongByMSNV;

        for (const row of get(rawGioCongData)) {
            const maNV = String(row.maNV || '').trim();
            const hoTen = String(row.hoTen || '').trim().replace(/\s+/g, ' ');
            
            // T√¨m MSNV n·∫øu file gi·ªù c√¥ng kh√¥ng c√≥ c·ªôt MSNV (d√πng t√™n ƒë·ªÉ map)
            let foundMaNV = maNV || get(employeeNameToMaNVMap).get(hoTen.toLowerCase()) || null;
            
            if (foundMaNV) currentMaNV = foundMaNV;

            if (currentMaNV && gioCongByMSNV[currentMaNV] === undefined) {
                gioCongByMSNV[currentMaNV] = 0;
            }

            const gioCongValue = parseFloat(String(row.tongGioCong || '0').replace(/,/g, '')) || 0;
            if (currentMaNV && gioCongValue > 0) {
                gioCongByMSNV[currentMaNV] += gioCongValue;
            }
        }
        return gioCongByMSNV;
    }
};
<<< FILE_END: src/services/processing/logic/timekeeping.processor.js

>>> FILE_START: src/services/processing/normalizers.js
import { config } from '../../config.js';
import { debugInfo, rawGioCongData } from '../../stores.js';
import { helpers } from './helpers.js';

export const normalizers = {
    normalizeCategoryStructureData(rawData) {
        if (!rawData || rawData.length === 0) {
            return { success: false, error: 'File r·ªóng.', normalizedData: [] };
        }
        const header = Object.keys(rawData[0] || {});
        
        const nganhHangCol = helpers.findColumnName(header, ['ng√†nh h√†ng', 'nganh hang']);
        const nhomHangCol = helpers.findColumnName(header, ['nh√≥m h√†ng', 'nhom hang']);
        const nhaSanXuatCol = helpers.findColumnName(header, ['nh√† s·∫£n xu·∫•t', 'nha san xuat', 'h√£ng', 'brand']);

        const missingCols = [];
        if (!nganhHangCol) missingCols.push('"Ng√†nh h√†ng"');
        if (!nhomHangCol) missingCols.push('"Nh√≥m h√†ng"');
        if (!nhaSanXuatCol) missingCols.push('"Nh√† s·∫£n xu·∫•t"');

        if (missingCols.length > 0) {
            return { success: false, error: `File thi·∫øu c√°c c·ªôt: ${missingCols.join(', ')}`, normalizedData: [] };
        }

        const normalizedData = rawData
            .map(row => ({
                nganhHang: String(row[nganhHangCol] || '').trim(),
                nhomHang: String(row[nhomHangCol] || '').trim(),
                nhaSanXuat: String(row[nhaSanXuatCol] || '').trim(),
            }))
            .filter(item => item.nganhHang && item.nhomHang);
            
        return { success: true, normalizedData };
    },
    
    normalizeSpecialProductData(rawData) {
        if (!rawData || rawData.length === 0) {
            return { success: false, error: 'File r·ªóng.', normalizedData: [] };
        }
        const header = Object.keys(rawData[0] || {});
        const maSpCol = helpers.findColumnName(header, ['m√£ s·∫£n ph·∫©m', 'masanpham', 'm√£ sp', 'product code']);
        const nhomHangCol = helpers.findColumnName(header, ['nh√≥m h√†ng', 'nhom hang']);
        const tenSpCol = helpers.findColumnName(header, ['t√™n s·∫£n ph·∫©m', 'tensanpham', 't√™n sp']);

        const missingColumns = [];
        if (!maSpCol) missingColumns.push('M√£ s·∫£n ph·∫©m');
        if (!nhomHangCol) missingColumns.push('Nh√≥m h√†ng');
        if (!tenSpCol) missingColumns.push('T√™n s·∫£n ph·∫©m');

        if (missingColumns.length > 0) {
            return { success: false, error: `File thi·∫øu c√°c c·ªôt b·∫Øt bu·ªôc: ${missingColumns.join(', ')}.`, normalizedData: [] };
        }

        const normalizedData = rawData
            .map(row => ({
                maSanPham: String(row[maSpCol] || '').trim(),
                nhomHang: String(row[nhomHangCol] || '').trim(),
                tenSanPham: String(row[tenSpCol] || '').trim(),
            }))
            .filter(item => item.maSanPham && item.nhomHang && item.tenSanPham);

        return { success: true, normalizedData };
    },

    normalizeBrandData(rawData) {
        if (!rawData || rawData.length === 0) {
             return { success: false, error: 'Sheet "H√£ng" r·ªóng.', normalizedData: [] };
        }
        const header = Object.keys(rawData[0] || {});
        const brandCol = helpers.findColumnName(header, ['h√£ng', 't√™n h√£ng', 'nh√† s·∫£n xu·∫•t']);
        if (!brandCol) {
            return { success: false, error: 'Sheet "H√£ng" ph·∫£i c√≥ c·ªôt "H√£ng" ho·∫∑c "T√™n H√£ng".', normalizedData: [] };
        }

        const normalizedData = rawData
            .map(row => String(row[brandCol] || '').trim())
            .filter(brand => brand);
        return { success: true, normalizedData: [...new Set(normalizedData)].sort() };
    },

    normalizeData(rawData, fileType) {
        const mapping = config.COLUMN_MAPPINGS[fileType];
        if (!mapping) {
            console.error(`No column mapping found for fileType: ${fileType}`);
            return { normalizedData: [], success: false, missingColumns: ['Unknown mapping'] };
        }

        if (!rawData || rawData.length === 0) {
            return { normalizedData: [], success: true, missingColumns: [] };
        }

        const header = Object.keys(rawData[0] || {});
        const foundMapping = {};
        let allRequiredFound = true;
        const missingColumns = [];

        const newDebugInfo = { required: [], found: header, firstFiveMsnv: [] };
        for (const key in mapping) {
            const { required, displayName, aliases } = mapping[key];
            const foundName = helpers.findColumnName(header, aliases);
            foundMapping[key] = foundName;

            if (required) {
                const status = !!foundName;
                newDebugInfo.required.push({ displayName, foundName: foundName || 'Kh√¥ng t√¨m th·∫•y', status: status });
                if (!status) {
                    allRequiredFound = false;
                    missingColumns.push(displayName);
                }
            }
        }

        if (fileType === 'giocong' || fileType === 'thuongnong') {
            if (!foundMapping.maNV && !foundMapping.hoTen) {
                 allRequiredFound = false;
                const missingMsg = 'M√£ NV ho·∫∑c T√™n NV';
                missingColumns.push(missingMsg);
                if (!newDebugInfo.required.some(r => r.displayName.includes('NV'))) {
                     newDebugInfo.required.push({ displayName: missingMsg, foundName: 'Kh√¥ng t√¨m th·∫•y', status: false });
                }
            }
        }

        if (!allRequiredFound) {
            debugInfo.update(currentInfo => ({ ...currentInfo, [fileType]: newDebugInfo }));
            return { normalizedData: [], success: false, missingColumns };
        }

        // [LOGIC PREP]
        let heSoMap = {};
        if (fileType === 'ycx') {
            heSoMap = helpers.getHeSoQuyDoi(); 
        }

        const normalizedData = rawData.map((row, index) => {
            const newRow = {};
            for (const key in foundMapping) {
                if (foundMapping[key]) {
                    if (key === 'maNV' || key === 'hoTen' || key === 'maSanPham') {
                         newRow[key] = String(row[foundMapping[key]] || '').trim();
                    } else if ((key === 'ngayTao' || key === 'ngayHenGiao') && row[foundMapping[key]]) {
                        const dateValue = row[foundMapping[key]];
                        if (dateValue instanceof Date) {
                             newRow[key] = dateValue;
                        } else if (typeof dateValue === 'number') {
                            newRow[key] = new Date(Math.round((dateValue - 25569) * 86400 * 1000));
                        } else if (typeof dateValue === 'string') {
                             const parsedDate = new Date(dateValue.replace(/(\d{2})\/(\d{2})\/(\d{4})/, '$2/$1/$3'));
                            if (!isNaN(parsedDate.getTime())) newRow[key] = parsedDate;
                        }
                    } else {
                         newRow[key] = row[foundMapping[key]];
                    }
                }
            }

            // --- [NEW LOGIC FIXED] T√çNH TO√ÅN DOANH THU QUY ƒê·ªîI ---
            if (fileType === 'ycx') {
                // 1. Chu·∫©n h√≥a doanh thu th·ª±c
                let revenue = 0;
                if (newRow.thanhTien) {
                    revenue = parseFloat(String(newRow.thanhTien).replace(/,/g, '')) || 0;
                }
                newRow.revenue = revenue; 

                // 2. X√°c ƒë·ªãnh H·ªá s·ªë g·ªëc (Base Rate)
                const productKey = String(newRow.nhomHang || '').trim();
                const baseRate = heSoMap[productKey] || 1;

                // 3. X√°c ƒë·ªãnh th∆∞·ªüng Tr·∫£ G√≥p (Bonus Rate) - D√πng includes thay v√¨ Set
                const exportModeRaw = String(newRow.hinhThucXuat || '');
                const exportModeLower = exportModeRaw.toLowerCase();
                
                // Logic: Ch·ªâ c·∫ßn ch·ª©a t·ª´ kh√≥a "tr·∫£ g√≥p" ho·∫∑c "tr·∫£ ch·∫≠m" l√† d√≠nh
                const isInstallment = exportModeLower.includes('tr·∫£ g√≥p') || exportModeLower.includes('tr·∫£ ch·∫≠m');
                const bonusRate = isInstallment ? 0.3 : 0;

                // 4. T√≠nh to√°n
                newRow.heSoQuyDoi = baseRate + bonusRate; 
                newRow.revenueQuyDoi = revenue * newRow.heSoQuyDoi;
                
                // [DEBUG LOG - CH·ªà HI·ªÜN 1 D√íNG ƒê·∫¶U TI√äN ƒê·ªÇ SOI]
                if (index === 0) {
                    console.group(`%cüîç DEBUG LOGIC QUY ƒê·ªîI (D√≤ng 1)`, "color: white; background: red; font-weight: bold; padding: 2px 5px");
                    console.log(`- S·∫£n ph·∫©m: ${productKey}`);
                    console.log(`- H·ªá s·ªë g·ªëc (Base): ${baseRate}`);
                    console.log(`- H√¨nh th·ª©c xu·∫•t: "${exportModeRaw}"`);
                    console.log(`- C√≥ ph·∫£i tr·∫£ g√≥p kh√¥ng?: ${isInstallment ? '‚úÖ C√ì (+30%)' : '‚ùå KH√îNG'}`);
                    console.log(`- T·ªïng h·ªá s·ªë: ${baseRate} + ${bonusRate} = ${newRow.heSoQuyDoi}`);
                    console.log(`- Doanh thu g·ªëc: ${revenue.toLocaleString()}`);
                    console.log(`- Doanh thu quy ƒë·ªïi: ${newRow.revenueQuyDoi.toLocaleString()}`);
                    console.groupEnd();
                }
            }
            // ------------------------------------------------------------------

            return newRow;
        });

        if (fileType === 'giocong') {
            const giocongRawList = rawData.map(row => {
                const newRow = {};
                for (const key in foundMapping) {
                    if (foundMapping[key]) newRow[key] = row[foundMapping[key]];
                }
                return newRow;
            });
            rawGioCongData.set(giocongRawList);
        }

        newDebugInfo.firstFiveMsnv = normalizedData.slice(0, 5).map(r => r.maNV).filter(Boolean);
        debugInfo.update(currentInfo => ({ ...currentInfo, [fileType]: newDebugInfo }));
        
        return { normalizedData, success: true, missingColumns: [] };
    }
};
<<< FILE_END: src/services/processing/normalizers.js

>>> FILE_START: src/services/processing/parsers/cluster.parser.js
// src/services/processing/parsers/cluster.parser.js
import { formatters } from '../../../utils/formatters.js';

export const clusterParser = {
    /**
     * 1. X·ª≠ l√Ω "Thi ƒëua si√™u th·ªã l≈©y k·∫ø" (Logic 3 T·∫ßng)
     */
    parseCompetitionStr: (text) => {
        if (!text) return null;
        const lines = text.split('\n').map(l => l.trim()).filter(l => l);
        
        // T·∫ßng 1: T√¨m danh s√°ch Ng√†nh h√†ng
        let categories = [];
        const domainIndex = lines.findIndex(l => l.toLowerCase().includes('t√™n mi·ªÅn'));
        if (domainIndex !== -1 && domainIndex + 1 < lines.length) {
            // L·∫•y d√≤ng ngay sau "t√™n mi·ªÅn"
            // T√°ch theo tab ho·∫∑c kho·∫£ng tr·∫Øng l·ªõn (2 spaces tr·ªü l√™n)
            categories = lines[domainIndex + 1].split(/\t|\s{2,}/).filter(s => s.trim());
        }

        // T·∫ßng 2: T√¨m t·ª∑ tr·ªçng % T·ªïng
        let totalPercents = [];
        const totalIndex = lines.findIndex(l => l.toLowerCase() === 't·ªïng' || l.toLowerCase().startsWith('t·ªïng '));
        if (totalIndex !== -1 && totalIndex + 1 < lines.length) {
            totalPercents = lines[totalIndex + 1].split(/\t|\s+/).filter(s => s.includes('%'));
        }

        // T·∫ßng 3: T√¨m Si√™u th·ªã v√† Data chi ti·∫øt
        const stores = [];
        // B·∫Øt ƒë·∫ßu qu√©t t·ª´ sau d√≤ng T·ªïng + 1 (d√≤ng ch·ª©a %)
        let startIndex = totalIndex !== -1 ? totalIndex + 2 : 0;
        
        for (let i = startIndex; i < lines.length; i++) {
            const line = lines[i];
            
            // Nh·∫≠n di·ªán T√™n si√™u th·ªã: L√† d√≤ng ch·ª©a k√Ω t·ª± ch·ªØ, KH√îNG ch·ª©a qu√° nhi·ªÅu s·ªë
            // Logic: N·∫øu d√≤ng ti·∫øp theo (i+1) ch·ª©a c·∫∑p gi√° tr·ªã (% v√† s·ªë) -> D√≤ng hi·ªán t·∫°i l√† T√™n Si√™u Th·ªã
            const nextLine = lines[i+1];
            if (nextLine && /[\d]+/.test(nextLine) && nextLine.includes('%')) {
                const storeName = line;
                const rawValues = nextLine.split(/\t|\s+/).filter(s => s);
                
                // Parse c·∫∑p gi√° tr·ªã: Xen k·∫Ω % (Th·ª±c hi·ªán) v√† S·ªë (Doanh thu)
                // C·∫•u tr√∫c mong ƒë·ª£i: [Val1_%, Val1_DT, Val2_%, Val2_DT...]
                const storeData = categories.map((cat, idx) => {
                    // M·ªói category chi·∫øm 2 v·ªã tr√≠ trong m·∫£ng rawValues
                    const pIndex = idx * 2;
                    const vIndex = idx * 2 + 1;
                    
                    return {
                        category: cat,
                        percent: rawValues[pIndex] || '0%',
                        revenue: formatters.parseNumber(rawValues[vIndex] || '0')
                    };
                });

                stores.push({
                    name: storeName,
                    data: storeData
                });
                
                i++; // Nh·∫£y qua d√≤ng d·ªØ li·ªáu ƒë·ªÉ ti·∫øp t·ª•c v√≤ng l·∫∑p
            }
        }

        return {
            categories,
            totalPercents,
            stores
        };
    },

    /**
     * 2. X·ª≠ l√Ω "Data l≈©y k·∫ø" (T·ªïng C·ª•m + Chi ti·∫øt 16 c·ªôt)
     */
    parseCumulativeStr: (text) => {
        if (!text) return null;
        const lines = text.split('\n').map(l => l.trim());
        const fullText = lines.join(' ');

        // A. Parse T·ªïng C·ª•m (KPI Cards)
        const kpiMapping = {
            'DTLK': { key: 'dtThuc', type: 'money' },
            'DT D·ª± Ki·∫øn': { key: 'dtThucDuKien', type: 'money' },
            'DTQƒê': { key: 'dtQuyDoi', type: 'money' },
            'DT D·ª± Ki·∫øn (Qƒê)': { key: 'dtQuyDoiDuKien', type: 'money' },
            '% HT Target D·ª± Ki·∫øn (Qƒê)': { key: 'percentQuyDoi', type: 'percent' },
            'DTCK Th√°ng': { key: 'growth', type: 'growth' }, // L·∫•y c·∫£ 2 gi√° tr·ªã
            'T·ª∑ Tr·ªçng Tr·∫£ G√≥p': { key: 'traGopPercent', type: 'percent' },
            'DT Si√™u th·ªã': { key: 'traGopRevenue', type: 'money' }
        };

        const generalStats = {};

        // Helper regex t√¨m gi√° tr·ªã sau t·ª´ kh√≥a
        const findVal = (keyword) => {
            // Regex: T√¨m keyword -> b·ªè qua kho·∫£ng tr·∫Øng/d·∫•u : -> l·∫•y c·ª•m s·ªë (c√≥ th·ªÉ c√≥ d·∫•u , . % - +)
            const escaped = keyword.replace('(', '\\(').replace(')', '\\)');
            const regex = new RegExp(`${escaped}\\s*[:]?\\s*([\\d,.]+%?)`, 'i');
            const match = fullText.match(regex);
            return match ? match[1] : '0';
        };

        Object.keys(kpiMapping).forEach(label => {
            const config = kpiMapping[label];
            if (config.key === 'growth') {
                // X·ª≠ l√Ω ri√™ng cho TƒÉng tr∆∞·ªüng (l·∫•y 2 gi√° tr·ªã: s·ªë ti·ªÅn v√† %)
                const regex = /DTCK Th√°ng\s*[:]?\s*([+\-\d,.]+)\s+([+\-\d,.]+%)/i;
                const match = fullText.match(regex);
                if (match) {
                    generalStats[config.key] = {
                        value: formatters.parseNumber(match[1]),
                        percent: match[2]
                    };
                }
            } else {
                const raw = findVal(label);
                generalStats[config.key] = config.type === 'percent' ? raw : formatters.parseNumber(raw);
            }
        });

        // B. Parse Chi ti·∫øt Si√™u th·ªã (16 c·ªôt ngang)
        const storeDetails = [];
        
        // T√¨m d√≤ng ch·ª©a t·ª´ kh√≥a "T·ªïng" -> Sau ƒë√≥ l√† T√™n Si√™u Th·ªã -> Sau ƒë√≥ l√† Data
        // Regex: T√¨m ch·ªØ "T·ªïng" -> (Nh√≥m 1: T√™n si√™u th·ªã) -> (Nh√≥m 2: Chu·ªói s·ªë li·ªáu c√≤n l·∫°i)
        // Gi·∫£ ƒë·ªãnh T√™n si√™u th·ªã kh√¥ng ch·ª©a s·ªë, ho·∫∑c √≠t s·ªë. Data b·∫Øt ƒë·∫ßu b·∫±ng s·ªë.
        lines.forEach(line => {
            if (line.includes('T·ªïng')) {
                // T√°ch ph·∫ßn sau ch·ªØ T·ªïng
                const afterTong = line.split('T·ªïng')[1].trim();
                
                // T√°ch T√™n si√™u th·ªã v√† D·ªØ li·ªáu
                // C√°ch t√°ch: T√¨m v·ªã tr√≠ c·ªßa con s·ªë ƒë·∫ßu ti√™n
                const firstDigitIndex = afterTong.search(/[\d-]/); // T√¨m s·ªë ho·∫∑c d·∫•u √¢m
                
                if (firstDigitIndex !== -1) {
                    const storeName = afterTong.substring(0, firstDigitIndex).trim();
                    const dataPart = afterTong.substring(firstDigitIndex).trim();
                    
                    // T√°ch c√°c c·ªôt d·ªØ li·ªáu (Space ho·∫∑c Tab)
                    const cols = dataPart.split(/\s+/);
                    
                    // Map 16 c·ªôt c·ªë ƒë·ªãnh
                    if (cols.length >= 15) { // Ch·∫•p nh·∫≠n thi·∫øu 1 v√†i c·ªôt cu·ªëi n·∫øu data l·ªói
                         storeDetails.push({
                            name: storeName,
                            dtHomQua: formatters.parseNumber(cols[0]),
                            dtLuyKe: formatters.parseNumber(cols[1]),
                            dtDuKien: formatters.parseNumber(cols[2]),
                            dtQuyDoi: formatters.parseNumber(cols[3]),
                            dtQuyDoiDuKien: formatters.parseNumber(cols[4]),
                            percentHTQuyDoi: cols[5],
                            growthNum: formatters.parseNumber(cols[6]),
                            growthPercent: cols[7], // +/- DTCK Th√°ng (Qƒê) ??? C·∫ßn check l·∫°i th·ª© t·ª±
                            laiGopQuyDoi: formatters.parseNumber(cols[8]),
                            percentLNTT: cols[9],
                            luotKhachLK: formatters.parseNumber(cols[10]),
                            growthLuotKhach: cols[11],
                            tlpvtcLK: cols[12],
                            growthTlpvtc: cols[13],
                            tyTrongTraGop: cols[14],
                            growthTraGop: cols[15] || '0%'
                        });
                    }
                }
            }
        });

        return {
            generalStats,
            storeDetails
        };
    }
};
<<< FILE_END: src/services/processing/parsers/cluster.parser.js

>>> FILE_START: src/services/processing/parsers/employee.parser.js
import readXlsxFile from 'read-excel-file';

// C·∫•u h√¨nh Schema ƒë·ªÉ map c·ªôt t·ª´ Excel sang bi·∫øn
const SCHEMA = {
  'M√£ nh√¢n vi√™n': {
    prop: 'ma_nv',
    type: String,
    required: true
  },
  'T√™n nh√¢n vi√™n': {
    prop: 'ten_nv',
    type: String,
    required: true
  },
  'M√£ kho': {
    prop: 'ma_kho',
    type: String,
    required: true
  },
  'M√£ c·ª•m': {
    prop: 'ma_cum',
    type: String,
    // Kh√¥ng b·∫Øt bu·ªôc required: true n·∫øu c√≥ nh√¢n vi√™n kh√¥ng thu·ªôc c·ª•m, 
    // nh∆∞ng c·∫ßn ƒë·ªãnh nghƒ©a ƒë·ªÉ map ƒë√∫ng c·ªôt
  },
  'V·ªã tr√≠': {
    prop: 'vi_tri',
    type: String
  },
  'Ng√†y v√†o l√†m': {
    prop: 'ngay_vao_lam',
    type: Date
  }
  // Th√™m c√°c c·ªôt kh√°c n·∫øu c·∫ßn thi·∫øt
};

export const parseEmployeeData = async (file) => {
  try {
    const { rows, errors } = await readXlsxFile(file, { schema: SCHEMA });

    if (errors && errors.length > 0) {
      console.error('L·ªói ƒë·ªçc file nh√¢n vi√™n:', errors);
      // C√≥ th·ªÉ throw l·ªói ho·∫∑c v·∫´n x·ª≠ l√Ω ti·∫øp t√πy logic business
    }

    // Set ƒë·ªÉ l∆∞u c√°c m√£ duy nh·∫•t
    const warehouseSet = new Set();
    const clusterSet = new Set();

    // Duy·ªát qua t·ª´ng d√≤ng ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu v√† thu th·∫≠p meta data
    const processedData = rows.map((row) => {
      // Chu·∫©n h√≥a d·ªØ li·ªáu (trim spaces, uppercase n·∫øu c·∫ßn)
      const maKho = row.ma_kho ? row.ma_kho.toString().trim().toUpperCase() : '';
      const maCum = row.ma_cum ? row.ma_cum.toString().trim().toUpperCase() : '';

      // Th√™m v√†o Set ƒë·ªÉ ƒë·∫øm
      if (maKho) warehouseSet.add(maKho);
      if (maCum) clusterSet.add(maCum);

      return {
        ...row,
        ma_kho: maKho,
        ma_cum: maCum,
        // Gi·ªØ l·∫°i gi√° tr·ªã g·ªëc ho·∫∑c x·ª≠ l√Ω th√™m c√°c tr∆∞·ªùng kh√°c t·∫°i ƒë√¢y
      };
    });

    // --- LOGIC X·ª¨ L√ù ƒêA KHO & B·ªò L·ªåC ---
    
    // Chuy·ªÉn Set th√†nh Array
    const uniqueWarehouses = Array.from(warehouseSet).sort();
    const uniqueClusters = Array.from(clusterSet).sort();

    // Logic k√≠ch ho·∫°t ch·∫ø ƒë·ªô ƒëa kho: N·∫øu c√≥ t·ª´ 2 m√£ kho tr·ªü l√™n
    const isMultiWarehouseMode = uniqueWarehouses.length >= 2;

    // Chu·∫©n b·ªã d·ªØ li·ªáu cho b·ªô l·ªçc (Filter Options)
    // 1. Options cho Kho (gi·ªØ nguy√™n m√£)
    const warehouseOptions = uniqueWarehouses.map(code => ({
      value: code,
      label: code,
      type: 'warehouse'
    }));

    // 2. Options cho C·ª•m (Th√™m ch·ªØ "C·ª•m" v√†o label ƒë·ªÉ ph√¢n bi·ªát)
    const clusterOptions = uniqueClusters.map(code => ({
      value: code, // Value v·∫´n gi·ªØ nguy√™n ƒë·ªÉ filter d·ªØ li·ªáu ch√≠nh x√°c
      label: `C·ª•m ${code}`, // Label hi·ªÉn th·ªã: "C·ª•m AG01"
      type: 'cluster'
    }));

    // G·ªôp t·∫•t c·∫£ option v√†o m·ªôt m·∫£ng filter chung (n·∫øu UI d√πng chung 1 dropdown)
    // Ho·∫∑c UI c√≥ th·ªÉ d√πng ri√™ng l·∫ª t·ª´ meta
    const allFilterOptions = [...warehouseOptions, ...clusterOptions];

    // Tr·∫£ v·ªÅ c·∫•u tr√∫c ƒë·∫ßy ƒë·ªß
    return {
      data: processedData,
      meta: {
        isMultiWarehouseMode, // Flag k√≠ch ho·∫°t ch·∫ø ƒë·ªô
        uniqueWarehouses,     // Danh s√°ch m√£ kho th√¥
        uniqueClusters,       // Danh s√°ch m√£ c·ª•m th√¥
        warehouseOptions,     // Danh s√°ch options kho cho dropdown
        clusterOptions,       // Danh s√°ch options c·ª•m cho dropdown (ƒë√£ format t√™n)
        allFilterOptions,     // Danh s√°ch g·ªôp
        totalRows: processedData.length
      }
    };

  } catch (error) {
    console.error("Critical error parsing employee file:", error);
    throw error;
  }
};
<<< FILE_END: src/services/processing/parsers/employee.parser.js

>>> FILE_START: src/services/processing/parsers/erp.parser.js
// src/services/processing/parsers/erp.parser.js
export const erpParser = {
    processThuongERP: (pastedText) => {
        if (!pastedText || !pastedText.trim()) return [];
        
        // [FIX GENESIS] Thay ƒë·ªïi c√°ch split ƒë·ªÉ x·ª≠ l√Ω c·∫£ \r\n (Windows) v√† \n (Linux/Mac)
        // Th√™m .map(l => l.trim()) ngay l·∫≠p t·ª©c ƒë·ªÉ lo·∫°i b·ªè k√Ω t·ª± r√°c ƒë·∫ßu/cu·ªëi d√≤ng
        const lines = pastedText.trim().split(/\r?\n/).map(l => l.trim());
        
        const results = [];
        // Regex gi·ªØ nguy√™n logic c≈©
        const regex = /(ƒêML_|TGD|ƒêMM|ƒêMS).*?(BP .*?)(?:Nh√¢n Vi√™n|Tr∆∞·ªüng Ca)(.*?)([\d,]+)$/;
        
        lines.forEach(line => {
            // V√¨ ƒë√£ trim() ·ªü tr√™n, d√≤ng n√†y s·∫°ch.
            // Replace \s+ ƒë·ªÉ g·ªôp nhi·ªÅu d·∫•u c√°ch th√†nh 1 (an to√†n cho regex)
            const cleanLine = line.replace(/\s+/g, ' '); 
            const match = cleanLine.match(regex);
            
            if (match) {
                results.push({ 
                    name: match[3].trim(), 
                    bonus: match[4].trim() 
                });
            }
        });
        return results;
    }
};
<<< FILE_END: src/services/processing/parsers/erp.parser.js

>>> FILE_START: src/services/processing/parsers/luyke.parser.js
// src/services/processing/parsers/luyke.parser.js
import { competitionData } from '../../../stores.js';

export const luykeParser = {
    // 1. Ph√¢n t√≠ch c√°c ch·ªâ s·ªë KPI ch√≠nh (DT, DTQƒê, %HT)
    parseLuyKePastedData: (text) => {
        const defaults = {
            mainKpis: {},
            comparisonData: { value: 0, percentage: 'N/A' },
            luotKhachData: { value: 0, percentage: 'N/A' },
            dtDuKien: 0, dtqdDuKien: 0, dtTraCham: 0, tyLeTraCham: 0 
        };
        if (!text) return defaults;

        const allLines = text.split('\n').map(line => line.trim());
        const textContent = allLines.join(' ');

        const patterns = {
            'Th·ª±c hi·ªán DT th·ª±c': /DTLK\s+([\d,.]+)/,
            'Th·ª±c hi·ªán DTQƒê': /DTQƒê\s+([\d,.]+)/,
            '% HT Target D·ª± Ki·∫øn (Qƒê)': /% HT Target D·ª± Ki·∫øn \(Qƒê\)\s+([\d.]+%?)/,
        };

        for (const [key, regex] of Object.entries(patterns)) {
            const match = textContent.match(regex);
            if (match && match[1]) {
                defaults.mainKpis[key] = match[1];
            }
        }

        const findValueAfterKeyword = (lines, keyword, isQd = false) => {
            let keywordRegex;
            if (isQd) {
                keywordRegex = new RegExp(keyword.replace('(', '\\(').replace(')', '\\)'));
            } else {
                keywordRegex = new RegExp(`^${keyword}$`);
            }

            const index = lines.findIndex(line => keywordRegex.test(line) && !/l∆∞·ª£t kh√°ch/i.test(line));
            if (index !== -1 && index + 1 < lines.length) {
                return parseFloat(lines[index + 1].replace(/,/g, '').replace(/%/g, '')) || 0;
            }
            return 0;
        };

        defaults.dtDuKien = findValueAfterKeyword(allLines, "DT D·ª± Ki·∫øn");
        defaults.dtqdDuKien = findValueAfterKeyword(allLines, "DT D·ª± Ki·∫øn (Qƒê)", true);
        defaults.dtTraCham = findValueAfterKeyword(allLines, "DT Si√™u th·ªã");
        defaults.tyLeTraCham = findValueAfterKeyword(allLines, "T·ª∑ Tr·ªçng Tr·∫£ G√≥p");

        // T√¨m tƒÉng tr∆∞·ªüng c√πng k·ª≥
        const dtckIndex = allLines.findIndex(line => line.includes('DTCK Th√°ng'));
        if (dtckIndex !== -1 && dtckIndex + 1 < allLines.length) {
            const valueLine = allLines[dtckIndex + 1];
            const values = valueLine.split(/\s+/);
            if (values.length >= 2) {
                defaults.comparisonData = {
                    value: parseFloat(values[0].replace(/,/g, '')) || 0,
                    percentage: values[1] || 'N/A'
                };
            }
        }

        // T√¨m l∆∞·ª£t kh√°ch
        const luotKhachIndex = allLines.findIndex(line => line.includes('L∆∞·ª£t Kh√°ch CK Th√°ng'));
        if (luotKhachIndex !== -1 && luotKhachIndex + 1 < allLines.length) {
            const valueLine = allLines[luotKhachIndex + 1];
            const values = valueLine.split(/\s+/);
            if (values.length >= 2) {
                defaults.luotKhachData = {
                    value: parseFloat(values[0].replace(/,/g, '')) || 0,
                    percentage: values[1] || 'N/A'
                };
            }
        }

        return defaults;
    },

    // 2. Ph√¢n t√≠ch danh s√°ch c√°c ch∆∞∆°ng tr√¨nh thi ƒëua (T·ªïng h·ª£p)
    parseCompetitionDataFromLuyKe: (text) => {
        if (!text || !text.trim()) return [];
        const lines = text.split('\n').map(l => l.trim());
        const results = [];
        let currentCompetition = null;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line.toLowerCase().startsWith('thi ƒëua')) {
                if (currentCompetition) results.push(currentCompetition);
                currentCompetition = {
                    name: line.replace("Thi ƒëua doanh thu", "DT").replace("Thi ƒëua s·ªë l∆∞·ª£ng", "SL"),
                    type: line.toLowerCase().includes('doanh thu') ? 'doanhThu' : 'soLuong',
                    luyKe: 0, target: 0, hoanThanh: '0%'
                };
            } else if (currentCompetition) {
                if (line.startsWith('DTLK') || line.startsWith('SLLK') || line.startsWith('DTQƒê')) {
                     if (i + 1 < lines.length) {
                         currentCompetition.luyKe = parseFloat(lines[i + 1].replace(/,/g, '')) || 0;
                    }
                } else if (line.startsWith('Target')) {
                    if (i + 1 < lines.length) {
                        currentCompetition.target = parseFloat(lines[i + 1].replace(/,/g, '')) || 0;
                    }
                } else if (line.startsWith('% HT D·ª± Ki·∫øn')) {
                    if (i + 1 < lines.length) {
                         currentCompetition.hoanThanh = lines[i + 1] || '0%';
                    }
                }
            }
        }
        if (currentCompetition) results.push(currentCompetition);

        competitionData.set(results);
        return results;
    }
};
<<< FILE_END: src/services/processing/parsers/luyke.parser.js

>>> FILE_START: src/services/processing/parsers/thidua.parser.js
// src/services/processing/parsers/thidua.parser.js
import { debugInfo } from '../../../stores.js';

export const thiduaParser = {
    parsePastedThiDuaTableData(rawText) {
        const newDebugInfo = { required: [], found: [], status: 'B·∫Øt ƒë·∫ßu ph√¢n t√≠ch...' };

        if (!rawText || !rawText.trim()) {
            newDebugInfo.status = 'L·ªói: D·ªØ li·ªáu d√°n v√†o r·ªóng.';
            debugInfo.update(current => ({ ...current, 'thiduanv-pasted': newDebugInfo }));
            return { success: false, error: newDebugInfo.status, mainHeaders: [], subHeaders: [], dataRows: [] };
        }

        const lines = rawText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        const splitRegex = /\s{2,}|\t/; 
        const numberCheckRegex = /^-?[\d,.]+$/;

        const mainHeaderStartIndex = lines.findIndex(line => line.includes('Ph√≤ng ban'));
        const subHeaderStartIndex = lines.findIndex(line => line.startsWith('DTLK') || line.startsWith('SLLK') || line.startsWith('DTQƒê'));
        
        let dataEndIndex = lines.findIndex(line => line.includes('H·ªó tr·ª£ BI'));
        if (dataEndIndex === -1) {
            dataEndIndex = lines.length;
        }

        const dataRowsStartIndex = lines.findIndex((line, index) => {
            if (index <= subHeaderStartIndex) return false;
            const parts = line.split(splitRegex).map(p => p.trim());
            const firstPart = parts[0] || "";

            if (firstPart.startsWith('T·ªïng') || firstPart.startsWith('BP ') || firstPart.startsWith('DTLK') || firstPart.startsWith('SLLK') || firstPart.startsWith('DTQƒê')) {
               return false;
            }
            return parts.length > 1 && numberCheckRegex.test(parts[1]);
        });

        if (mainHeaderStartIndex === -1 || subHeaderStartIndex === -1 || dataRowsStartIndex === -1) {
            let error = "D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá thi ƒëua ng√†nh h√†ng theo nh√¢n vi√™n, vui l√≤ng ki·ªÉm tra l·∫°i";
            newDebugInfo.status = error;
            debugInfo.update(current => ({ ...current, 'thiduanv-pasted': newDebugInfo }));
            return { success: false, error: error, mainHeaders: [], subHeaders: [], dataRows: [] };
        }
        
        const mainHeaderLines = lines.slice(mainHeaderStartIndex + 1, subHeaderStartIndex);
        const mainHeaderString = mainHeaderLines.join('\t');
        const mainHeaders = mainHeaderString.split(splitRegex).filter(Boolean);
        newDebugInfo.found.push({ name: 'Ti√™u ƒë·ªÅ ch√≠nh (Ng√†nh h√†ng)', value: `${mainHeaders.length} m·ª•c`, status: mainHeaders.length > 0 });

        const subHeaderLines = lines.slice(subHeaderStartIndex, dataRowsStartIndex);
        const subHeaderString = subHeaderLines.join('\t');
        const subHeaders = subHeaderString.split(/\s+/).filter(Boolean);
        newDebugInfo.found.push({ name: 'Ti√™u ƒë·ªÅ ph·ª• (SLLK/DTQƒê)', value: `${subHeaders.length} m·ª•c`, status: subHeaders.length > 0 });

        const potentialDataLines = lines.slice(dataRowsStartIndex, dataEndIndex);
        const dataRows = [];
        
        for (const line of potentialDataLines) {
            const parts = line.split(splitRegex).map(p => p.trim());
            const firstPart = parts[0] || "";

            if (firstPart.startsWith('T·ªïng') || firstPart.startsWith('BP ')) {
                continue;
            }

            if (parts.length > 1 && numberCheckRegex.test(parts[1])) {
                dataRows.push({
                    name: firstPart,
                    values: parts.slice(1)
                });
            }
        }
        newDebugInfo.found.push({ name: 'D√≤ng d·ªØ li·ªáu nh√¢n vi√™n', value: `${dataRows.length} d√≤ng`, status: dataRows.length > 0 });

        if (mainHeaders.length === 0 || subHeaders.length === 0 || dataRows.length === 0) {
            newDebugInfo.status = 'L·ªói: Kh√¥ng th·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu. Thi·∫øu Ti√™u ƒë·ªÅ ch√≠nh, Ti√™u ƒë·ªÅ ph·ª•, ho·∫∑c D√≤ng d·ªØ li·ªáu (sau khi l·ªçc).';
            debugInfo.update(current => ({ ...current, 'thiduanv-pasted': newDebugInfo }));
            return { success: false, error: newDebugInfo.status, mainHeaders, subHeaders, dataRows };
        }
        
        const expectedDataCols = subHeaders.length;
        if (dataRows.length > 0 && dataRows[0].values.length !== expectedDataCols) {
             newDebugInfo.status = `C·∫£nh b√°o: S·ªë c·ªôt kh√¥ng kh·ªõp! Ti√™u ƒë·ªÅ ph·ª• (${expectedDataCols}) vs D·ªØ li·ªáu (${dataRows[0].values.length}).`;
        } else {
           newDebugInfo.status = `Ph√¢n t√≠ch th√†nh c√¥ng.`;
        }
        
        debugInfo.update(current => ({ ...current, 'thiduanv-pasted': newDebugInfo }));
        return { success: true, mainHeaders, subHeaders, dataRows };
    }
};
<<< FILE_END: src/services/processing/parsers/thidua.parser.js

>>> FILE_START: src/services/processing/parsers.js
// src/services/processing/parsers.js
import { erpParser } from './parsers/erp.parser.js';
import { luykeParser } from './parsers/luyke.parser.js';
import { thiduaParser } from './parsers/thidua.parser.js';

export const parsers = {
    // --- ERP Logic ---
    processThuongERP: erpParser.processThuongERP,

    // --- Luy Ke Logic ---
    parseLuyKePastedData: luykeParser.parseLuyKePastedData,
    parseCompetitionDataFromLuyKe: luykeParser.parseCompetitionDataFromLuyKe,

    // --- Thi Dua Nhan Vien Logic ---
    parsePastedThiDuaTableData: thiduaParser.parsePastedThiDuaTableData
};
<<< FILE_END: src/services/processing/parsers.js

>>> FILE_START: src/services/processing/processors.js
// src/services/processing/processors.js
import { competitionProcessor } from './logic/competition.processor.js';
import { timekeepingProcessor } from './logic/timekeeping.processor.js';
import { regionalProcessor } from './logic/regional.processor.js';

export const processors = {
    // --- COMPETITION LOGIC ---
    debugCompetitionFiltering: competitionProcessor.debugCompetitionFiltering,
    updateCompetitionNameMappings: competitionProcessor.updateCompetitionNameMappings,
    processThiDuaNhanVienData: competitionProcessor.processThiDuaNhanVienData,

    // --- TIMEKEEPING LOGIC ---
    processGioCongData: timekeepingProcessor.processGioCongData,

    // --- REGIONAL LOGIC ---
    processThiDuaVungFile: regionalProcessor.processThiDuaVungFile
};
<<< FILE_END: src/services/processing/processors.js

>>> FILE_START: src/services/reportService.js
// src/services/reportService.js
// Version 3.0 - Modular Facade
// File n√†y ch·ªâ ƒë√≥ng vai tr√≤ ƒëi·ªÅu ph·ªëi, logic ƒë√£ ƒë∆∞·ª£c t√°ch ra th∆∞ m·ª•c reports/

import { masterReportLogic } from './reports/master.report.js';
import { competitionReportLogic } from './reports/competition.report.js';
import { detailReportLogic } from './reports/detail.report.js';
import { generalReportLogic } from './reports/general.report.js';

export const reportService = {
    ...masterReportLogic,
    ...competitionReportLogic,
    ...detailReportLogic,
    ...generalReportLogic
};
<<< FILE_END: src/services/reportService.js

>>> FILE_START: src/services/reports/competition.report.js
// src/services/reports/competition.report.js
// Version 1.1 - Fix: Include maKho in result for Realtime filtering
import { get } from 'svelte/store';
import * as utils from '../../utils.js';
import { dataProcessing } from '../dataProcessing.js';
import {
    danhSachNhanVien,
    specialProductList,
    thiDuaVungChiTiet,
    thiDuaVungTong
} from '../../stores.js';

export const competitionReportLogic = {
    calculateSpecialProductReport(sourceYcxData, specialProgramConfigs) {
        const $specialProductList = get(specialProductList);
        if (!sourceYcxData || sourceYcxData.length === 0 ||
            !specialProgramConfigs || specialProgramConfigs.length === 0 ||
            !$specialProductList || $specialProductList.length === 0) {
            return [];
        }

        const hinhThucXuatTinhDoanhThu = dataProcessing.getHinhThucXuatTinhDoanhThu();
        const validSalesData = sourceYcxData.filter(row => {
            const isDoanhThuHTX = hinhThucXuatTinhDoanhThu.has(row.hinhThucXuat);
            const isBaseValid = (row.trangThaiThuTien || "").trim() === 'ƒê√£ thu' &&
                                (row.trangThaiHuy || "").trim() === 'Ch∆∞a h·ªßy' &&
                                (row.tinhTrangTra || "").trim() === 'Ch∆∞a tr·∫£' &&
                                (row.trangThaiXuat || "").trim() === 'ƒê√£ xu·∫•t';
            return isBaseValid && isDoanhThuHTX;
        });
        if (validSalesData.length === 0) return [];

        const $danhSachNhanVien = get(danhSachNhanVien);
        const report = specialProgramConfigs.map(program => {
            const programGroups = new Set((program.groups || []).map(g => String(g).trim()));
            if (programGroups.size === 0) return null;

            const specialProductSet = new Set(
                $specialProductList
                    .filter(sp => programGroups.has(String(sp.nhomHang).trim()))
                    .map(sp => String(sp.maSanPham).trim())
            );

            const totalGroupSales = validSalesData.filter(row => 
                programGroups.has(String(row.nhomHang).trim())
            );
    
            if (totalGroupSales.length === 0) return null;

            const employeeResults = $danhSachNhanVien.map(employee => {
                const stats = { slDacQuyen: 0, slNhomHang: 0, dtDacQuyen: 0, dtNhomHang: 0 };
                const employeeSales = totalGroupSales.filter(row => {
                    const msnvMatch = String(row.nguoiTao || '').match(/(\d+)/);
                    return msnvMatch && msnvMatch[1].trim() === employee.maNV;
                });
                if (employeeSales.length === 0) {
                    return { 
                        ...employee, 
                        maKho: employee.maKho, // [FIX] Ensure maKho is preserved
                        ...stats, 
                        tyLeSL: 0, 
                        tyLeDT: 0 
                    };
                }

                employeeSales.forEach(row => {
                    const maSanPham = String(row.maSanPham || '').trim();
                    const thanhTien = parseFloat(String(row.thanhTien || "0").replace(/,/g, '')) || 0;
                    const soLuong = parseInt(String(row.soLuong || "0"), 10) || 0;

                    stats.slNhomHang += soLuong;
                    stats.dtNhomHang += thanhTien;

                    if (specialProductSet.has(maSanPham)) {
                        stats.slDacQuyen += soLuong;
                        stats.dtDacQuyen += thanhTien;
                    }
                });
                const tyLeSL = stats.slNhomHang > 0 ? (stats.slDacQuyen / stats.slNhomHang) : 0;
                const tyLeDT = stats.dtNhomHang > 0 ? (stats.dtDacQuyen / stats.dtNhomHang) : 0;

                return {
                    maNV: employee.maNV,
                    hoTen: employee.hoTen,
                    boPhan: employee.boPhan,
                    maKho: employee.maKho, // [FIX] Add maKho here
                    ...stats,
                    tyLeSL,
                    tyLeDT
                };
            }).filter(e => e.slNhomHang > 0); 

            return {
                program: program,
                employeeData: employeeResults,
            };
        }).filter(Boolean); 

        return report;
    },

    calculateCompetitionFocusReport(sourceYcxData, competitionConfigs) {
        if (!sourceYcxData || sourceYcxData.length === 0 || !competitionConfigs || competitionConfigs.length === 0) {
            return [];
        }

        const hinhThucXuatTinhDoanhThu = dataProcessing.getHinhThucXuatTinhDoanhThu();
        const validSalesData = sourceYcxData.filter(row => {
            const isDoanhThuHTX = hinhThucXuatTinhDoanhThu.has(row.hinhThucXuat);
            const isBaseValid = (row.trangThaiThuTien || "").trim() === 'ƒê√£ thu' &&
                                 (row.trangThaiHuy || "").trim() === 'Ch∆∞a h·ªßy' &&
                                (row.tinhTrangTra || "").trim() === 'Ch∆∞a tr·∫£' &&
                                (row.trangThaiXuat || "").trim() === 'ƒê√£ xu·∫•t';
            return isBaseValid && isDoanhThuHTX;
        });
        const $danhSachNhanVien = get(danhSachNhanVien);

        const report = competitionConfigs.map(config => {
            const cleanedConfigGroups = new Set((config.groups || []).map(g => utils.cleanCategoryName(g)));

            let baseSalesData = validSalesData.filter(row => {
                const cleanNhomHangFromYCX = utils.cleanCategoryName(row.nhomHang);
                const isInGroup = cleanedConfigGroups.has(cleanNhomHangFromYCX);
                
                if (!isInGroup) return false;

                if (config.type === 'soluong' && (config.minPrice > 0 || config.maxPrice > 0)) {
                    const price = (parseFloat(String(row.thanhTien || "0").replace(/,/g, '')) || 0) / (parseInt(String(row.soLuong || "1"), 10) || 1);
                    const minPrice = config.minPrice || 0;
                    const maxPrice = config.maxPrice || Infinity;
                    if (price < minPrice || price > maxPrice) return false;
                }
                return true;
            });

            if (config.excludeApple) {
                baseSalesData = baseSalesData.filter(row => row.nhaSanXuat !== 'Apple');
            }

            const employeeResults = $danhSachNhanVien.map(employee => {
                let performanceByBrand = {};
                let totalTargetRevenue = 0;
                let totalTargetQuantity = 0;
                let baseCategoryRevenue = 0;
                let baseCategoryQuantity = 0;

                baseSalesData.forEach(row => {
                     const msnvMatch = String(row.nguoiTao || '').match(/(\d+)/);
                     if (msnvMatch && msnvMatch[1].trim() === employee.maNV) {
                        const revenueValue = (parseFloat(String(row.thanhTien || "0").replace(/,/g, '')) || 0);
                        const quantityValue = (parseInt(String(row.soLuong || "0"), 10) || 0);

                        baseCategoryRevenue += revenueValue;
                        baseCategoryQuantity += quantityValue;

                        const brand = row.nhaSanXuat;
                        if ((config.brands || []).includes(brand)) {
                            if (!performanceByBrand[brand]) {
                                performanceByBrand[brand] = { revenue: 0, quantity: 0 };
                            }
                            performanceByBrand[brand].revenue += revenueValue;
                            performanceByBrand[brand].quantity += quantityValue;

                            totalTargetRevenue += revenueValue;
                            totalTargetQuantity += quantityValue;
                        }
                    }
                });
                return {
                    maNV: employee.maNV,
                    hoTen: employee.hoTen,
                    boPhan: employee.boPhan,
                    maKho: employee.maKho, // [FIX] Add maKho here so filter works
                    performanceByBrand,
                    targetBrandsRevenue: totalTargetRevenue,
                    targetBrandsQuantity: totalTargetQuantity,
                    baseCategoryRevenue,
                    baseCategoryQuantity,
                    tyLeDT: baseCategoryRevenue > 0 ? (totalTargetRevenue / baseCategoryRevenue) : 0,
                    tyLeSL: baseCategoryQuantity > 0 ? (totalTargetQuantity / baseCategoryQuantity) : 0,
                };
            }).filter(e => e.baseCategoryRevenue > 0 || e.baseCategoryQuantity > 0);

            return {
                competition: config,
                employeeData: employeeResults,
            };
        }).filter(r => r.employeeData.length > 0);

        return report;
    },

    generateThiDuaVungReport(selectedSupermarket) {
        const $thiDuaVungChiTiet = get(thiDuaVungChiTiet);
        const $thiDuaVungTong = get(thiDuaVungTong);

        if (!selectedSupermarket || !$thiDuaVungChiTiet || $thiDuaVungChiTiet.length === 0 || !$thiDuaVungTong || $thiDuaVungTong.length === 0) {
            return null;
        }

        const findKey = (data, keyword) => {
            if (!data || data.length === 0) return null;
            return Object.keys(data[0]).find(k => k.trim().toLowerCase().includes(keyword.toLowerCase())) || keyword;
        };
        const supermarketKeyTong = findKey($thiDuaVungTong, 'si√™u th·ªã');
        const supermarketKeyChiTiet = findKey($thiDuaVungChiTiet, 'si√™u th·ªã');
        const tongThuongKey = findKey($thiDuaVungChiTiet, 't·ªïng th∆∞·ªüng');
        const hangVuotTroiKey = findKey($thiDuaVungChiTiet, 'h·∫°ng v∆∞·ª£t tr·ªôi');
        const hangTargetKey = findKey($thiDuaVungChiTiet, 'h·∫°ng % target');
        const layTopKey = findKey($thiDuaVungChiTiet, 'l·∫•y top');
        const kenhKey = findKey($thiDuaVungChiTiet, 'k√™nh');
        const nganhHangKey = findKey($thiDuaVungChiTiet, 'ng√†nh h√†ng');

        if (!supermarketKeyTong || !supermarketKeyChiTiet) {
            console.error("Kh√¥ng th·ªÉ t√¨m th·∫•y c·ªôt 'si√™u th·ªã' trong d·ªØ li·ªáu.");
            return null;
        }

        const summary = $thiDuaVungTong.find(row => row[supermarketKeyTong] === selectedSupermarket);
        if (!summary) return null;

        const chiTiet = $thiDuaVungChiTiet.filter(row => row[supermarketKeyChiTiet] === selectedSupermarket);

        if (chiTiet.length > 0 && layTopKey) {
            summary.hangCoGiaiKenh = chiTiet[0][layTopKey];
        } else {
            summary.hangCoGiaiKenh = 'N/A';
        }

        const report = { summary, coGiai: [], sapCoGiai: [], tiemNang: [], canCoGangNhieu: [] };

        const getPotentialPrize = (kenh, nganhHang) => {
            const winningSupermarkets = $thiDuaVungChiTiet.filter(sm =>
                sm[kenhKey] === kenh && sm[nganhHangKey] === nganhHang && sm[tongThuongKey] > 0
            );
            if (winningSupermarkets.length === 0) return 0;
            return Math.min(...winningSupermarkets.map(s => s[tongThuongKey]));
        };

        chiTiet.forEach(nganhHang => {
            if (nganhHang[tongThuongKey] > 0) {
                report.coGiai.push(nganhHang);
            } else {
                const hangVuotTroi = nganhHang[hangVuotTroiKey] || Infinity;
                const hangTarget = nganhHang[hangTargetKey] || Infinity;
                const hangCoGiai = nganhHang[layTopKey] || 0;

                const khoangCach = Math.min(
                    (hangVuotTroi > 0 && hangVuotTroi > hangCoGiai) ? hangVuotTroi - hangCoGiai : Infinity,
                    (hangTarget > 0 && hangTarget > hangCoGiai) ? hangTarget - hangCoGiai : Infinity
                );
                nganhHang.khoangCach = khoangCach;

                if (hangCoGiai > 0 && khoangCach <= 20) {
                    nganhHang.thuongTiemNang = getPotentialPrize(nganhHang[kenhKey], nganhHang[nganhHangKey]);
                    report.sapCoGiai.push(nganhHang);
                } else if (hangCoGiai > 0 && khoangCach > 20 && khoangCach <= 40) {
                    report.tiemNang.push(nganhHang);
                } else {
                    report.canCoGangNhieu.push(nganhHang);
                }
            }
        });

        report.coGiai.sort((a, b) => b[tongThuongKey] - a[tongThuongKey]);
        report.sapCoGiai.sort((a, b) => a.khoangCach - b.khoangCach);
        report.tiemNang.sort((a, b) => a.khoangCach - b.khoangCach);

        return report;
    }
};
<<< FILE_END: src/services/reports/competition.report.js

>>> FILE_START: src/services/reports/detail.report.js
// src/services/reports/detail.report.js
// Version 1.0 - Detail views logic
import { get } from 'svelte/store';
import * as utils from '../../utils.js';
import { formatters } from '../../utils/formatters.js';
import { dataProcessing } from '../dataProcessing.js';
import { masterReportData } from '../../stores.js';

export const detailReportLogic = {
    generateRealtimeEmployeeDetailReport(employeeMaNV, realtimeYCXData) {
        if (!employeeMaNV || !realtimeYCXData || realtimeYCXData.length === 0) return null;

        const employeeData = realtimeYCXData.filter(row => {
            const msnvMatch = String(row.nguoiTao || '').match(/(\d+)/);
            return msnvMatch && msnvMatch[1].trim() === String(employeeMaNV);
        });

        if (employeeData.length === 0) return null;

        const hinhThucXuatTinhDoanhThu = dataProcessing.getHinhThucXuatTinhDoanhThu();
        const heSoQuyDoi = dataProcessing.getHeSoQuyDoi();

        const summary = {
            totalRealRevenue: 0,
            totalConvertedRevenue: 0,
            unexportedRevenue: 0
        };
        const byProductGroup = {};
        const byCustomer = {};

        employeeData.forEach(row => {
            const isDoanhThuHTX = hinhThucXuatTinhDoanhThu.has(row.hinhThucXuat);
            const isBaseValid = (row.trangThaiThuTien || "").trim() === 'ƒê√£ thu' && (row.trangThaiHuy || "").trim() === 'Ch∆∞a h·ªßy' && (row.tinhTrangTra || "").trim() === 'Ch∆∞a tr·∫£';

            if (isDoanhThuHTX && isBaseValid) {
                const realRevenue = parseFloat(String(row.thanhTien || "0").replace(/,/g, '')) || 0;
                const quantity = parseInt(String(row.soLuong || "0"), 10) || 0;
                const heSo = heSoQuyDoi[row.nhomHang] || 1;
                
                // [FIX] D√πng revenueQuyDoi t·ª´ normalizer
                const convertedRevenue = row.revenueQuyDoi !== undefined ? row.revenueQuyDoi : (realRevenue * heSo);
                
                const groupName = utils.cleanCategoryName(row.nhomHang || 'Kh√°c');
                const customerName = row.tenKhachHang || 'Kh√°ch l·∫ª';

                if ((row.trangThaiXuat || "").trim() === 'ƒê√£ xu·∫•t') {
                    summary.totalRealRevenue += realRevenue;
                    summary.totalConvertedRevenue += convertedRevenue;

                    if (!byProductGroup[groupName]) {
                        byProductGroup[groupName] = { name: groupName, quantity: 0, realRevenue: 0, convertedRevenue: 0 };
                    }
                    byProductGroup[groupName].quantity += quantity;
                    byProductGroup[groupName].realRevenue += realRevenue;
                    byProductGroup[groupName].convertedRevenue += convertedRevenue;

                    if (!byCustomer[customerName]) {
                        byCustomer[customerName] = { name: customerName, products: [], totalQuantity: 0 };
                    }
                    byCustomer[customerName].products.push({
                        productName: row.tenSanPham,
                        quantity: quantity,
                        realRevenue: realRevenue,
                        convertedRevenue: convertedRevenue,
                    });
                    byCustomer[customerName].totalQuantity += quantity;
                } else if ((row.trangThaiXuat || "").trim() === 'Ch∆∞a xu·∫•t') {
                    summary.unexportedRevenue += convertedRevenue;
                }
            }
        });

        summary.totalOrders = Object.keys(byCustomer).length;
        summary.bundledOrderCount = Object.values(byCustomer).filter(c => c.totalQuantity > 1).length;
        summary.conversionRate = summary.totalRealRevenue > 0 ? (summary.totalConvertedRevenue / summary.totalRealRevenue) - 1 : 0;

        return {
            summary,
            byProductGroup: Object.values(byProductGroup).sort((a, b) => b.realRevenue - a.realRevenue),
            byCustomer: Object.values(byCustomer)
        };
    },

    generateLuyKeEmployeeDetailReport(employeeMaNV, luykeYCXData) {
        if (!employeeMaNV || !luykeYCXData || luykeYCXData.length === 0) {
            return null;
        }

        const employeeData = luykeYCXData.filter(row => {
            const msnvMatch = String(row.nguoiTao || '').match(/(\d+)/);
            return msnvMatch && msnvMatch[1].trim() === String(employeeMaNV);
        });

        if (employeeData.length === 0) {
             return null;
        }

        const hinhThucXuatTinhDoanhThu = dataProcessing.getHinhThucXuatTinhDoanhThu();
        const heSoQuyDoi = dataProcessing.getHeSoQuyDoi();

        const summary = {
            totalRealRevenue: 0,
            totalConvertedRevenue: 0,
            unexportedRevenue: 0, 
        };
        const byProductGroup = {};
        const byCustomer = {};
        const categoryChartDataMap = {};
        const dailyStats = {}; 
        const unexportedDetails = {};
        
        employeeData.forEach(row => {
            const isDoanhThuHTX = hinhThucXuatTinhDoanhThu.has(row.hinhThucXuat);
            
            const isBaseValid = (row.trangThaiThuTien || "").trim() === 'ƒê√£ thu' &&
                                (row.trangThaiHuy || "").trim() === 'Ch∆∞a h·ªßy' &&
                                (row.tinhTrangTra || "").trim() === 'Ch∆∞a tr·∫£';

            if (isDoanhThuHTX && isBaseValid) {
                const realRevenue = parseFloat(String(row.thanhTien || "0").replace(/,/g, '')) || 0;
                const quantity = parseInt(String(row.soLuong || "0"), 10) || 0;
                if(isNaN(realRevenue) || isNaN(quantity)) return;

                const heSo = heSoQuyDoi[row.nhomHang] || 1;
                
                // [FIX] D√πng revenueQuyDoi t·ª´ normalizer
                const convertedRevenue = row.revenueQuyDoi !== undefined ? row.revenueQuyDoi : (realRevenue * heSo);
                
                const groupName = utils.cleanCategoryName(row.nhomHang || 'Kh√°c');
                const customerName = row.tenKhachHang || 'Kh√°ch L·∫ª';
                const categoryName = utils.cleanCategoryName(row.nganhHang || 'Kh√°c');
                const productName = row.tenSanPham || 'Kh√¥ng r√µ';
                
                if ((row.trangThaiXuat || "").trim() === 'ƒê√£ xu·∫•t') {
                    summary.totalRealRevenue += realRevenue;
                    summary.totalConvertedRevenue += convertedRevenue;

                    if (!byProductGroup[groupName]) {
                        byProductGroup[groupName] = { name: groupName, quantity: 0, realRevenue: 0, convertedRevenue: 0 };
                    }
                    byProductGroup[groupName].quantity += quantity;
                    byProductGroup[groupName].realRevenue += realRevenue;
                    byProductGroup[groupName].convertedRevenue += convertedRevenue;

                    if (!categoryChartDataMap[categoryName]) {
                        categoryChartDataMap[categoryName] = { name: categoryName, revenue: 0 };
                    }
                    categoryChartDataMap[categoryName].revenue += realRevenue;
                    if (!byCustomer[customerName]) {
                        byCustomer[customerName] = { name: customerName, products: [], totalQuantity: 0, totalRealRevenue: 0, totalConvertedRevenue: 0 };
                    }
                    byCustomer[customerName].products.push({
                        productName: row.tenSanPham,
                        quantity: quantity,
                        realRevenue: realRevenue,
                        convertedRevenue: convertedRevenue,
                    });
                    byCustomer[customerName].totalQuantity += quantity;
                    byCustomer[customerName].totalRealRevenue += realRevenue;
                    byCustomer[customerName].totalConvertedRevenue += convertedRevenue;
                    
                    const ngayTao = row.ngayTao;
                    if (ngayTao instanceof Date) {
                        const dateString = ngayTao.toISOString().split('T')[0];
                        if (!dailyStats[dateString]) {
                            dailyStats[dateString] = { date: ngayTao, revenue: 0, convertedRevenue: 0 };
                        }
                        dailyStats[dateString].revenue += realRevenue;
                        dailyStats[dateString].convertedRevenue += convertedRevenue;
                    }

                } else if ((row.trangThaiXuat || "").trim() === 'Ch∆∞a xu·∫•t') {
                    summary.unexportedRevenue += convertedRevenue;

                    if (!unexportedDetails[groupName]) {
                        unexportedDetails[groupName] = { name: groupName, totalSL: 0, totalDTQD: 0, products: {} };
                    }
                    if (!unexportedDetails[groupName].products[productName]) {
                        unexportedDetails[groupName].products[productName] = { name: productName, sl: 0, dtqd: 0 };
                    }
                    unexportedDetails[groupName].products[productName].sl += quantity;
                    unexportedDetails[groupName].products[productName].dtqd += convertedRevenue;
                    unexportedDetails[groupName].totalSL += quantity;
                    unexportedDetails[groupName].totalDTQD += convertedRevenue;
                }
            }
        });

        summary.totalOrders = Object.keys(byCustomer).length;
        summary.bundledOrderCount = Object.values(byCustomer).filter(c => c.products.length > 1).length;
        summary.conversionRate = summary.totalRealRevenue > 0 ? (summary.totalConvertedRevenue / summary.totalRealRevenue) - 1 : 0;

        for (const customerName in byCustomer) {
            const customer = byCustomer[customerName];
            customer.conversionRate = customer.totalRealRevenue > 0 ? (customer.totalConvertedRevenue / customer.totalRealRevenue) - 1 : 0;
        }
        for (const groupName in byProductGroup) {
            const group = byProductGroup[groupName];
            group.conversionRate = group.realRevenue > 0 ? (group.convertedRevenue / group.realRevenue) - 1 : 0;
        }

        const finalDailyStats = Object.values(dailyStats).sort((a, b) => a.date - b.date);
        const finalUnexportedDetails = Object.values(unexportedDetails)
            .map(group => ({
                ...group,
                products: Object.values(group.products).sort((a, b) => b.dtqd - a.dtqd)
            }))
            .sort((a, b) => b.totalDTQD - a.totalDTQD);

        return {
            summary,
            topProductGroups: Object.values(byProductGroup)
                .sort((a, b) => b.realRevenue - a.realRevenue)
                .slice(0, 8),
            categoryChartData: Object.values(categoryChartDataMap),
            byCustomer: Object.values(byCustomer)
                .sort((a,b) => b.totalRealRevenue - a.totalRealRevenue),
            dailyStats: finalDailyStats, 
            unexportedDetails: finalUnexportedDetails 
        };
    }
};
<<< FILE_END: src/services/reports/detail.report.js

>>> FILE_START: src/services/reports/general.report.js
// src/services/reports/general.report.js
// Version 1.0 - General reports (Brand, Unexported)
import { get } from 'svelte/store';
import * as utils from '../../utils.js';
import { dataProcessing } from '../dataProcessing.js';
import { employeeMaNVMap } from '../../stores.js';

export const generalReportLogic = {
    generateRealtimeBrandReport(realtimeYCXData, selectedCategory, selectedBrand) {
        if (!realtimeYCXData || realtimeYCXData.length === 0) return { byBrand: [], byEmployee: [] };
        
        const $employeeMaNVMap = get(employeeMaNVMap);

        const filteredData = realtimeYCXData.filter(row => {
            const categoryMatch = !selectedCategory || utils.cleanCategoryName(row.nganhHang) === selectedCategory;
            const brandMatch = !selectedBrand || (row.nhaSanXuat || 'H√£ng kh√°c') === selectedBrand;
            const isDoanhThuHTX = dataProcessing.getHinhThucXuatTinhDoanhThu().has(row.hinhThucXuat);
            const isBaseValid = (row.trangThaiThuTien || "").trim() === 'ƒê√£ thu' && (row.trangThaiHuy || "").trim() === 'Ch∆∞a h·ªßy' && (row.tinhTrangTra || "").trim() === 'Ch∆∞a tr·∫£' && (row.trangThaiXuat || "").trim() === 'ƒê√£ xu·∫•t';

            return categoryMatch && brandMatch && isDoanhThuHTX && isBaseValid;
        });

        const byBrand = {};
        const byEmployee = {};

        filteredData.forEach(row => {
            const brand = row.nhaSanXuat || 'H√£ng kh√°c';
            const msnvMatch = String(row.nguoiTao || '').match(/(\d+)/);
            const employeeId = msnvMatch ? msnvMatch[1].trim() : 'Unknown';
            const realRevenue = parseFloat(String(row.thanhTien || "0").replace(/,/g, '')) || 0;
            const quantity = parseInt(String(row.soLuong || "0"), 10) || 0;

            if (!byBrand[brand]) {
                byBrand[brand] = { name: brand, quantity: 0, revenue: 0 };
            }
            byBrand[brand].quantity += quantity;
            byBrand[brand].revenue += realRevenue;

            if (!byEmployee[employeeId]) {
                const employeeInfo = $employeeMaNVMap.get(employeeId);
                byEmployee[employeeId] = { id: employeeId, name: employeeInfo ? employeeInfo.hoTen : `NV ${employeeId}`, quantity: 0, revenue: 0 };
            }
            byEmployee[employeeId].quantity += quantity;
            byEmployee[employeeId].revenue += realRevenue;
        });

        const brandArray = Object.values(byBrand).map(b => ({...b, avgPrice: b.quantity > 0 ? b.revenue / b.quantity : 0})).sort((a,b) => b.revenue - a.revenue);
        const employeeArray = Object.values(byEmployee).sort((a,b) => b.revenue - a.revenue);

        return { byBrand: brandArray, byEmployee: employeeArray };
    },

    generateLuyKeChuaXuatReport(sourceYcxData) {
        if (!sourceYcxData || sourceYcxData.length === 0) return [];

        const hinhThucXuatTinhDoanhThu = dataProcessing.getHinhThucXuatTinhDoanhThu();
        const heSoQuyDoi = dataProcessing.getHeSoQuyDoi();
        const report = {};

        sourceYcxData.forEach(row => {
            const isDoanhThuHTX = hinhThucXuatTinhDoanhThu.has(row.hinhThucXuat);
            const isBaseValid = (row.trangThaiThuTien || "").trim() === 'ƒê√£ thu' &&
                                (row.trangThaiHuy || "").trim() === 'Ch∆∞a h·ªßy' &&
                                (row.tinhTrangTra || "").trim() === 'Ch∆∞a tr·∫£' &&
                                (row.trangThaiXuat || "").trim() === 'Ch∆∞a xu·∫•t';

            if (isBaseValid && isDoanhThuHTX) {
                const thanhTien = parseFloat(String(row.thanhTien || "0").replace(/,/g, '')) || 0;
                const soLuong = parseInt(String(row.soLuong || "0"), 10) || 0;
                if (isNaN(thanhTien) || isNaN(soLuong)) return;

                const nganhHangName = utils.cleanCategoryName(row.nganhHang);
                const heSo = heSoQuyDoi[row.nhomHang] || 1;
                // [FIX] D√πng revenueQuyDoi t·ª´ normalizer
                const revenueQuyDoi = row.revenueQuyDoi !== undefined ? row.revenueQuyDoi : (thanhTien * heSo);

                if (!report[nganhHangName]) {
                    report[nganhHangName] = {
                        nganhHang: nganhHangName,
                        soLuong: 0,
                        doanhThuThuc: 0,
                        doanhThuQuyDoi: 0
                    };
                }

                report[nganhHangName].soLuong += soLuong;
                report[nganhHangName].doanhThuThuc += thanhTien;
                report[nganhHangName].doanhThuQuyDoi += revenueQuyDoi; // [UPDATED]
            }
        });

        return Object.values(report);
    },

    generateRealtimeChuaXuatReport(sourceRealtimeYcxData) {
        if (!sourceRealtimeYcxData || sourceRealtimeYcxData.length === 0) return [];

        const hinhThucXuatTinhDoanhThu = dataProcessing.getHinhThucXuatTinhDoanhThu();
        const heSoQuyDoi = dataProcessing.getHeSoQuyDoi();
        const report = {};

        sourceRealtimeYcxData.forEach(row => {
            const isDoanhThuHTX = hinhThucXuatTinhDoanhThu.has(row.hinhThucXuat);
            const isBaseValid = (row.trangThaiThuTien || "").trim() === 'ƒê√£ thu' &&
                                (row.trangThaiHuy || "").trim() === 'Ch∆∞a h·ªßy' &&
                                (row.tinhTrangTra || "").trim() === 'Ch∆∞a tr·∫£' &&
                                (row.trangThaiXuat || "").trim() === 'Ch∆∞a xu·∫•t';

            if (isBaseValid && isDoanhThuHTX) {
                const thanhTien = parseFloat(String(row.thanhTien || "0").replace(/,/g, '')) || 0;
                const soLuong = parseInt(String(row.soLuong || "0"), 10) || 0;
                if (isNaN(thanhTien) || isNaN(soLuong)) return;

                const nganhHangName = utils.cleanCategoryName(row.nganhHang);
                const heSo = heSoQuyDoi[row.nhomHang] || 1;
                // [FIX] D√πng revenueQuyDoi t·ª´ normalizer
                const revenueQuyDoi = row.revenueQuyDoi !== undefined ? row.revenueQuyDoi : (thanhTien * heSo);

                if (!report[nganhHangName]) {
                    report[nganhHangName] = {
                        nganhHang: nganhHangName,
                        soLuong: 0,
                        doanhThuThuc: 0,
                        doanhThuQuyDoi: 0
                    };
                }

                report[nganhHangName].soLuong += soLuong;
                report[nganhHangName].doanhThuThuc += thanhTien;
                report[nganhHangName].doanhThuQuyDoi += revenueQuyDoi; // [UPDATED]
            }
        });

        return Object.values(report);
    }
};
<<< FILE_END: src/services/reports/general.report.js

>>> FILE_START: src/services/reports/installment.report.js
// src/services/reports/installment.report.js
import { config } from '../../config';

// Helpers
const normalize = (str) => str ? str.toString().trim().toLowerCase() : '';
const formatCurrency = (amount) => amount ? parseInt(amount) : 0;

/**
 * [GENESIS] Ki·ªÉm tra ƒë∆°n h√†ng c√≥ ƒë∆∞·ª£c t√≠nh doanh thu kh√¥ng
 */
const isRevenueOrder = (hinhThucXuat) => {
    if (!hinhThucXuat) return false;
    const type = normalize(hinhThucXuat);
    const revenueTypes = (config.DEFAULT_DATA.HINH_THUC_XUAT_TINH_DOANH_THU || []).map(t => normalize(t));
    return revenueTypes.includes(type);
};

/**
 * [GENESIS] Ki·ªÉm tra Ng√†nh H√†ng cho ph√©p
 */
const isValidSector = (nganhHang) => {
    if (!nganhHang) return false;
    const sectorVal = normalize(nganhHang); 
    const allowedSectors = config.DEFAULT_DATA.NGANH_HANG_TRA_GOP_ALLOW_LIST || [];

    return allowedSectors.some(code => {
        const cleanCode = normalize(code);
        return sectorVal === cleanCode || 
               sectorVal.startsWith(cleanCode + ' ') || 
               sectorVal.startsWith(cleanCode + '-');
    });
};

const isInstallmentOrder = (hinhThucXuat) => {
    if (!hinhThucXuat) return false;
    const type = normalize(hinhThucXuat);
    const installmentTypes = (config.DEFAULT_DATA.HINH_THUC_XUAT_TRA_GOP || []).map(t => normalize(t));
    return installmentTypes.includes(type);
};

const isSuccessInstallment = (order) => {
    if (!isInstallmentOrder(order.hinhThucXuat)) return false;
    const statusHuy = normalize(order.trangThaiHuy);
    const statusThuTien = normalize(order.trangThaiThuTien);
    // ƒêi·ªÅu ki·ªán ƒë·∫≠u: Kh√¥ng h·ªßy V√Ä ƒê√£ thu ti·ªÅn
    return statusHuy !== 'ƒë√£ h·ªßy' && statusThuTien === 'ƒë√£ thu';
};

/**
 * H√†m x·ª≠ l√Ω ch√≠nh
 */
export const processInstallmentReport = (employeesInput) => {
    const kpi = {
        totalOrders: 0,
        totalInstallment: 0,
        totalSuccess: 0,
        approvalRate: 0
    };

    const sourceEmployees = Array.isArray(employeesInput) ? employeesInput : [];

    const processedEmployees = sourceEmployees.map(emp => {
        const newEmp = {
            ...emp,
            stats: {
                ...emp.stats, 
                totalRevenue: 0,              // DT Th·ª±c (ƒê√£ thu ti·ªÅn & Kh√¥ng h·ªßy)
                installmentTotal: 0,
                installmentSuccess: 0,
                installmentFail: 0,
                installmentRevenueRaw: 0,     // DT Tr·∫£ ch·∫≠m g·ªëc
                installmentRevenueWeighted: 0 // DT Tr·∫£ ch·∫≠m (30%)
            }
        };

        const rawOrders = emp.orders || [];
        
        // 1. L·∫•y danh s√°ch ƒë∆°n h·ª£p l·ªá
        const validOrders = rawOrders.filter(o => 
            isRevenueOrder(o.hinhThucXuat) && 
            isValidSector(o.nganhHang)
        );

        validOrders.forEach(order => {
            const amount = formatCurrency(order.thanhTien);
            
            // [GENESIS FIX] X√°c ƒë·ªãnh ƒëi·ªÅu ki·ªán Doanh Thu Th·ª±c
            const isCancelled = normalize(order.trangThaiHuy) === 'ƒë√£ h·ªßy';
            const isCollected = normalize(order.trangThaiThuTien) === 'ƒë√£ thu';

            // ƒêI·ªÄU KI·ªÜN M·ªöI: Ph·∫£i l√† "ƒê√£ thu" v√† Kh√¥ng ph·∫£i "ƒê√£ h·ªßy"
            if (isCollected && !isCancelled) {
                newEmp.stats.totalRevenue += amount;
            }
            
            kpi.totalOrders++;
            
            // X·ª≠ l√Ω KPI Tr·∫£ Ch·∫≠m
            if (isInstallmentOrder(order.hinhThucXuat)) {
                kpi.totalInstallment++;
                newEmp.stats.installmentTotal++;
                
                // Logic ƒë·∫≠u/r·ªõt gi·ªØ nguy√™n (ƒë√£ d√πng logic t∆∞∆°ng t·ª± trong h√†m isSuccessInstallment)
                if (isSuccessInstallment(order)) {
                    kpi.totalSuccess++;
                    newEmp.stats.installmentSuccess++;
                    newEmp.stats.installmentRevenueRaw += amount;
                } else {
                    newEmp.stats.installmentFail++;
                }
            }
        });

        // T√≠nh DT Tr·∫£ ch·∫≠m quy ƒë·ªïi (130%)
        newEmp.stats.installmentRevenueWeighted = newEmp.stats.installmentRevenueRaw * 1.3;

        // T√≠nh t·ª∑ l·ªá duy·ªát
        newEmp.stats.approvalRate = newEmp.stats.installmentTotal > 0
            ? ((newEmp.stats.installmentSuccess / newEmp.stats.installmentTotal) * 100).toFixed(1)
            : 0;

        newEmp.processedCustomers = processCustomerGrouping(validOrders);

        return newEmp;
    });

    kpi.approvalRate = kpi.totalInstallment > 0
        ? ((kpi.totalSuccess / kpi.totalInstallment) * 100).toFixed(1)
        : 0;

    const finalEmployees = processedEmployees
        .filter(e => e.processedCustomers && e.processedCustomers.length > 0) 
        .sort((a, b) => b.stats.installmentTotal - a.stats.installmentTotal);

    return { kpi, employees: finalEmployees };
};

const processCustomerGrouping = (orders) => {
    const customerMap = {};
    orders.forEach(order => {
        const rawName = order.tenKhachHang || 'Kh√°ch l·∫ª';
        const key = normalize(rawName);

        if (!customerMap[key]) {
            customerMap[key] = {
                name: rawName,
                totalOrders: 0, installmentCount: 0, successCount: 0, orders: []
            };
        }
        const cust = customerMap[key];
        const isInst = isInstallmentOrder(order.hinhThucXuat);
        const isSucc = isSuccessInstallment(order);

        cust.totalOrders++; 
        if (isInst) {
            cust.installmentCount++;
            if (isSucc) cust.successCount++;
        }
        cust.orders.push({ ...order, _isInstallment: isInst, _isSuccess: isSucc });
    });

    return Object.values(customerMap).sort((a, b) => {
        if (b.installmentCount !== a.installmentCount) return b.installmentCount - a.installmentCount;
        return b.totalOrders - a.totalOrders;
    });
};
<<< FILE_END: src/services/reports/installment.report.js

>>> FILE_START: src/services/reports/master/aggregator.js
// src/services/reports/master/aggregator.js
import { get } from 'svelte/store';
import { efficiencyConfig, warehouseCustomMetrics } from '../../../stores.js';
import { normalize } from './utils.js';

export const aggregator = {
    aggregateReport(reportData) {
        if (!reportData || reportData.length === 0) return {};

        // T√≠nh t·ªïng h·ª£p cho to√†n si√™u th·ªã
        const supermarketReport = reportData.reduce((acc, curr) => {
            // C·ªông d·ªìn t·∫•t c·∫£ c√°c tr∆∞·ªùng s·ªë
            for (const key in curr) {
                if (typeof curr[key] === 'number') {
                    acc[key] = (acc[key] || 0) + curr[key];
                }
            }
            
            // Merge chi ti·∫øt Ng√†nh h√†ng / Nh√≥m h√†ng
            ['doanhThuTheoNganhHang', 'doanhThuTheoNhomHang'].forEach(dictKey => {
                if(curr[dictKey]) {
                    if(!acc[dictKey]) acc[dictKey] = {};
                    Object.entries(curr[dictKey]).forEach(([k, v]) => {
                        if(!acc[dictKey][k]) acc[dictKey][k] = { ...v };
                        else {
                            acc[dictKey][k].revenue += v.revenue;
                            acc[dictKey][k].quantity += v.quantity;
                            acc[dictKey][k].revenueQuyDoi += v.revenueQuyDoi;
                        }
                    });
                }
            });

            return acc;
        }, { doanhThu: 0, dynamicMetrics: {} });

        supermarketReport.nganhHangChiTiet = supermarketReport.doanhThuTheoNganhHang;
        supermarketReport.nhomHangChiTiet = supermarketReport.doanhThuTheoNhomHang;

        // T√≠nh l·∫°i % T·ªïng h·ª£p Si√™u th·ªã
        const totalRevenue = supermarketReport.doanhThu || 1;
        supermarketReport.pctPhuKien = (supermarketReport.dtPhuKien || 0) / totalRevenue;
        supermarketReport.pctGiaDung = (supermarketReport.dtGiaDung || 0) / totalRevenue;
        supermarketReport.pctMLN = (supermarketReport.dtMLN || 0) / totalRevenue;
        supermarketReport.pctSim = (supermarketReport.dtSim || 0) / totalRevenue;
        supermarketReport.pctVAS = (supermarketReport.dtVAS || 0) / totalRevenue;
        supermarketReport.pctBaoHiem = (supermarketReport.dtBaoHiem || 0) / totalRevenue;
        supermarketReport.hieuQuaQuyDoi = (supermarketReport.doanhThuQuyDoi || 0) / totalRevenue - 1;
        supermarketReport.tyLeTraCham = (supermarketReport.doanhThuTraGop || 0) / totalRevenue;
        supermarketReport.comparisonData = { value: 0, percentage: 'N/A' }; 

        if (supermarketReport.qdc) {
            for (const key in supermarketReport.qdc) {
                const group = supermarketReport.qdc[key];
                group.donGia = group.sl > 0 ? group.dt / group.sl : 0;
            }
        }

        // --- T√≠nh l·∫°i Dynamic Metrics cho c·∫•p Si√™u th·ªã ---
        const $efficiencyConfig = get(efficiencyConfig) || [];
        const $warehouseCustomMetrics = get(warehouseCustomMetrics) || [];
        const allMetricsConfig = [...$efficiencyConfig, ...$warehouseCustomMetrics];

        supermarketReport.dynamicMetrics = {};
        
        if (allMetricsConfig.length > 0) {
            allMetricsConfig.forEach(cfg => {
                try {
                    if (!cfg.id || !cfg.groupA || !cfg.groupB) return;

                    const numType = cfg.typeA || 'DTTL';
                    const denType = cfg.typeB || 'DTTL'; 

                    const calcGroupValue = (groupList, valueType) => {
                        let total = 0;
                        if (!Array.isArray(groupList) || groupList.length === 0) return 0;
                        
                        groupList.forEach(rawName => {
                            if(!rawName) return;
                            const cleanCfgName = normalize(rawName);
                             const scanBucket = (bucket) => {
                                for (const [k, v] of Object.entries(bucket)) {
                                    if (normalize(k).includes(cleanCfgName)) {
                                        if(valueType==='SL') total+=v.quantity;
                                        else if(valueType==='DTQD') total+=v.revenueQuyDoi;
                                        else total+=v.revenue;
                                    }
                                }
                            };
                            scanBucket(supermarketReport.doanhThuTheoNganhHang);
                            scanBucket(supermarketReport.doanhThuTheoNhomHang);
                        });
                        return total;
                    };

                    const numVal = calcGroupValue(cfg.groupA, numType);
                    const denVal = calcGroupValue(cfg.groupB, denType);
                    
                    supermarketReport.dynamicMetrics[cfg.id] = {
                        value: denVal > 0 ? numVal / denVal : 0,
                        target: cfg.target, 
                        label: cfg.label
                    };
                } catch(e) {}
            });
        }

        return supermarketReport;
    }
};
<<< FILE_END: src/services/reports/master/aggregator.js

>>> FILE_START: src/services/reports/master/configLoader.js
import { get } from 'svelte/store';
import { 
    macroCategoryConfig, 
    macroProductGroupConfig 
} from '../../../stores.js';
import { normalize } from './utils.js';
import { parseIdentity } from '../../../utils.js';

export const configLoader = {
    loadUiKeywords() {
        // L·∫•y config t·ª´ Store Svelte
        const $macroProductGroupConfig = get(macroProductGroupConfig) || [];
        const $macroCategoryConfig = get(macroCategoryConfig) || [];

        // Kh·ªüi t·∫°o b·ªô ch·ª©a keywords cho c√°c nh√≥m UI c·ªë ƒë·ªãnh
        const uiKeywords = {
            dtICT: [], dtCE: [], dtPhuKien: [], dtGiaDung: [],
            dtMLN: [], dtSim: [], dtVAS: [], dtBaoHiem: []
        };

        // Mapping ƒë·ªãnh danh: Nh√≥m UI n√†o ·ª©ng v·ªõi t·ª´ kh√≥a c·∫•u h√¨nh n√†o
        // V√≠ d·ª•: N·∫øu admin ƒë·∫∑t t√™n nh√≥m l√† "Nh√≥m Ph·ª• Ki·ªán ƒê·∫∑c Bi·ªát", n√≥ s·∫Ω match v√†o 'dtPhuKien'
        const uiIdentity = {
            dtICT: ['ict', 'ƒëi·ªán tho·∫°i', 'laptop', 'tablet', 'mobile'],
            dtCE: ['ce', 'ƒëi·ªán t·ª≠', 'tivi', 'loa', '√¢m thanh', 'tv'],
            dtPhuKien: ['ph·ª• ki·ªán', 'pk', 'accessories'],
            dtGiaDung: ['gia d·ª•ng', 'gd', 'household'],
            dtMLN: ['m√°y l·ªçc n∆∞·ªõc', 'mln', 'l·ªçc n∆∞·ªõc'],
            dtSim: ['sim', 'th·∫ª c√†o', 'card'],
            dtVAS: ['vas', 'd·ªãch v·ª•'],
            dtBaoHiem: ['b·∫£o hi·ªÉm', 'r∆°i v·ª°', 'insurance']
        };

        const loadKeywords = (configs) => {
            if (!Array.isArray(configs)) return;
            
            configs.forEach(group => {
                const groupName = normalize(group.name);
                
                // Duy·ªát qua c√°c nh√≥m UI ƒë·ªãnh s·∫µn
                for (const [uiKey, identityTags] of Object.entries(uiIdentity)) {
                    // N·∫øu t√™n nh√≥m trong config (VD: "Ph·ª• ki·ªán 2024") ch·ª©a identity (VD: "ph·ª• ki·ªán")
                    if (identityTags.some(tag => groupName.includes(tag))) {
                         
                         // Th√¨ l·∫•y t·∫•t c·∫£ items b√™n trong nh√≥m ƒë√≥ ƒë∆∞a v√†o keywords c·ªßa UI Key t∆∞∆°ng ·ª©ng
                         if (group.items && Array.isArray(group.items)) {
                             group.items.forEach(i => {
                                 // 1. Push t√™n g·ªëc ƒë√£ chu·∫©n h√≥a
                                 uiKeywords[uiKey].push(normalize(i)); 
                                 
                                 // 2. Push ID n·∫øu c√≥ (Quan tr·ªçng: X·ª≠ l√Ω chu·ªói "1394 - C√°p s·∫°c")
                                 const parsed = parseIdentity(i);
                                 if (parsed.id && parsed.id !== 'unknown') {
                                     uiKeywords[uiKey].push(normalize(parsed.id));
                                 }
                             });
                         }
                    }
                }
            });
        };

        // Load t·ª´ c·∫£ 2 ngu·ªìn config
        loadKeywords($macroProductGroupConfig);
        loadKeywords($macroCategoryConfig);

        return uiKeywords;
    }
};
<<< FILE_END: src/services/reports/master/configLoader.js

>>> FILE_START: src/services/reports/master/metricsProcessor.js
// src/services/reports/master/metricsProcessor.js
import { get } from 'svelte/store';
import { efficiencyConfig, warehouseCustomMetrics } from '../../../stores.js';
import { normalize } from './utils.js';

export const metricsProcessor = {
    calculateDynamicMetrics(data, goalSettings) {
        const $efficiencyConfig = get(efficiencyConfig) || [];
        const $warehouseCustomMetrics = get(warehouseCustomMetrics) || [];
        
        // G·ªôp c·∫•u h√¨nh
        const allMetricsConfig = [...$efficiencyConfig, ...$warehouseCustomMetrics];
        
        const dynamicMetrics = {};

        if (allMetricsConfig && Array.isArray(allMetricsConfig)) {
            allMetricsConfig.forEach(cfg => {
                try {
                    if (!cfg.id || !cfg.groupA || !cfg.groupB) return;

                    // [LOGIC FIX] ∆Øu ti√™n l·∫•y percentMetric (t·ª´ Modal m·ªõi) -> typeA -> type -> m·∫∑c ƒë·ªãnh DTTL
                    // ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o khi b·∫°n ch·ªçn "S·ªë l∆∞·ª£ng" ·ªü Modal, code s·∫Ω t√≠nh theo SL
                    const metricType = cfg.percentMetric || cfg.typeA || cfg.type || 'DTTL';
                    
                    const numType = metricType; 
                    const denType = cfg.typeB || metricType; // N·∫øu m·∫´u s·ªë kh√¥ng c·∫•u h√¨nh ri√™ng th√¨ d√πng chung lo·∫°i

                    const modeA = cfg.modeA || 'group';
                    const modeB = cfg.modeB || (cfg.modeA === 'category' ? 'category' : 'group'); 

                    const calcValue = (groupList, type, mode) => {
                        let total = 0;
                        if (!Array.isArray(groupList)) return 0;
                        
                        groupList.forEach(targetId => {
                            if (!targetId) return;
                            const cleanTargetId = normalize(targetId); 

                            // Ch·ªçn th√πng d·ªØ li·ªáu
                            const bucketToScan = (mode === 'category') 
                                ? data.doanhThuTheoNganhHang 
                                : data.doanhThuTheoNhomHang;

                            // Qu√©t d·ªØ li·ªáu
                            for (const [key, val] of Object.entries(bucketToScan)) {
                                const cleanKey = normalize(key);
                                
                                if (cleanKey === cleanTargetId) {
                                    let valueToAdd = 0;
                                    // Logic l·∫•y gi√° tr·ªã ch√≠nh x√°c theo type
                                    if (type === 'SL') valueToAdd = val.quantity || 0;
                                    else if (type === 'DTQD') valueToAdd = val.revenueQuyDoi || 0;
                                    else valueToAdd = val.revenue || 0; // M·∫∑c ƒë·ªãnh l√† DTTL

                                    total += valueToAdd;
                                }
                            }
                        });

                        return total;
                    };

                    // T√≠nh to√°n
                    const num = calcValue(cfg.groupA, numType, modeA);
                    const den = calcValue(cfg.groupB, denType, modeB);

                    dynamicMetrics[cfg.id] = {
                        value: den > 0 ? num / den : 0, // L∆∞u d·∫°ng decimal (0.5) ƒë·ªÉ component UI format sau
                        target: goalSettings && goalSettings[cfg.id] ? parseFloat(goalSettings[cfg.id]) : (cfg.target || 0),
                        label: cfg.label
                    };
                } catch (e) {
                    console.error("Metric Calc Error:", e);
                }
            });
        }
        return dynamicMetrics;
    }
};
<<< FILE_END: src/services/reports/master/metricsProcessor.js

>>> FILE_START: src/services/reports/master/salaryProcessor.js
// src/services/reports/master/salaryProcessor.js
import { get } from 'svelte/store';
import {
    thuongNongData,
    thuongERPData,
    thuongNongDataThangTruoc,
    thuongERPDataThangTruoc,
    employeeNameToMaNVMap
} from '../../../stores.js';
import { dataProcessing } from '../../dataProcessing.js';

export const salaryProcessor = {
    prepareSalaryData() {
        const $thuongNongData = get(thuongNongData) || [];
        const $employeeNameToMaNVMap = get(employeeNameToMaNVMap);
        const $thuongERPData = get(thuongERPData) || [];
        const $thuongNongDataThangTruoc = get(thuongNongDataThangTruoc) || [];
        const $thuongERPDataThangTruoc = get(thuongERPDataThangTruoc) || [];

        const thuongNongByMSNV = {};
        $thuongNongData.forEach(row => {
            const msnv = String(row.maNV || '').trim() || $employeeNameToMaNVMap.get(String(row.hoTen).toLowerCase());
            if(msnv) thuongNongByMSNV[msnv] = (thuongNongByMSNV[msnv]||0) + (parseFloat(String(row.diemThuong||0).replace(/,/g,''))||0);
        });

        const thuongNongThangTruocByMSNV = {};
        $thuongNongDataThangTruoc.forEach(row => {
            const msnv = String(row.maNV || '').trim() || $employeeNameToMaNVMap.get(String(row.hoTen).toLowerCase());
            if(msnv) thuongNongThangTruocByMSNV[msnv] = (thuongNongThangTruocByMSNV[msnv]||0) + (parseFloat(String(row.diemThuong||0).replace(/,/g,''))||0);
        });

        const gioCongByMSNV = dataProcessing.processGioCongData();

        return {
            thuongNongByMSNV,
            thuongNongThangTruocByMSNV,
            gioCongByMSNV,
            $thuongERPData,
            $thuongERPDataThangTruoc
        };
    },

    calculateEmployeeSalary(employee, salaryData) {
        const { 
            thuongNongByMSNV, thuongNongThangTruocByMSNV, gioCongByMSNV, 
            $thuongERPData, $thuongERPDataThangTruoc 
        } = salaryData;

        const gioCong = gioCongByMSNV[employee.maNV] || 0;
        const thuongNong = thuongNongByMSNV[employee.maNV] || 0;
        
        const erpEntry = $thuongERPData.find(e => e.name.includes(employee.hoTen));
        const thuongERP = erpEntry ? parseFloat(erpEntry.bonus.replace(/,/g, '')) : 0;
        const tongThuNhap = thuongNong + thuongERP;

        const today = new Date();
        const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
        let thuNhapDuKien = 0;
        if (today.getDate() > 1) {
            thuNhapDuKien = (tongThuNhap / (today.getDate() - 1)) * daysInMonth;
        } else {
            thuNhapDuKien = tongThuNhap * daysInMonth;
        }

        const thuongNongThangTruoc = thuongNongThangTruocByMSNV[employee.maNV] || 0;
        const erpEntryThangTruoc = $thuongERPDataThangTruoc.find(e => e.name.includes(employee.hoTen));
        const thuongERPThangTruoc = erpEntryThangTruoc ? parseFloat(erpEntryThangTruoc.bonus.replace(/,/g, '')) : 0;
        const thuNhapThangTruoc = (thuongNongThangTruoc || 0) + thuongERPThangTruoc;
        const chenhLechThuNhap = thuNhapDuKien - thuNhapThangTruoc;

        return {
            gioCong, thuongNong, thuongERP, tongThuNhap, 
            thuNhapDuKien, thuNhapThangTruoc, chenhLechThuNhap
        };
    }
};
<<< FILE_END: src/services/reports/master/salaryProcessor.js

>>> FILE_START: src/services/reports/master/salesProcessor.js
import { config } from '../../../config.js';
import * as utils from '../../../utils.js';
import { normalize } from './utils.js';
import { dataProcessing } from '../../dataProcessing.js';
import { parseIdentity } from '../../../utils.js';

// [FIX] H√†m x·ª≠ l√Ω s·ªë an to√†n
const parseMoney = (value) => {
    if (typeof value === 'number') return value;
    if (!value) return 0;
    return parseFloat(String(value).replace(/,/g, '')) || 0;
};

// [HELPER] H√†m chu·∫©n h√≥a chu·ªói
const normalizeStr = (val) => (val || "").trim();

export const salesProcessor = {
    // --- KH·ªûI T·∫†O D·ªÆ LI·ªÜU R·ªñNG ---
    createEmptySalesData() {
        const PG = config.PRODUCT_GROUPS;
        let data = {
            // T·ªïng h·ª£p chung
            doanhThu: 0, 
            doanhThuQuyDoi: 0, 
            doanhThuTraGop: 0,
            doanhThuChuaXuat: 0, 
            doanhThuQuyDoiChuaXuat: 0,
            doanhThuGiaoXa: 0, 
            doanhThuQuyDoiGiaoXa: 0,
            
            // Map chi ti·∫øt
            doanhThuTheoNganhHang: {}, 
            doanhThuTheoNhomHang: {}, 
            
            // Quy ƒë·ªïi chu·∫©n (QDC)
            qdc: {},

            // [HARDCODED METRICS]
            dtICT: 0, dtCE: 0, dtPhuKien: 0, dtGiaDung: 0, 
            dtSim: 0, dtVAS: 0, dtBaoHiem: 0, dtMLN: 0,
            
            // Chi ti·∫øt s·∫£n ph·∫©m
            dtTivi: 0, slTivi: 0, 
            dtTuLanh: 0, slTuLanh: 0,
            dtMayGiat: 0, slMayGiat: 0, 
            dtMayLanh: 0, slMayLanh: 0,
            dtDienThoai: 0, slDienThoai: 0, 
            dtLaptop: 0, slLaptop: 0
        };

        // Init QDC Groups
        for (const key in PG.QDC_GROUPS) {
            data.qdc[key] = { sl: 0, dt: 0, dtqd: 0, name: PG.QDC_GROUPS[key].name };
        }
        return data;
    },

    // --- X·ª¨ L√ù DOANH THU NH√ÇN VI√äN ---
    processEmployeeSales(employee, sourceData, uiKeywords) {
        const data = this.createEmptySalesData();
        const PG = config.PRODUCT_GROUPS;
        
        const hinhThucXuatTinhDoanhThu = dataProcessing.getHinhThucXuatTinhDoanhThu();
        const hinhThucXuatTraGop = dataProcessing.getHinhThucXuatTraGop();
        const heSoQuyDoi = dataProcessing.getHeSoQuyDoi();

        if (sourceData && Array.isArray(sourceData)) {
            sourceData.forEach(row => {
                const msnvMatch = String(row.nguoiTao || '').match(/(\d+)/);
                if (msnvMatch && msnvMatch[1].trim() === employee.maNV) {
                    
                    const hinhThucXuat = row.hinhThucXuat;
                    const trangThaiXuat = normalizeStr(row.trangThaiXuat);
                    
                    // [STRICT] B·∫Øt bu·ªôc ph·∫£i c√≥ HTX trong danh s√°ch
                    const isDoanhThuHTX = hinhThucXuatTinhDoanhThu.has(hinhThucXuat);
                    
                    // --- LOGIC ƒê√É XU·∫§T ---
                    const isDaXuat = !trangThaiXuat || trangThaiXuat === 'ƒê√£ xu·∫•t' || trangThaiXuat === 'ƒê√£ giao';

                    if (isDoanhThuHTX && isDaXuat) {
                        const thanhTien = parseMoney(row.thanhTien);
                        const soLuong = parseInt(String(row.soLuong || "0"), 10) || 0;
                        const heSo = heSoQuyDoi[row.nhomHang] || 1;
                        
                        // [FIX] L·∫•y doanh thu quy ƒë·ªïi ch√≠nh x√°c t·ª´ Normalizer (ƒë√£ t√≠nh tr·∫£ g√≥p)
                        // Fallback v·ªÅ c√°ch t√≠nh c≈© n·∫øu row.revenueQuyDoi ch∆∞a t·ªìn t·∫°i
                        const revenueQuyDoi = row.revenueQuyDoi !== undefined ? row.revenueQuyDoi : (thanhTien * heSo);
                        
                        const nhomIdObj = row.maNhomHang 
                            ? { id: row.maNhomHang, name: parseIdentity(row.nhomHang).name } 
                            : parseIdentity(row.nhomHang);
                        const nganhIdObj = row.maNganhHang 
                            ? { id: row.maNganhHang, name: parseIdentity(row.nganhHang).name } 
                            : parseIdentity(row.nganhHang);

                        // A. Map chi ti·∫øt
                        const trackMetric = (container, idObj, rawString) => {
                            if (!idObj.id || idObj.id === 'unknown') return;
                            const key = String(idObj.id).trim();
                            if (!container[key]) {
                                container[key] = { 
                                    id: key, 
                                    name: idObj.name || rawString, 
                                    revenue: 0, quantity: 0, revenueQuyDoi: 0 
                                };
                            }
                            container[key].revenue += thanhTien;
                            container[key].quantity += soLuong;
                            container[key].revenueQuyDoi += revenueQuyDoi; // [UPDATED]
                        }

                        trackMetric(data.doanhThuTheoNganhHang, nganhIdObj, row.nganhHang);
                        trackMetric(data.doanhThuTheoNhomHang, nhomIdObj, row.nhomHang);

                        data.doanhThu += thanhTien;
                        data.doanhThuQuyDoi += revenueQuyDoi; // [UPDATED]

                        if (hinhThucXuat && hinhThucXuatTraGop.has(hinhThucXuat)) {
                            data.doanhThuTraGop += thanhTien;
                        }

                        // C. Ph√¢n lo·∫°i nh√≥m
                        const nhomHangCode = String(nhomIdObj.id).trim();
                        
                        if (PG.DIEN_THOAI.includes(nhomHangCode) || PG.LAPTOP.includes(nhomHangCode) || (PG.TABLET && PG.TABLET.includes(nhomHangCode))) { data.dtICT += thanhTien; }
                        if (PG.TIVI.includes(nhomHangCode) || PG.TU_LANH.includes(nhomHangCode) || PG.MAY_GIAT.includes(nhomHangCode) || PG.MAY_LANH.includes(nhomHangCode) || (PG.DONG_HO && PG.DONG_HO.includes(nhomHangCode))) { data.dtCE += thanhTien; }
                        if (PG.PHU_KIEN && PG.PHU_KIEN.includes(nhomHangCode)) { data.dtPhuKien += thanhTien; }
                        if (PG.GIA_DUNG && PG.GIA_DUNG.includes(nhomHangCode)) { data.dtGiaDung += thanhTien; }
                        if (PG.MAY_LOC_NUOC && PG.MAY_LOC_NUOC.includes(nhomHangCode)) { data.dtMLN += thanhTien; }
                        if (PG.SIM && PG.SIM.includes(nhomHangCode)) { data.dtSim += thanhTien; }
                        if (PG.VAS && PG.VAS.includes(nhomHangCode)) { data.dtVAS += thanhTien; }
                        if (PG.BAO_HIEM_VAS && PG.BAO_HIEM_VAS.includes(nhomHangCode)) { data.dtBaoHiem += thanhTien; }

                        // Dynamic Keyword Logic
                        const rawNhomHang = normalize(row.nhomHang);
                        const rawNganhHang = normalize(row.nganhHang);
                        const cleanNhomId = normalize(nhomHangCode);
                        const cleanNganhId = normalize(nganhIdObj.id);

                        const checkDynamic = (uiKey, hardcodeList = []) => {
                            const keywords = uiKeywords[uiKey];
                            if (!keywords || keywords.length === 0) return;
                            const isMatch = keywords.some(k => rawNhomHang.includes(k) || rawNganhHang.includes(k) || cleanNhomId === k || cleanNganhId === k);
                            if (isMatch && !hardcodeList.includes(nhomHangCode)) {
                                data[uiKey] += thanhTien;
                            }
                        };
                        
                        checkDynamic('dtICT', [...PG.DIEN_THOAI, ...PG.LAPTOP, ...(PG.TABLET || [])]); 
                        checkDynamic('dtCE', [...PG.TIVI, ...PG.TU_LANH, ...PG.MAY_GIAT, ...PG.MAY_LANH, ...(PG.DONG_HO || [])]); 
                        checkDynamic('dtPhuKien', PG.PHU_KIEN || []);
                        checkDynamic('dtGiaDung', PG.GIA_DUNG || []);
                        checkDynamic('dtMLN', PG.MAY_LOC_NUOC || []); 
                        checkDynamic('dtSim', PG.SIM || []);
                        checkDynamic('dtVAS', PG.VAS || []); 
                        checkDynamic('dtBaoHiem', PG.BAO_HIEM_VAS || []);

                        if (PG.DIEN_THOAI.includes(nhomHangCode)) { data.dtDienThoai += thanhTien; data.slDienThoai += soLuong; }
                        if (PG.LAPTOP.includes(nhomHangCode)) { data.dtLaptop += thanhTien; data.slLaptop += soLuong; }
                        if (PG.TIVI.includes(nhomHangCode)) { data.dtTivi += thanhTien; data.slTivi += soLuong; }
                        if (PG.TU_LANH.includes(nhomHangCode)) { data.dtTuLanh += thanhTien; data.slTuLanh += soLuong; }
                        if (PG.MAY_GIAT.includes(nhomHangCode)) { data.dtMayGiat += thanhTien; data.slMayGiat += soLuong; }
                        if (PG.MAY_LANH.includes(nhomHangCode)) { data.dtMayLanh += thanhTien; data.slMayLanh += soLuong; }

                        for (const key in PG.QDC_GROUPS) {
                            if (PG.QDC_GROUPS[key].codes.includes(nhomHangCode)) {
                                data.qdc[key].sl += soLuong; 
                                data.qdc[key].dt += thanhTien; 
                                data.qdc[key].dtqd += revenueQuyDoi; // [UPDATED]
                            }
                        }
                    } 
                    
                    // --- LOGIC CH∆ØA XU·∫§T ---
                    else if (isDoanhThuHTX && trangThaiXuat === 'Ch∆∞a xu·∫•t') {
                        
                        const valThuTien = normalizeStr(row.trangThaiThuTien);
                        const valHuy = normalizeStr(row.trangThaiHuy);
                        const valTra = normalizeStr(row.tinhTrangTra);

                        const isThuTien = valThuTien === 'ƒê√£ thu';
                        const isChuaHuy = valHuy === 'Ch∆∞a h·ªßy';
                        const isChuaTra = valTra === 'Ch∆∞a tr·∫£';

                        if (isThuTien && isChuaHuy && isChuaTra) {
                            const thanhTien = parseMoney(row.thanhTien);
                            const heSo = heSoQuyDoi[row.nhomHang] || 1;
                            // [FIX] L·∫•y doanh thu quy ƒë·ªïi ch√≠nh x√°c (Ch∆∞a xu·∫•t)
                            const revenueQuyDoi = row.revenueQuyDoi !== undefined ? row.revenueQuyDoi : (thanhTien * heSo);
                            
                            data.doanhThuChuaXuat += thanhTien;
                            data.doanhThuQuyDoiChuaXuat += revenueQuyDoi; // [UPDATED]
                        } 
                    }
                }
            });
        }
        return data;
    },

    // --- T√çNH T·ª∂ L·ªÜ PH·∫¶N TRƒÇM ---
    calculateStaticRatios(data) {
        const totalRevenue = data.doanhThu > 0 ? data.doanhThu : 1;
        return {
            pctPhuKien: data.dtPhuKien / totalRevenue,
            pctGiaDung: data.dtGiaDung / totalRevenue,
            pctMLN: data.dtMLN / totalRevenue,
            pctSim: data.dtSim / totalRevenue,
            pctVAS: data.dtVAS / totalRevenue,
            pctBaoHiem: data.dtBaoHiem / totalRevenue,
            hieuQuaQuyDoi: data.doanhThu > 0 ? (data.doanhThuQuyDoi / data.doanhThu) - 1 : 0,
            tyLeTraCham: data.doanhThu > 0 ? data.doanhThuTraGop / data.doanhThu : 0
        };
    }
};
<<< FILE_END: src/services/reports/master/salesProcessor.js

>>> FILE_START: src/services/reports/master/utils.js
// src/services/reports/master/utils.js
export const normalize = (str) => {
    if (!str) return '';
    return str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim();
};
<<< FILE_END: src/services/reports/master/utils.js

>>> FILE_START: src/services/reports/master.report.js
// src/services/reports/master.report.js
// Version 6.0 - Modularized Architecture
import { get } from 'svelte/store';
import { danhSachNhanVien } from '../../stores.js';

// Import sub-modules
import { configLoader } from './master/configLoader.js';
import { salaryProcessor } from './master/salaryProcessor.js';
import { salesProcessor } from './master/salesProcessor.js';
import { metricsProcessor } from './master/metricsProcessor.js';
import { aggregator } from './master/aggregator.js';

export const masterReportLogic = {
    generateMasterReportData: (sourceData, goalSettings, isRealtime = false) => {
        const $danhSachNhanVien = get(danhSachNhanVien);
        if (!$danhSachNhanVien || $danhSachNhanVien.length === 0) return [];

        // 1. Load Configurations & Keywords
        const uiKeywords = configLoader.loadUiKeywords();

        // 2. Prepare Salary Data
        const salaryData = salaryProcessor.prepareSalaryData();

        // 3. Main Loop: Process each employee
        return $danhSachNhanVien.map((employee) => {
            // A. Calculate Sales (Core Logic)
            const salesData = salesProcessor.processEmployeeSales(employee, sourceData, uiKeywords);
            
            // B. Calculate Dynamic Metrics (Admin + User)
            salesData.dynamicMetrics = metricsProcessor.calculateDynamicMetrics(salesData, goalSettings);
            
            // C. Calculate Static Ratios
            const staticRatios = salesProcessor.calculateStaticRatios(salesData);

            // D. Calculate Salary
            const salaryInfo = salaryProcessor.calculateEmployeeSalary(employee, salaryData);

            // E. Calculate Average Price
            const totalQuantity = Object.values(salesData.doanhThuTheoNganhHang).reduce((sum, c) => sum + c.quantity, 0);
            const donGiaTrungBinh = totalQuantity > 0 ? salesData.doanhThu / totalQuantity : 0;

            // F. Combine Everything
            return { 
                ...employee, 
                ...salesData, 
                ...staticRatios,
                ...salaryInfo,
                donGiaTrungBinh,
                mucTieu: goalSettings 
            };
        });
    },

    aggregateReport: (reportData, selectedWarehouse = null) => {
        return aggregator.aggregateReport(reportData);
    }
};
<<< FILE_END: src/services/reports/master.report.js

>>> FILE_START: src/services/settings.service.js
// src/services/settings.service.js
import { get } from 'svelte/store';
import { 
    luykeGoalSettings, 
    realtimeGoalSettings, 
    interfaceSettings,
    pastedThiDuaReportData
} from '../stores.js';
import { datasyncService } from './datasync.service.js'; // [M·ªöI] Import

// ... (Gi·ªØ nguy√™n c√°c h·∫±ng s·ªë ALL_EFFICIENCY_ITEMS, PASTED_COMPETITION_SETTINGS_KEY) ...
const ALL_EFFICIENCY_ITEMS = [
    { id: 'dtICT', label: 'DT ICT' },
    { id: 'dtPhuKien', label: 'DT Ph·ª• ki·ªán' },
    { id: 'pctPhuKien', label: '% Ph·ª• ki·ªán' },
    { id: 'dtCE', label: 'DT CE' },
    { id: 'dtGiaDung', label: 'DT Gia d·ª•ng' },
    { id: 'pctGiaDung', label: '% Gia d·ª•ng' },
    { id: 'pctMLN',    label: '% M√°y l·ªçc n∆∞·ªõc' }, 
    { id: 'pctSim',    label: '% Sim' },
    { id: 'pctVAS',    label: '% VAS' },
    { id: 'pctBaoHiem', label: '% B·∫£o hi·ªÉm' }
];
const PASTED_COMPETITION_SETTINGS_KEY = 'pastedCompetitionViewSettings';

export const settingsService = {
    // --- INTERFACE SETTINGS ---
    loadInterfaceSettings() {
        try {
            const saved = localStorage.getItem('interfaceSettings');
            if (saved) {
                const parsed = JSON.parse(saved);
                interfaceSettings.set({ ...get(interfaceSettings), ...parsed });
            }
            this.applyInterfaceStyles(get(interfaceSettings));
            const contrast = localStorage.getItem('contrastLevel') || '3';
            this.updateContrast(contrast);
        } catch (e) { console.error(e); }
    },

    updateInterface(newSettings) {
        interfaceSettings.set(newSettings);
        localStorage.setItem('interfaceSettings', JSON.stringify(newSettings));
        this.applyInterfaceStyles(newSettings);
    },

    updateContrast(level) {
        document.documentElement.dataset.contrast = level;
        localStorage.setItem('contrastLevel', level);
        interfaceSettings.update(s => ({ ...s, contrastLevel: level }));
    },

    applyInterfaceStyles(settings) {
        const root = document.documentElement;
        if (!settings) return;
        if (settings.globalFontSize) root.style.fontSize = `${settings.globalFontSize}px`;
        for (let i = 1; i <= 8; i++) {
            const key = `kpiCard${i}Bg`;
            if (settings[key]) root.style.setProperty(`--kpi-card-${i}-bg`, settings[key]);
        }
        if (settings.kpiTitleColor) root.style.setProperty('--kpi-title-color', settings.kpiTitleColor);
        if (settings.kpiMainColor) root.style.setProperty('--kpi-main-color', settings.kpiMainColor);
        if (settings.kpiSubColor) root.style.setProperty('--kpi-sub-color', settings.kpiSubColor);
        if (settings.kpiFontSize) root.style.setProperty('--kpi-main-font-size', `${settings.kpiFontSize}px`);
    },

    // --- GOAL SETTINGS (M·ª§C TI√äU) - C·∫¨P NH·∫¨T ƒê·ªÇ SYNC CLOUD ---
    
    // [M·ªöI] T·∫£i m·ª•c ti√™u t·ª´ Cloud
    async loadGoalsFromCloud(warehouse) {
        if (!warehouse) return;
        const data = await datasyncService.loadGoalSettings(warehouse);
        
        // C·∫≠p nh·∫≠t store L≈©y k·∫ø
        luykeGoalSettings.update(current => ({
            ...current,
            [warehouse]: data.luyke || {}
        }));

        // C·∫≠p nh·∫≠t store Realtime
        realtimeGoalSettings.update(current => ({
            ...current,
            [warehouse]: data.realtime || { goals: {}, timing: {} }
        }));
    },

    saveLuykeGoalForWarehouse(warehouse, goals) {
        luykeGoalSettings.update(current => {
            const updated = { ...current, [warehouse]: goals };
            // V·∫´n l∆∞u local ƒë·ªÉ backup
            localStorage.setItem('luykeGoalSettings', JSON.stringify(updated)); 
            return updated;
        });
        // [M·ªöI] L∆∞u l√™n Cloud
        datasyncService.saveGoalSettings(warehouse, 'luyke', goals);
    },

    getLuykeGoalSettings(selectedWarehouse = null) {
        const $luykeGoalSettings = get(luykeGoalSettings);
        const settings = { goals: {} };
        const goalKeys = ['doanhThuThuc', 'doanhThuQD', 'phanTramQD', 'phanTramTC', 'phanTramGiaDung', 'phanTramMLN', 'phanTramPhuKien', 'phanTramBaoHiem', 'phanTramSim', 'phanTramVAS'];

        if (selectedWarehouse && $luykeGoalSettings[selectedWarehouse]) {
             const source = $luykeGoalSettings[selectedWarehouse];
             // [FIX] Copy ƒë·ªông t·∫•t c·∫£ c√°c key (ƒë·ªÉ h·ªó tr·ª£ Dynamic Metrics t·ª´ Admin)
             Object.assign(settings.goals, source);
        } else if (!selectedWarehouse) {
             // Logic trung b√¨nh (gi·ªØ nguy√™n n·∫øu c·∫ßn, ho·∫∑c ƒë∆°n gi·∫£n h√≥a)
             return settings;
        }
        return settings;
    },

    saveRealtimeGoalForWarehouse(warehouse, settings) {
        realtimeGoalSettings.update(current => {
            const updated = { ...current, [warehouse]: settings };
            localStorage.setItem('realtimeGoalSettings', JSON.stringify(updated));
            return updated;
        });
        // [M·ªöI] L∆∞u l√™n Cloud
        datasyncService.saveGoalSettings(warehouse, 'realtime', settings);
    },

    getRealtimeGoalSettings(selectedWarehouse = null) {
        const $realtimeGoalSettings = get(realtimeGoalSettings);
        if (selectedWarehouse && $realtimeGoalSettings && $realtimeGoalSettings[selectedWarehouse]) {
            return $realtimeGoalSettings[selectedWarehouse];
        }
        return { goals: {}, timing: {} };
    },

    // --- VIEW SETTINGS (GI·ªÆ NGUY√äN) ---
    saveEfficiencyViewSettings(settings) {
        if (!Array.isArray(settings)) return;
        try { localStorage.setItem('efficiencyViewSettings', JSON.stringify(settings)); } catch (e) {}
    },
    loadEfficiencyViewSettings() {
        try {
            const savedSettingsJSON = localStorage.getItem('efficiencyViewSettings');
            if (savedSettingsJSON) {
                const savedItems = JSON.parse(savedSettingsJSON);
                if (Array.isArray(savedItems) && savedItems.length > 0) {
                    const savedIds = new Set(savedItems.map(s => s.id));
                    const newItems = ALL_EFFICIENCY_ITEMS
                        .filter(item => !savedIds.has(item.id))
                        .map(item => ({ ...item, visible: true }));
                    
                    const currentItems = savedItems
                        .filter(item => ALL_EFFICIENCY_ITEMS.some(config => config.id === item.id))
                        .map(item => {
                            const defaultItem = ALL_EFFICIENCY_ITEMS.find(d => d.id === item.id);
                             return defaultItem ? { ...item, label: defaultItem.label } : item;
                        });
                    return [...currentItems, ...newItems];
                }
            }
        } catch (e) {}
        return ALL_EFFICIENCY_ITEMS.map(item => ({ ...item, visible: true }));
    },
    saveQdcViewSettings(settings) {
        if (!Array.isArray(settings)) return;
        try { localStorage.setItem('qdcViewSettings', JSON.stringify(settings)); } catch (e) {}
    },
    saveCategoryViewSettings(settings) {
        if (!Array.isArray(settings)) return;
        try { localStorage.setItem('categoryViewSettings', JSON.stringify(settings)); } catch (e) {}
    },
    loadQdcViewSettings(allItems) {
        try {
            const saved = localStorage.getItem('qdcViewSettings');
            if (saved) return JSON.parse(saved);
        } catch (e) {}
        return allItems;
    },
    loadCategoryViewSettings(allItems) {
        try {
            const saved = localStorage.getItem('categoryViewSettings');
            if (saved) return JSON.parse(saved);
        } catch (e) {}
        return allItems;
    },
    savePastedCompetitionViewSettings(settings) {
        try { localStorage.setItem(PASTED_COMPETITION_SETTINGS_KEY, JSON.stringify(settings)); } catch (e) {}
    },
    loadPastedCompetitionViewSettings() {
        const pastedDataStoreValue = get(pastedThiDuaReportData);
        if (!pastedDataStoreValue || pastedDataStoreValue.length === 0) return [];
        
        const masterColumns = pastedDataStoreValue[0].competitions.map((comp, index) => ({
            id: `comp_${index}`,
            label: comp.tenNganhHang,
            tenGoc: comp.tenGoc,
            loaiSoLieu: comp.loaiSoLieu,
            visible: true
        }));
        const masterMap = new Map(masterColumns.map(item => [item.tenGoc, item]));

        let savedItems = [];
        try {
            savedItems = JSON.parse(localStorage.getItem(PASTED_COMPETITION_SETTINGS_KEY) || '[]');
        } catch (e) { savedItems = []; }

        const savedMap = new Map(savedItems.map(item => [item.tenGoc, item]));
        const finalSettings = [];
        
        savedItems.forEach(savedItem => {
            if (masterMap.has(savedItem.tenGoc)) {
                const masterItem = masterMap.get(savedItem.tenGoc);
                finalSettings.push({ ...savedItem, id: masterItem.id, label: masterItem.label });
            }
        });
        masterColumns.forEach(masterItem => {
            if (!savedMap.has(masterItem.tenGoc)) finalSettings.push(masterItem);
        });
        return finalSettings;
    }
};
<<< FILE_END: src/services/settings.service.js

>>> FILE_START: src/services/sknv.service.js
import { formatters } from '../utils/formatters.js';
import { cleanCategoryName } from '../utils.js';

export const sknvService = {
    calculateDepartmentAverages(departmentName, reportData) {
        const departmentEmployees = reportData.filter(e => e.boPhan === departmentName);
        if (departmentEmployees.length === 0) return {};

        const totals = departmentEmployees.reduce((acc, curr) => {
            Object.keys(curr).forEach(key => {
                if (typeof curr[key] === 'number') acc[key] = (acc[key] || 0) + curr[key];
            });
            if (curr.qdc) {
                if (!acc.qdc) acc.qdc = {};
                for (const k in curr.qdc) {
                    if (!acc.qdc[k]) acc.qdc[k] = { sl: 0, dt: 0, dtqd: 0 };
                    acc.qdc[k].sl += curr.qdc[k].sl;
                    acc.qdc[k].dt += curr.qdc[k].dt;
                    acc.qdc[k].dtqd += curr.qdc[k].dtqd;
                }
            }
            return acc;
        }, {});

        const averages = {};
        for (const key in totals) {
            if (key !== 'qdc') averages[key] = totals[key] / departmentEmployees.length;
            else {
                averages.qdc = {};
                for (const qdcKey in totals.qdc) averages.qdc[qdcKey] = {
                    sl: totals.qdc[qdcKey].sl / departmentEmployees.length,
                    dt: totals.qdc[qdcKey].dt / departmentEmployees.length,
                    dtqd: totals.qdc[qdcKey].dtqd / departmentEmployees.length
                };
            }
        }
        return averages;
    },

    evaluateEmployee(employee, departmentAverages) {
        const counts = {
            doanhthu: { above: 0, total: 7 },
            nangsuat: { above: 0, total: 7 },
            hieuqua: { above: 0, total: 6 },
            dongia: { above: 0, total: 7 }
        };

        const check = (group, value, avg, higherIsBetter = true) => {
            if (!isFinite(value) || avg === undefined || !isFinite(avg)) return;
            if (higherIsBetter ? (value >= avg) : (value <= avg)) 
                counts[group].above++;
        };

        check('doanhthu', employee.doanhThu, departmentAverages.doanhThu);
        check('doanhthu', employee.doanhThuQuyDoi, departmentAverages.doanhThuQuyDoi);
        check('doanhthu', employee.hieuQuaQuyDoi, departmentAverages.hieuQuaQuyDoi);
        check('doanhthu', employee.dtCE, departmentAverages.dtCE);
        check('doanhthu', employee.dtICT, departmentAverages.dtICT);
        check('doanhthu', employee.doanhThuTraGop, departmentAverages.doanhThuTraGop);
        check('doanhthu', employee.tyLeTraCham, departmentAverages.tyLeTraCham);
        
        check('nangsuat', employee.tongThuNhap, departmentAverages.tongThuNhap);
        check('nangsuat', employee.thuNhapDuKien, departmentAverages.thuNhapDuKien);
        check('nangsuat', employee.gioCong, departmentAverages.gioCong);
        const tnTrenGc = employee.gioCong > 0 ? employee.tongThuNhap / employee.gioCong : 0;
        const avgTnTrenGc = departmentAverages.gioCong > 0 ? departmentAverages.tongThuNhap / departmentAverages.gioCong : 0;
        check('nangsuat', tnTrenGc, avgTnTrenGc);
        const dtqdTrenGc = employee.gioCong > 0 ? employee.doanhThuQuyDoi / employee.gioCong : 0;
        const avgDtqdTrenGc = departmentAverages.gioCong > 0 ? departmentAverages.doanhThuQuyDoi / departmentAverages.gioCong : 0;
        check('nangsuat', dtqdTrenGc, avgDtqdTrenGc);
        check('nangsuat', employee.thuongNong, departmentAverages.thuongNong);
        check('nangsuat', employee.thuongERP, departmentAverages.thuongERP);

        check('hieuqua', employee.pctPhuKien, departmentAverages.pctPhuKien);
        check('hieuqua', employee.pctGiaDung, departmentAverages.pctGiaDung);
        check('hieuqua', employee.pctMLN, departmentAverages.pctMLN);
        check('hieuqua', employee.pctSim, departmentAverages.pctSim);
        check('hieuqua', employee.pctVAS, departmentAverages.pctVAS);
        check('hieuqua', employee.pctBaoHiem, departmentAverages.pctBaoHiem);

        check('dongia', employee.donGiaTrungBinh, departmentAverages.donGiaTrungBinh);
        check('dongia', employee.donGiaTivi, departmentAverages.donGiaTivi);
        check('dongia', employee.donGiaTuLanh, departmentAverages.donGiaTuLanh);
        check('dongia', employee.donGiaMayGiat, departmentAverages.donGiaMayGiat);
        check('dongia', employee.donGiaMayLanh, departmentAverages.donGiaMayLanh);
        check('dongia', employee.donGiaDienThoai, departmentAverages.donGiaDienThoai);
        check('dongia', employee.donGiaLaptop, departmentAverages.donGiaLaptop);

        const totalAbove = Object.values(counts).reduce((sum, grp) => sum + grp.above, 0);
        const totalCriteria = Object.values(counts).reduce((sum, grp) => sum + grp.total, 0);

        return { ...employee, summary: counts, totalAbove, totalCriteria };
    },

    processReportData(rawReportData) {
        if (!rawReportData || rawReportData.length === 0) return [];
        return rawReportData.map(emp => {
            const deptAvg = this.calculateDepartmentAverages(emp.boPhan, rawReportData);
            return this.evaluateEmployee(emp, deptAvg);
        });
    },

    getDetailStats(employeeData, departmentAverages, customMetrics = []) {
        if (!employeeData || !departmentAverages) return {};

        const { mucTieu } = employeeData;
        const fmtRev = (val) => formatters.formatRevenue(val);
        const fmtNum = (val) => formatters.formatNumberOrDash(val);
        const fmtPct = (val) => formatters.formatPercentage(val);

        const doanhThu = [
            { id: 'dtThuc', label: 'Doanh thu th·ª±c', value: fmtRev(employeeData.doanhThu), average: fmtRev(departmentAverages.doanhThu), rawValue: employeeData.doanhThu, rawAverage: departmentAverages.doanhThu },
            { id: 'dtQD', label: 'Doanh thu Qƒê', value: fmtRev(employeeData.doanhThuQuyDoi), average: fmtRev(departmentAverages.doanhThuQuyDoi), rawValue: employeeData.doanhThuQuyDoi, rawAverage: departmentAverages.doanhThuQuyDoi },
            { id: 'pctQD', label: '% Quy ƒë·ªïi', value: fmtPct(employeeData.hieuQuaQuyDoi), valueClass: (mucTieu && employeeData.hieuQuaQuyDoi < (mucTieu.phanTramQD / 100)) ? 'text-red-600 bg-red-50' : '', average: fmtPct(departmentAverages.hieuQuaQuyDoi), rawValue: employeeData.hieuQuaQuyDoi, rawAverage: departmentAverages.hieuQuaQuyDoi },
            { id: 'dtCE', label: 'DT CE', value: fmtRev(employeeData.dtCE), average: fmtRev(departmentAverages.dtCE), rawValue: employeeData.dtCE, rawAverage: departmentAverages.dtCE },
            { id: 'dtICT', label: 'DT ICT', value: fmtRev(employeeData.dtICT), average: fmtRev(departmentAverages.dtICT), rawValue: employeeData.dtICT, rawAverage: departmentAverages.dtICT },
            { id: 'dtTraCham', label: 'DT Tr·∫£ ch·∫≠m', value: fmtRev(employeeData.doanhThuTraGop), average: fmtRev(departmentAverages.doanhThuTraGop), rawValue: employeeData.doanhThuTraGop, rawAverage: departmentAverages.doanhThuTraGop },
            { id: 'pctTraCham', label: '% Tr·∫£ ch·∫≠m', value: fmtPct(employeeData.tyLeTraCham), valueClass: (mucTieu && employeeData.tyLeTraCham < (mucTieu.phanTramTC / 100)) ? 'text-red-600 bg-red-50' : '', average: fmtPct(departmentAverages.tyLeTraCham), rawValue: employeeData.tyLeTraCham, rawAverage: departmentAverages.tyLeTraCham }
        ];

        const nangSuat = [
            { id: 'thuongNong', label: 'Th∆∞·ªüng n√≥ng', value: fmtRev(employeeData.thuongNong), average: fmtRev(departmentAverages.thuongNong), rawValue: employeeData.thuongNong, rawAverage: departmentAverages.thuongNong },
            { id: 'thuongERP', label: 'Th∆∞·ªüng ERP', value: fmtRev(employeeData.thuongERP), average: fmtRev(departmentAverages.thuongERP), rawValue: employeeData.thuongERP, rawAverage: departmentAverages.thuongERP },
            { id: 'thuNhapLK', label: 'Thu nh·∫≠p LK', value: fmtRev(employeeData.tongThuNhap), average: fmtRev(departmentAverages.tongThuNhap), rawValue: employeeData.tongThuNhap, rawAverage: departmentAverages.tongThuNhap },
            { id: 'thuNhapDK', label: 'Thu nh·∫≠p DK', value: fmtRev(employeeData.thuNhapDuKien), average: fmtRev(departmentAverages.thuNhapDuKien), rawValue: employeeData.thuNhapDuKien, rawAverage: departmentAverages.thuNhapDuKien },
            { id: 'gioCong', label: 'Gi·ªù c√¥ng', value: fmtNum(employeeData.gioCong), average: fmtNum(departmentAverages.gioCong), rawValue: employeeData.gioCong, rawAverage: departmentAverages.gioCong },
            { id: 'tnTrenGc', label: 'TN/Gi·ªù c√¥ng', value: fmtNum(employeeData.gioCong > 0 ? employeeData.tongThuNhap / employeeData.gioCong : 0), average: fmtNum((departmentAverages.gioCong || 0) > 0 ? (departmentAverages.tongThuNhap || 0) / departmentAverages.gioCong : 0), rawValue: employeeData.gioCong > 0 ? employeeData.tongThuNhap / employeeData.gioCong : 0, rawAverage: (departmentAverages.gioCong || 0) > 0 ? (departmentAverages.tongThuNhap || 0) / departmentAverages.gioCong : 0 },
            { id: 'dtqdTrenGc', label: 'DTQƒê/Gi·ªù c√¥ng', value: fmtRev(employeeData.gioCong > 0 ? employeeData.doanhThuQuyDoi / employeeData.gioCong : 0), average: fmtRev((departmentAverages.gioCong || 0) > 0 ? (departmentAverages.doanhThuQuyDoi || 0) / departmentAverages.gioCong : 0), rawValue: employeeData.gioCong > 0 ? employeeData.doanhThuQuyDoi / employeeData.gioCong : 0, rawAverage: (departmentAverages.gioCong || 0) > 0 ? (departmentAverages.doanhThuQuyDoi || 0) / departmentAverages.gioCong : 0 }
        ];

        const hieuQua = [
            { id: 'pctPhuKien', label: '% PK', value: fmtPct(employeeData.pctPhuKien), valueClass: (mucTieu && employeeData.pctPhuKien < (mucTieu.phanTramPhuKien / 100)) ? 'text-red-600 bg-red-50' : '', average: fmtPct(departmentAverages.pctPhuKien), rawValue: employeeData.pctPhuKien, rawAverage: departmentAverages.pctPhuKien },
            { id: 'pctGiaDung', label: '% Gia d·ª•ng', value: fmtPct(employeeData.pctGiaDung), valueClass: (mucTieu && employeeData.pctGiaDung < (mucTieu.phanTramGiaDung / 100)) ? 'text-red-600 bg-red-50' : '', average: fmtPct(departmentAverages.pctGiaDung), rawValue: employeeData.pctGiaDung, rawAverage: departmentAverages.pctGiaDung },
            { id: 'pctMLN', label: '% MLN', value: fmtPct(employeeData.pctMLN), valueClass: (mucTieu && employeeData.pctMLN < (mucTieu.phanTramMLN / 100)) ? 'text-red-600 bg-red-50' : '', average: fmtPct(departmentAverages.pctMLN), rawValue: employeeData.pctMLN, rawAverage: departmentAverages.pctMLN },
            { id: 'pctSim', label: '% Sim', value: fmtPct(employeeData.pctSim), valueClass: (mucTieu && employeeData.pctSim < (mucTieu.phanTramSim / 100)) ? 'text-red-600 bg-red-50' : '', average: fmtPct(departmentAverages.pctSim), rawValue: employeeData.pctSim, rawAverage: departmentAverages.pctSim },
            { id: 'pctVAS', label: '% VAS', value: fmtPct(employeeData.pctVAS), valueClass: (mucTieu && employeeData.pctVAS < (mucTieu.phanTramVAS / 100)) ? 'text-red-600 bg-red-50' : '', average: fmtPct(departmentAverages.pctVAS), rawValue: employeeData.pctVAS, rawAverage: departmentAverages.pctVAS },
            { id: 'pctBaoHiem', label: '% B·∫£o hi·ªÉm', value: fmtPct(employeeData.pctBaoHiem), valueClass: (mucTieu && employeeData.pctBaoHiem < (mucTieu.phanTramBaoHiem / 100)) ? 'text-red-600 bg-red-50' : '', average: fmtPct(departmentAverages.pctBaoHiem), rawValue: employeeData.pctBaoHiem, rawAverage: departmentAverages.pctBaoHiem },
        ];

        const donGia = [
            { id: 'dgTB', label: 'ƒê∆°n gi√° TB', value: fmtRev(employeeData.donGiaTrungBinh), average: fmtRev(departmentAverages.donGiaTrungBinh), rawValue: employeeData.donGiaTrungBinh, rawAverage: departmentAverages.donGiaTrungBinh },
            { id: 'dgTivi', label: 'ƒê∆°n gi√° Tivi', value: fmtRev(employeeData.donGiaTivi), average: fmtRev(departmentAverages.donGiaTivi), rawValue: employeeData.donGiaTivi, rawAverage: departmentAverages.donGiaTivi },
            { id: 'dgTuLanh', label: 'ƒê∆°n gi√° T·ªß l·∫°nh', value: fmtRev(employeeData.donGiaTuLanh), average: fmtRev(departmentAverages.donGiaTuLanh), rawValue: employeeData.donGiaTuLanh, rawAverage: departmentAverages.donGiaTuLanh },
            { id: 'dgMayGiat', label: 'ƒê∆°n gi√° M√°y gi·∫∑t', value: fmtRev(employeeData.donGiaMayGiat), average: fmtRev(departmentAverages.donGiaMayGiat), rawValue: employeeData.donGiaMayGiat, rawAverage: departmentAverages.donGiaMayGiat },
            { id: 'dgMayLanh', label: 'ƒê∆°n gi√° M√°y l·∫°nh', value: fmtRev(employeeData.donGiaMayLanh), average: fmtRev(departmentAverages.donGiaMayLanh), rawValue: employeeData.donGiaMayLanh, rawAverage: departmentAverages.donGiaMayLanh },
            { id: 'dgDienThoai', label: 'ƒê∆°n gi√° ƒêi·ªán tho·∫°i', value: fmtRev(employeeData.donGiaDienThoai), average: fmtRev(departmentAverages.donGiaDienThoai), rawValue: employeeData.donGiaDienThoai, rawAverage: departmentAverages.donGiaDienThoai },
            { id: 'dgLaptop', label: 'ƒê∆°n gi√° Laptop', value: fmtRev(employeeData.donGiaLaptop), average: fmtRev(departmentAverages.donGiaLaptop), rawValue: employeeData.donGiaLaptop, rawAverage: departmentAverages.donGiaLaptop },
        ];

        if (customMetrics && customMetrics.length > 0) {
            customMetrics.forEach(metric => {
                const empVal = this.calculateDynamicMetricValue(employeeData, metric);
                const avgVal = departmentAverages[`custom_${metric.id}`] || 0; 

                const newItem = {
                    id: metric.id,
                    label: metric.label,
                    rawValue: empVal,
                    rawAverage: avgVal,
                    isCustom: true,
                    rawConfig: metric // [M·ªöI] L∆∞u config g·ªëc ƒë·ªÉ c√≥ th·ªÉ s·ª≠a/x√≥a
                };

                if (metric.type === 'UNIT_PRICE') {
                    newItem.value = fmtRev(empVal);
                    newItem.average = fmtRev(avgVal);
                    donGia.push(newItem);
                } else {
                    newItem.value = fmtPct(empVal);
                    newItem.average = fmtPct(avgVal);
                    newItem.valueClass = (metric.target && empVal < (metric.target / 100)) ? 'text-red-600 bg-red-50' : '';
                    hieuQua.push(newItem);
                }
            });
        }

        return { doanhThu, nangSuat, hieuQua, donGia };
    },

    calculateDynamicMetricValue(data, metricConfig) {
        const sumValues = (listNames, metricType) => {
            let total = 0;
            if(!listNames || listNames.length === 0) return 0;

            listNames.forEach(name => {
                const cleanName = cleanCategoryName(name);
                let item = data.doanhThuTheoNganhHang?.[cleanName];
                if (!item && data.doanhThuTheoNhomHang) {
                    item = data.doanhThuTheoNhomHang[cleanName];
                }

                if (item) {
                    if (metricType === 'SL') total += item.quantity;
                    else if (metricType === 'DTQD') total += item.revenueQuyDoi;
                    else total += item.revenue; 
                }
            });
            return total;
        };

        const numVal = sumValues(metricConfig.groupA, metricConfig.typeA);
        const denVal = sumValues(metricConfig.groupB, metricConfig.typeB);

        return denVal > 0 ? numVal / denVal : 0;
    }
};
<<< FILE_END: src/services/sknv.service.js

>>> FILE_START: src/services/storage.service.js
// src/services/storage.service.js
// Version 3.1 - Fixed: Export both 'storage' (IndexedDB) and 'storageService' (Firebase)
// MODULE: STORAGE SERVICE
import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "firebase/storage";
import { get } from 'svelte/store';
import { firebaseStore, notificationStore } from '../stores.js';

// --- PH·∫¶N 1: FIREBASE STORAGE (M·ªõi) ---

const getStorageInstance = () => {
    const fb = get(firebaseStore);
    if (!fb || !fb.storage) {
        try { return getStorage(); } catch (e) { return null; }
    }
    return fb.storage;
};

const showNotification = (message, type = 'info') => {
    notificationStore.set({ message, type, visible: true });
    setTimeout(() => notificationStore.update(s => ({ ...s, visible: false })), 3000);
};

export const storageService = {
    async getTemplateDownloadURL() {
        const storage = getStorageInstance();
        if (!storage) throw new Error("Firebase Storage ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.");
        const filePath = 'templates/danh_sach_nhan_vien_mau.xlsx';
        const storageRef = ref(storage, filePath);
        return await getDownloadURL(storageRef);
    },

    async getBookmarkDownloadURL() {
        const storage = getStorageInstance();
        if (!storage) throw new Error("Firebase Storage ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.");
        const filePath = 'templates/Share_QLST.zip';
        const storageRef = ref(storage, filePath);
        return await getDownloadURL(storageRef);
    },

    async getQrCodeDownloadURL() {
        const storage = getStorageInstance();
        if (!storage) throw new Error("Firebase Storage ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.");
        const filePath = 'qrcodes/main-qr.jpg';
        const storageRef = ref(storage, filePath);
        return await getDownloadURL(storageRef);
    },

    async uploadFileToStorage(file, storagePath, onProgress) {
        const storage = getStorageInstance();
        if (!storage) throw new Error("Firebase Storage ch∆∞a kh·ªüi t·∫°o.");
        
        const storageRef = ref(storage, storagePath);
        const uploadTask = uploadBytesResumable(storageRef, file);

        return new Promise((resolve, reject) => {
            uploadTask.on('state_changed',
                (snapshot) => {
                    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                    console.log(`Upload ${storagePath}: ${Math.round(progress)}%`);
                    if (onProgress) onProgress(progress);
                },
                (error) => {
                    console.error(`Upload l·ªói:`, error);
                    showNotification(`L·ªói upload: ${error.code}`, 'error');
                    reject(error);
                },
                async () => {
                    try {
                        const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                        console.log('File available at', downloadURL);
                        resolve(downloadURL);
                    } catch (err) {
                        reject(err);
                    }
                }
            );
        });
    },
};

// --- PH·∫¶N 2: INDEXEDDB (C≈© - Kh√¥i ph·ª•c l·∫°i) ---

export const storage = {
    db: null,
    dbName: 'AppStorageDB',
    storeName: 'fileStore',

    openDB() {
        // console.log("[IndexedDB] Opening...");
        return new Promise((resolve, reject) => {
            if (this.db) return resolve(this.db);
            const request = indexedDB.open(this.dbName, 1);
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName, { keyPath: 'id' });
                }
            };
            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve(this.db);
            };
            request.onerror = (event) => reject(event.target.error);
        });
    },

    async setItem(id, value) {
        try {
            const db = await this.openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([this.storeName], 'readwrite');
                const store = transaction.objectStore(this.storeName);
                const request = store.put({ id, value });
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e.target.error);
            });
        } catch (error) {
            console.error(`[IndexedDB] Error saving ${id}:`, error);
            throw error;
        }
    },

    async getItem(id) {
        try {
            const db = await this.openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([this.storeName], 'readonly');
                const store = transaction.objectStore(this.storeName);
                const request = store.get(id);
                request.onsuccess = (e) => resolve(e.target.result ? e.target.result.value : null);
                request.onerror = (e) => reject(e.target.error);
            });
        } catch (error) {
            console.error(`[IndexedDB] Error getting ${id}:`, error);
            throw error;
        }
    }
};
<<< FILE_END: src/services/storage.service.js

>>> FILE_START: src/utils/capture.utils.js
// Version 2.0 - Restore Logic from Legacy Project (Fix Blank Image)
import { get } from 'svelte/store';
import { charts } from '../stores.js'; // Store ch·ª©a instance bi·ªÉu ƒë·ªì

/**
 * Ch√®n CSS styles ƒë·ªông ƒë·ªÉ ƒë·ªãnh d·∫°ng ·∫£nh ch·ª•p (Gi·ªëng h·ªát file g·ªëc)
 */
export const injectCaptureStyles = () => {
    const styleId = 'dynamic-capture-styles';
    document.getElementById(styleId)?.remove();

    const styles = `
        .capture-container { 
            padding: 24px; 
            background-color: #f3f4f6; 
            box-sizing: border-box; 
            width: fit-content; 
            position: absolute;
            /* QUAN TR·ªåNG: D√πng left -9999px thay v√¨ opacity/display none ƒë·ªÉ ƒë·∫£m b·∫£o render */
            left: -9999px;
            top: 0;
            z-index: -1;
        }
        .capture-layout-container { 
            display: flex; 
            flex-direction: column; 
            gap: 24px; 
        }
        .capture-title { 
            font-size: 28px; 
            font-weight: 700; 
            text-align: center; 
            color: #1f2937; 
            margin-bottom: 24px; 
            padding: 12px; 
            background-color: #ffffff; 
            border-radius: 0.75rem; 
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1); 
        }
        /* --- VIRTUAL STAGES / PRESETS --- */
        .prepare-for-kpi-capture {
            display: grid !important;
            grid-template-columns: repeat(2, 1fr) !important;
            gap: 24px !important;
            width: 900px !important;
        }
        .preset-mobile-portrait {
            width: 550px !important; 
        }
        .preset-landscape-table {
            width: fit-content !important;
        }
        .preset-landscape-table table {
            table-layout: fixed !important;
        }
        .preset-landscape-table th, 
        .preset-landscape-table td {
            width: 95px !important;
            word-wrap: break-word;
        }
        .preset-landscape-table th:first-child,
        .preset-landscape-table td:first-child {
            width: 180px !important;
        }
        .preset-large-font-report {
            width: 800px !important;
        }
        .preset-large-font-report table th {
            white-space: normal !important;
            vertical-align: middle;
        }
        .preset-large-font-report table td {
            font-size: 22px !important;
            vertical-align: middle;
        }
        .preset-infographic-wide {
            width: 1100px !important;
        }
    `;

    const styleElement = document.createElement('style');
    styleElement.id = styleId;
    styleElement.innerHTML = styles;
    document.head.appendChild(styleElement);
    return styleElement;
};

/**
 * T√¨m v√† thay th·∫ø t·∫•t c·∫£ <canvas> c·ªßa Chart.js b·∫±ng <img> tƒ©nh.
 * Logic n√†y kh·∫Øc ph·ª•c l·ªói ·∫£nh tr·∫Øng ·ªü bi·ªÉu ƒë·ªì.
 * @param {HTMLElement} element - V√πng DOM (clone) s·∫Øp ƒë∆∞·ª£c ch·ª•p.
 */
export const swapCanvasToImage = (element) => {
    console.log("[CaptureUtils] B·∫Øt ƒë·∫ßu chuy·ªÉn ƒë·ªïi Canvas sang ·∫¢nh...");
    const canvasElements = element.querySelectorAll('canvas');
    let replacedCount = 0;
    
    // L·∫•y danh s√°ch chart instance t·ª´ store Svelte
    const $charts = get(charts);

    canvasElements.forEach(canvas => {
        const chartId = canvas.id;
        
        // C√°ch 1: Th·ª≠ l·∫•y t·ª´ Store (n·∫øu Chart Component ƒë√£ ƒëƒÉng k√Ω)
        if (chartId && $charts[chartId]) {
            try {
                const chart = $charts[chartId];
                const base64Image = chart.toBase64Image(); // L·∫•y ·∫£nh tƒ©nh t·ª´ Chart.js
                
                if (base64Image) {
                    replaceCanvasWithImg(canvas, base64Image);
                    replacedCount++;
                    return;
                }
            } catch (e) {
                console.error(`[CaptureUtils] L·ªói khi l·∫•y ·∫£nh t·ª´ chart '${chartId}':`, e);
            }
        }

        // C√°ch 2: Fallback - Th·ª≠ l·∫•y tr·ª±c ti·∫øp t·ª´ canvas element (n·∫øu kh√¥ng c√≥ trong store)
        // C√°ch n√†y ho·∫°t ƒë·ªông n·∫øu canvas g·ªëc ƒë√£ ƒë∆∞·ª£c render xong
        try {
            // T√¨m canvas g·ªëc trong DOM th·∫≠t (kh√¥ng ph·∫£i b·∫£n clone)
            const originalCanvas = document.getElementById(chartId);
            if (originalCanvas) {
                const base64Image = originalCanvas.toDataURL('image/png');
                if (base64Image && base64Image !== 'data:,') {
                    replaceCanvasWithImg(canvas, base64Image);
                    replacedCount++;
                }
            }
        } catch (e) {
            console.warn(`[CaptureUtils] Kh√¥ng th·ªÉ fallback toDataURL cho ${chartId}`);
        }
    });
    console.log(`[CaptureUtils] ƒê√£ ho√°n ƒë·ªïi th√†nh c√¥ng ${replacedCount} bi·ªÉu ƒë·ªì.`);
};

// Helper thay th·∫ø node
function replaceCanvasWithImg(canvasNode, src) {
    const img = document.createElement('img');
    img.src = src;
    // Gi·ªØ nguy√™n k√≠ch th∆∞·ªõc ƒë·ªÉ tr√°nh v·ª° layout
    img.style.width = canvasNode.style.width || `${canvasNode.width}px`;
    img.style.height = canvasNode.style.height || `${canvasNode.height}px`;
    img.style.display = 'block';
    
    // Copy c√°c class c≈© sang
    img.className = canvasNode.className;
    
    // Thay th·∫ø canvas b·∫±ng img
    if (canvasNode.parentNode) {
        canvasNode.parentNode.replaceChild(img, canvasNode);
    }
}
<<< FILE_END: src/utils/capture.utils.js

>>> FILE_START: src/utils/formatters.js
// src/utils/formatters.js
// Version 4.0 - Format 0 as "-"
export const formatters = {
    /**
     * ƒê·ªãnh d·∫°ng s·ªë l∆∞·ª£ng. 0 -> "-"
     */
    formatNumber: (value, decimals = 0) => {
        if (!isFinite(value) || value === null || value === 0) return '-';
        return new Intl.NumberFormat('vi-VN', { minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(value);
    },

    /**
     * ƒê·ªãnh d·∫°ng doanh thu (chia cho 1 tri·ªáu). 0 -> "-"
     */
    formatRevenue(value, decimals = 1) {
         if (!isFinite(value) || value === null) return '-';
         
         // N·∫øu gi√° tr·ªã qu√° nh·ªè (g·∫ßn b·∫±ng 0) -> tr·∫£ v·ªÅ "-"
         if (Math.abs(value) < 1000) return '-'; 

         const millions = value / 1000000;
         return new Intl.NumberFormat('vi-VN', {
             minimumFractionDigits: 0,
             maximumFractionDigits: decimals
         }).format(millions);
     },

     /**
      * ƒê·ªãnh d·∫°ng s·ªë th∆∞·ªùng (gi·ªØ nguy√™n logic c≈© cho c√°c tr∆∞·ªùng h·ª£p kh√°c)
      */
     formatNumberOrDash: (value, decimals = 1) => {
          if (!isFinite(value) || value === null || Math.abs(value) < 0.01) return '-';
          return new Intl.NumberFormat('vi-VN', {
              minimumFractionDigits: 0,
              maximumFractionDigits: decimals
          }).format(value);
      },

      /**
       * ƒê·ªãnh d·∫°ng ph·∫ßn trƒÉm. 0 -> "-"
       */
     formatPercentage: (value, decimals = 0) => {
          if (!isFinite(value) || value === null) return '-';
          
          // Ki·ªÉm tra s·ªë 0 tuy·ªát ƒë·ªëi ho·∫∑c r·∫•t nh·ªè
          if (Math.abs(value) < 0.0001) return '-';

          const percentageValue = value * 100;
          return new Intl.NumberFormat('vi-VN', {
             minimumFractionDigits: decimals,
             maximumFractionDigits: decimals
          }).format(percentageValue) + '%';
      },

    getShortEmployeeName(hoTen, maNV) {
        if (!hoTen) return maNV || '';
        const nameParts = hoTen.split(' ').filter(p => p);
        let displayName = hoTen;
        if (nameParts.length > 2) {
            displayName = nameParts.slice(-2).join(' ');
        }
        return `${displayName} - ${maNV}`;
    },
};
<<< FILE_END: src/utils/formatters.js

>>> FILE_START: src/utils/kpi.utils.js
// File: src/utils/kpi.utils.js

/**
 * H√†m thu·∫ßn t√∫y: T√≠nh m√†u s·∫Øc d·ª±a tr√™n % ho√†n th√†nh
 * @param {number} actual - S·ªë th·ª±c ƒë·∫°t
 * @param {number} target - M·ª•c ti√™u
 * @returns {string} - Class Tailwind t∆∞∆°ng ·ª©ng
 */
export const getCompletionColor = (actual, target) => {
    // 1. B·∫£o v·ªá: N·∫øu kh√¥ng c√≥ m·ª•c ti√™u, ho·∫∑c m·ª•c ti√™u = 0 -> Kh√¥ng t√¥ m√†u
    if (!target || target === 0) return '';

    // 2. T√≠nh to√°n % ho√†n th√†nh
    const percent = (actual / target) * 100;

    // 3. Logic M·ªõi (Theo y√™u c·∫ßu):
    // - D∆∞·ªõi m·ª•c ti√™u (< 100%) -> T√¥ ƒê·ªè
    // - ƒê·∫°t tr·ªü l√™n (>= 100%) -> Kh√¥ng t√¥ m√†u
    if (percent < 100) {
        return 'bg-red-50 text-red-600 font-bold'; 
    }
    
    // ƒê·∫°t m·ª•c ti√™u tr·ªü l√™n -> Tr·∫£ v·ªÅ r·ªóng (gi·ªØ nguy√™n m√†u ch·ªØ m·∫∑c ƒë·ªãnh c·ªßa b·∫£ng)
    return '';
};

/**
 * H√†m ƒë·ªãnh d·∫°ng ti·ªÅn t·ªá VNƒê (Ti·ªán √≠ch ƒëi k√®m th∆∞·ªùng d√πng)
 */
export const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(amount);
};
<<< FILE_END: src/utils/kpi.utils.js

>>> FILE_START: src/styles/base.css
/* Version 1.0 - Base styles (Refactored from v6.19) */
/* Ch·ª©a c√°c thi·∫øt l·∫≠p n·ªÅn t·∫£ng: fonts, :root variables, body, scrollbar */

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
    --global-font-size: 18px;
    --kpi-main-font-size: 36px;
    --bg-lightness-1: 98%; --header-lightness-1: 96%; --header-text-lightness-1: 25%; --special-header-lightness-1: 92%; --below-target-lightness-1: 96%;
    --bg-lightness-2: 96%; --header-lightness-2: 94%; --header-text-lightness-2: 22%; --special-header-lightness-2: 88%; --below-target-lightness-2: 94%;
    --bg-lightness-3: 94%; --header-lightness-3: 92%; --header-text-lightness-3: 18%; --special-header-lightness-3: 85%; --below-target-lightness-3: 92%; /* Normal */
    --bg-lightness-4: 92%; --header-lightness-4: 88%; --header-text-lightness-4: 15%; --special-header-lightness-4: 80%; --below-target-lightness-4: 88%;
    --bg-lightness-5: 90%; --header-lightness-5: 84%; --header-text-lightness-5: 12%; --special-header-lightness-5: 75%; --below-target-lightness-5: 84%;
    --bg-lightness-6: 88%; --header-lightness-6: 80%; --header-text-lightness-6: 10%; --special-header-lightness-6: 70%; --below-target-lightness-6: 80%;
    --kpi-card-1-bg: #38bdf8;
    --kpi-card-2-bg: #34d399; --kpi-card-3-bg: #fbbf24;
    --kpi-card-4-bg: #2dd4bf;
    --kpi-card-5-bg: #a78bfa; --kpi-card-6-bg: #f472b6;
    --kpi-card-7-bg: #818cf8;
    --kpi-card-8-bg: #f87171;
    --kpi-title-color: #ffffff;
    --kpi-main-color: #ffffff;
    --kpi-sub-color: #ffffff;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: #f3f4f6;
    font-size: var(--global-font-size);
}

html[data-contrast="1"] { --bg-lightness: var(--bg-lightness-1); --header-lightness: var(--header-lightness-1); --header-text-lightness: var(--header-text-lightness-1); --special-header-lightness: var(--special-header-lightness-1); --below-target-lightness: var(--below-target-lightness-1); }
html[data-contrast="2"] { --bg-lightness: var(--bg-lightness-2); --header-lightness: var(--header-lightness-2); --header-text-lightness: var(--header-text-lightness-2); --special-header-lightness: var(--special-header-lightness-2); --below-target-lightness: var(--below-target-lightness-2); }
html[data-contrast="3"] { --bg-lightness: var(--bg-lightness-3); --header-lightness: var(--header-lightness-3); --header-text-lightness: var(--header-text-lightness-3);
--below-target-lightness: var(--below-target-lightness-3); }
html[data-contrast="4"] { --bg-lightness: var(--bg-lightness-4); --header-lightness: var(--header-lightness-4); --header-text-lightness: var(--header-text-lightness-4); --special-header-lightness: var(--special-header-lightness-4); --below-target-lightness: var(--below-target-lightness-4); }
html[data-contrast="5"] { --bg-lightness: var(--bg-lightness-5); --header-lightness: var(--header-lightness-5); --header-text-lightness: var(--header-text-lightness-5); --special-header-lightness: var(--special-header-lightness-5); --below-target-lightness: var(--below-target-lightness-5); }
html[data-contrast="6"] { --bg-lightness: var(--bg-lightness-6); --header-lightness: var(--header-lightness-6); --header-text-lightness: var(--header-text-lightness-6); --special-header-lightness: var(--special-header-lightness-6); --below-target-lightness: var(--below-target-lightness-6); }


::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: #f1f1f1; }
::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
::-webkit-scrollbar-thumb:hover { background: #555; }

.feather {
    width: 1.1rem;
    height: 1.1rem;
    stroke-width: 1.5;
    flex-shrink: 0;
}
<<< FILE_END: src/styles/base.css

>>> FILE_START: src/styles/components.css
/* Version 3.1 - FIX LAYOUT REGRESSION & RESIZE SUB-TABS */
/* Ch·ª©a to√†n b·ªô style cho components: Header m·ªõi, Tabs m·ªõi, v√† c√°c th√†nh ph·∫ßn c≈© ƒë∆∞·ª£c kh√¥i ph·ª•c */

/* =========================================
   1. MODERN HEADER & TABS (NEW)
   ========================================= */

/* Header hi·ªán ƒë·∫°i cho 3 tab ch√≠nh */
.modern-page-header {
    background: linear-gradient(to right, #f0f9ff, #ffffff);
    padding: 1rem 1.5rem; /* Gi·∫£m padding d·ªçc m·ªôt ch√∫t cho g·ªçn */
    border-bottom: 1px solid #e5e7eb;
    border-radius: 0.75rem 0.75rem 0 0;
    
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    margin-bottom: 0;
}

.modern-page-header .title-wrapper {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-wrap: wrap;
}

.modern-page-header .main-icon {
    width: 2.25rem; /* Thu nh·ªè icon ch√≠nh m·ªôt ch√∫t cho c√¢n ƒë·ªëi */
    height: 2.25rem;
    color: #2563eb;
    stroke-width: 1.5;
    padding: 5px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    border: 1px solid #dbeafe;
    flex-shrink: 0;
}

.modern-page-header .page-title {
    font-size: 1.25rem; /* Gi·∫£m size ti√™u ƒë·ªÅ cho c√¢n ƒë·ªëi h∆°n (20px) */
    font-weight: 800;
    color: #1e40af;
    letter-spacing: -0.01em;
    margin: 0;
    line-height: 1.2;
    text-transform: uppercase; /* Th√™m uppercase cho m·∫°nh m·∫Ω */
}

/* === [FIX] SUB-TAB BUTTON: THU NH·ªé K√çCH TH∆Ø·ªöC === */
.sub-tab-btn {
    border-bottom: 2px solid transparent;
    padding: 0.5rem 0.75rem; /* Gi·∫£m padding ƒë·ªÉ n√∫t g·ªçn h∆°n */
    transition: all 0.2s ease-in-out;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.4rem; /* Gi·∫£m kho·∫£ng c√°ch gi·ªØa icon v√† ch·ªØ */
    color: #6b7280;
    font-weight: 600; /* TƒÉng ƒë·ªô ƒë·∫≠m m·ªôt ch√∫t ƒë·ªÉ d·ªÖ ƒë·ªçc ·ªü size nh·ªè */
    font-size: 0.8125rem; /* ~13px: Nh·ªè h∆°n ti√™u ƒë·ªÅ, c√¢n ƒë·ªëi */
    background: transparent;
    border: none;
    cursor: pointer;
    white-space: nowrap;
}

.sub-tab-btn:hover {
    color: #111827;
    background-color: #f3f4f6;
    border-radius: 4px 4px 0 0;
}

.sub-tab-btn .feather {
    width: 1rem; /* Icon nh·ªè l·∫°i (16px) */
    height: 1rem;
    stroke-width: 1.5;
    transition: color 0.2s;
}

/* Active State */
.sub-tab-btn.active {
    border-bottom: 2px solid #2563eb;
    color: #2563eb;
    background-color: #eff6ff;
}

.sub-tab-btn.active .feather {
    color: #2563eb;
    stroke-width: 2;
}

/* =========================================
   2. GENERAL COMPONENTS & TRANSITIONS
   ========================================= */

.nav-link,
.action-btn,
.kpi-card,
.content-card,
.tdv-item-card,
.data-input-group,
.toggle-filters-btn,
.page-header__help-btn,
.column-toggle-btn,
.rt-infographic-summary-card {
    transition: all 0.2s ease-in-out;
}

.nav-link:hover,
.action-btn:hover,
.kpi-card:hover,
.content-card:hover,
.data-input-group:hover,
.toggle-filters-btn:hover,
.rt-infographic-summary-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

.tdv-item-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

.page-header__help-btn {
    background-color: #fee2e2;
    color: #991b1b;
    border-radius: 9999px;
    width: 2rem;
    height: 2rem;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border: none;
    cursor: pointer;
}

.page-header__help-btn:hover {
    transform: scale(1.1) translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    background: #e5e7eb;
    border-radius: 5px;
    outline: none;
    transition: background 0.2s;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #3b82f6;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
}

input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #3b82f6;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
}

/* =========================================
   3. CARDS & LAYOUT (KH·∫ÆC PH·ª§C L·ªñI DATA SECTION)
   ========================================= */

.content-card {
    background-color: white;
    border-radius: 0.75rem;
    box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
    
    /* [FIX QUAN TR·ªåNG] Kh√¥i ph·ª•c padding m·∫∑c ƒë·ªãnh ƒë·ªÉ Tab Data kh√¥ng b·ªã d√≠nh l·ªÅ */
    padding: 1.5rem; 
    
    margin-bottom: 2rem;
    border: 1px solid #e5e7eb;
    overflow: hidden;
}

/* Class h·ªó tr·ª£ cho c√°c card s·ª≠ d·ª•ng Modern Header (ƒë·ªÉ header tr√†n vi·ªÅn) */
/* L∆∞u √Ω: C√°c file .svelte c·ªßa 3 tab kia ƒë√£ c√≥ class "!p-0", class ƒë√≥ s·∫Ω ghi ƒë√® padding tr√™n */
.content-card__body {
    padding: 1.5rem;
}

/* Header c≈© (d√πng cho DataSection - Kh√¥i ph·ª•c hi·ªÉn th·ªã ƒë√∫ng) */
.content-card__header { 
    display: flex; 
    align-items: center; 
    justify-content: flex-start;
    gap: 0.5rem;
    font-size: 1.125rem; 
    font-weight: 700; /* TƒÉng ƒë·ªô ƒë·∫≠m */
    color: #374151; 
    margin-bottom: 1rem;
    margin-top: -0.5rem; /* K√©o l√™n m·ªôt ch√∫t ƒë·ªÉ c√¢n ƒë·ªëi v·ªõi padding card */ 
    padding-bottom: 0.75rem; 
    border-bottom: 1px solid #e5e7eb; 
}

/* Notifications */
#notification { position: fixed; bottom: 20px; right: 20px; padding: 1rem 1.5rem; border-radius: 0.5rem; color: white; z-index: 1200; opacity: 0; transition: opacity 0.5s, transform 0.5s; transform: translateY(100px); }
#notification.show { opacity: 1; transform: translateY(0); }
.notification-success { background-color: #28a745; }
.notification-error { background-color: #dc3545; }

.placeholder-message { 
    border: 2px dashed #f59e0b; 
    background-color: #fffbeb; 
    color: #b45309; 
    padding: 2rem;
    border-radius: 0.75rem; 
    text-align: center; 
    font-weight: 600; 
}

[id$='-subtabs-nav'] { flex-wrap: wrap; }

/* =========================================
   4. DATA INPUT GROUPS (THEMES)
   ========================================= */

.data-input-group {
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
    padding: 1rem; /* TƒÉng padding nh·∫π cho input group */
    background-color: #ffffff; /* ƒê·ªïi n·ªÅn th√†nh tr·∫Øng cho s·∫°ch */
    display: flex;
    flex-direction: column;
    border-top: 4px solid #9ca3af;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.data-card--blue { background-color: #f0f9ff; border-color: #bae6fd; }
.data-card--green { background-color: #f0fdf4; border-color: #bbf7d0; }
.data-card--yellow { background-color: #fefce8; border-color: #fef08a; }

/* Fix m√†u header trong Data Section */
.data-header--blue { color: #0369a1; border-bottom-color: #7dd3fc; }
.data-header--green { color: #15803d; border-bottom-color: #86efac; }
.data-header--yellow { color: #854d0e; border-bottom-color: #fde047; }

.input-group--blue { border-top-color: #3b82f6; border-color: #dbeafe; }
.input-group--green { border-top-color: #22c55e; border-color: #dcfce7; }
.input-group--yellow { border-top-color: #f59e0b; border-color: #fef3c7; }

.input-group--blue .data-input-group__label { color: #1d4ed8; }
.input-group--green .data-input-group__label { color: #166534; }
.input-group--yellow .data-input-group__label { color: #92400e; }

.data-input-group__label { 
    font-weight: 700; 
    margin-bottom: 0.75rem; 
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 1rem;
}
.data-input-group__label .feather {
    width: 1.25rem;
    height: 1.25rem;
    flex-shrink: 0;
}
.data-input-group__label--link { text-decoration: none; display: inline-flex; }
.data-input-group__label--link:hover { text-decoration: underline; }
.data-input-group__label--link > .font-normal { font-weight: 400; }

.data-input-group__content { display: flex; flex-direction: column; gap: 0.5rem; flex-grow: 1; }
.data-input-group__file-trigger { cursor: pointer; background-color: #e5e7eb; color: #374151; padding: 0.5rem 1rem; border-radius: 0.375rem; font-size: 0.875em; font-weight: 600; white-space: nowrap; }
.data-input-group__file-trigger:hover { background-color: #d1d5db; }
.data-input-group__file-name { font-size: 0.875em; color: #6b7280; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-style: italic; }
.data-input-group__link { color: #2563eb; text-decoration: none; font-size: 0.875em; display: inline-flex; }
.data-input-group__link:hover { text-decoration: underline; }
.data-input-group__status-wrapper { min-height: 1rem; margin-top: 0.25rem; }
.data-input-group__status-text { font-size: 0.8rem; font-weight: 600; }
.data-input-group__status-text--default { color: #6b7280; }
.data-input-group__status-text--success { color: #16a34a; }
.data-input-group__status-text--error { color: #dc2626; }

.data-textarea { width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.875em; font-family: 'Inter', sans-serif; line-height: 1.5; }
.data-textarea:focus { outline: 2px solid transparent; outline-offset: 2px; border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); }

.progress-bar-container { overflow: hidden; height: 4px; border-radius: 2px; background-color: #e5e7eb; margin-top: 4px; }
.progress-bar { background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); background-size: 1rem 1rem; animation: progress-bar-stripes 1s linear infinite; background-color: #3b82f6; height: 100%; transition: width 0.3s; }
@keyframes progress-bar-stripes { from { background-position: 1rem 0; } to { background-position: 0 0; } }

/* =========================================
   5. INTERACTIVE TABLES
   ========================================= */

.interactive-row {
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
    cursor: pointer;
}
.interactive-row:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    background-color: #eff6ff;
}
.interactive-row .employee-name-cell {
    cursor: pointer;
    color: #2563eb;
    transition: color 0.2s ease-out;
}
.interactive-row:hover .employee-name-cell {
    text-decoration: underline;
    color: #1d4ed8;
}

.income-positive { color: #16a34a; }
.income-negative { color: #dc2626; }
.line-clamp-2 { display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }

/* =========================================
   6. KPI CARDS
   ========================================= */

.kpi-card { background-color: white; border-radius: 0.75rem; padding: 1rem; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
.kpi-card-title { color: var(--kpi-title-color); opacity: 0.9; font-size: 0.9em; font-weight: 600; text-transform: uppercase; }
.kpi-card p[id$="-main"] { color: var(--kpi-main-color); font-size: var(--kpi-main-font-size); transition: font-size 0.2s ease-in-out; }
.kpi-card p[id$="-sub"], .kpi-card p[id$="-sub1"], .kpi-card p[id$="-sub2"] { color: var(--kpi-sub-color); font-size: 0.95em; }

.kpi-percentage, .kpi-percentage-value { font-weight: 700; }
.kpi-sub-value { opacity: 0.9; }

/* KPI Card Colors */
#luyke-kpi-cards-container .kpi-card:nth-child(1), #realtime-kpi-cards-container .kpi-card:nth-child(1) { background-color: var(--kpi-card-1-bg); }
#luyke-kpi-cards-container .kpi-card:nth-child(2), #realtime-kpi-cards-container .kpi-card:nth-child(2) { background-color: var(--kpi-card-2-bg); }
#luyke-kpi-cards-container .kpi-card:nth-child(3), #realtime-kpi-cards-container .kpi-card:nth-child(3) { background-color: var(--kpi-card-3-bg); }
#luyke-kpi-cards-container .kpi-card:nth-child(4), #realtime-kpi-cards-container .kpi-card:nth-child(4) { background-color: var(--kpi-card-4-bg); }
#luyke-kpi-cards-container .kpi-card:nth-child(5) { background-color: var(--kpi-card-5-bg); }
#luyke-kpi-cards-container .kpi-card:nth-child(6) { background-color: var(--kpi-card-6-bg); }
#luyke-kpi-cards-container .kpi-card:nth-child(7) { background-color: var(--kpi-card-7-bg); }
#luyke-kpi-cards-container .kpi-card:nth-child(8) { background-color: var(--kpi-card-8-bg); }

/* =========================================
   7. BUTTONS & ACTIONS
   ========================================= */

.toggle-filters-btn { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 0.5rem; background-color: #f3f4f6; color: #4b5563; font-weight: 500; font-size: 0.875em; cursor: pointer; margin-bottom: 1rem; border: 1px solid #e5e7eb; }
.toggle-filters-btn .icon { width: 1rem; height: 1rem; transition: transform 0.3s ease-in-out; }
.toggle-filters-btn.active .icon { transform: rotate(180deg); }

.highlight-trigger { background: none; border: none; cursor: pointer; color: #6b7280; }
.highlight-trigger:hover { color: #1d4ed8; }
.highlighted-row td { animation: pulse-bg 2s infinite; }
@keyframes pulse-bg { 0% { background-color: var(--highlight-color, #ffff99); } 50% { background-color: var(--highlight-color-light, #ffffcc); } 100% { background-color: var(--highlight-color, #ffff99); } }

.action-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    font-weight: 600;
    font-size: 0.8125rem; /* ƒê·ªìng b·ªô size v·ªõi Sub-tab */
    cursor: pointer;
    border: 1px solid transparent;
    transition: all 0.2s;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}
.action-btn--composer { background-color: #ede9fe; color: #5b21b6; border-color: #c4b5fd; }
.action-btn--composer:hover { background-color: #d8b4fe; }
.action-btn--export { background-color: #dcfce7; color: #166534; border-color: #86efac; }
.action-btn--export:hover { background-color: #bbf7d0; }
.action-btn--capture { background-color: #dbeafe; color: #1e40af; border-color: #93c5fd; }
.action-btn--capture:hover { background-color: #bfdbfe; }
.action-btn--save { background-color: #16a34a; color: white; }
.action-btn--save:hover { background-color: #15803d; }
.action-btn--copy { background-color: #2563eb; color: white; }
.action-btn--copy:hover { background-color: #1d4ed8; }

/* =========================================
   8. MODALS
   ========================================= */

.modal { position: fixed; inset: 0; z-index: 1000; display: flex; align-items: center; justify-content: center; }
.modal.hidden { display: none; }
.modal__overlay { position: absolute; inset: 0; background-color: rgba(17, 24, 39, 0.6); backdrop-filter: blur(4px); cursor: pointer; }
.modal__container { position: relative; z-index: 1001; background-color: white; border-radius: 0.75rem; box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1); width: 90%; max-width: 600px; max-height: 90vh; display: flex; flex-direction: column; }

#force-update-modal .modal__overlay { cursor: not-allowed; }

.modal__container--large { max-width: 900px; }
.modal__header { padding: 1rem 1.5rem; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
.modal__title { font-size: 1.25rem; font-weight: 600; color: #1f2937; }
.modal__close-btn { font-size: 1.75rem; line-height: 1; color: #6b7280; background: none; border: none; cursor: pointer; }
.modal__close-btn:hover { color: #111827; }
.modal__content { padding: 1.5rem; overflow-y: auto; flex-grow: 1; }
.modal__content h4 { font-size: 1.125rem; font-weight: 600; color: #1e3a8a; margin-bottom: 0.75rem; }
.modal__content p { margin-bottom: 0.75rem; color: #374151; line-height: 1.6; }
.modal__content ul { list-style-type: disc; list-style-position: inside; margin-left: 0.5rem; }
.modal__content ul > * + * { margin-top: 0.5rem; }
.modal__footer { padding: 1rem 1.5rem; border-top: 1px solid #e5e7eb; background-color: #f9fafb; display: flex; justify-content: flex-end; gap: 0.75rem; flex-shrink: 0; }

#login-modal .modal__overlay { cursor: not-allowed; }
#login-modal .modal__container { box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25); }
#login-modal input[type="email"]:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); outline: none; }

/* =========================================
   9. INFOGRAPHIC & REALTIME STYLES
   ========================================= */

.view-switcher { display: flex; align-items: center; padding: 0.25rem; background-color: #e5e7eb; border-radius: 0.5rem; }
.view-switcher__btn { padding: 0.5rem 1rem; border: none; background-color: transparent; border-radius: 0.375rem; font-weight: 500; color: #4b5563; cursor: pointer; }
.view-switcher__btn.active { background-color: white; color: #3b82f6; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1); }

.infographic-card { border: 1px solid #e5e7eb; border-radius: 0.5rem; overflow: hidden; }
.infographic-card__header { padding: 0.75rem 1rem; font-weight: 700; }
.infographic-card__header--completed { background-color: #dcfce7; color: #166534; }
.infographic-card__header--pending { background-color: #fee2e2; color: #991b1b; }
.infographic-card__body { padding: 1rem; background-color: #f9fafb; }
.infographic-card__item { border-bottom: 1px dashed #d1d5db; padding: 0.75rem 0; }
.infographic-card__item:last-child { border-bottom: none; }
.infographic-card__title { font-weight: 600; color: #1f2937; margin-bottom: 0.5rem; }
.infographic-card__metrics { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0.5rem 1rem; font-size: 0.875em; }
.metric-label { color: #6b7280; }
.metric-value { font-weight: 600; color: #111827; text-align: right; }
.metric-value.is-negative { color: #ef4444; }
.metric-value.is-positive { color: #22c55e; }

/* RT Infographic */
.rt-infographic-container { background-color: #f9fafb; border-radius: 0.75rem; border: 1px solid #e5e7eb; padding: 1.5rem; }
.rt-infographic-header .employee-name { font-size: 1.5rem; font-weight: 800; color: #111827; }
.rt-infographic-header .employee-title { font-size: 1rem; font-weight: 500; color: #6b7280; }
.rt-infographic-summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-top: 1.5rem; }
.rt-infographic-summary-card { background-color: white; border-radius: 0.5rem; padding: 1rem; text-align: center; border: 1px solid #e5e7eb; }
.rt-infographic-summary-card .label { font-size: 0.875em; color: #4b5563; font-weight: 500; display: flex; align-items: center; justify-content: center; gap: 0.25rem; }
.rt-infographic-summary-card .label .feather { width: 1em; height: 1em; }
.rt-infographic-summary-card .value { font-size: 1.75rem; font-weight: 700; color: #3b82f6; margin-top: 0.25rem; }
.rt-infographic-summary-card .value.is-positive { color: #2563eb; }
.rt-infographic-summary-card .value.is-negative { color: #dc2626; }
.rt-infographic-summary-card .value.is-dat { color: #16a34a !important; }
.rt-infographic-summary-card .value.is-gan-dat { color: #f59e0b !important; }
.rt-infographic-summary-card .value.is-can-co-gang { color: #dc2626 !important; }

.rt-infographic-grid { display: grid; grid-template-columns: repeat(1, minmax(0, 1fr)); gap: 1.5rem; margin-top: 1.5rem; }
@media (min-width: 1024px) { .rt-infographic-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
.rt-infographic-section h4 { font-size: 1.125rem; font-weight: 700; color: #1f2937; margin-bottom: 1rem; }
.rt-progress-bar-item { margin-bottom: 0.75rem; }
.rt-progress-bar-label { display: flex; justify-content: space-between; font-size: 0.875em; font-weight: 500; margin-bottom: 0.25rem; }
.rt-progress-bar-container { background-color: #e5e7eb; border-radius: 9999px; height: 0.75rem; overflow: hidden; }
.rt-progress-bar { background-color: #22c55e; height: 100%; border-radius: 9999px; transition: width 0.5s ease-in-out; }

/* RT Customer Accordion */
.rt-customer-accordion { max-height: 400px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 0.5rem; }
.rt-customer-header { background-color: white; padding: 0.75rem 1rem; border-bottom: 1px solid #e5e7eb; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-weight: 600; list-style: none; }
.rt-customer-header::-webkit-details-marker { display: none; }
.rt-customer-header:hover { background-color: #f9fafb; }
.rt-customer-header .arrow { transition: transform 0.3s; }
.rt-customer-header .product-count { color: #dc2626; font-weight: bold; }
details[open] > summary .arrow { transform: rotate(180deg); }
.rt-customer-details { background-color: #f9fafb; padding: 1rem; }
.rt-customer-details table { font-size: 0.8rem; }

/* =========================================
   10. MISCELLANEOUS COMPONENTS
   ========================================= */

.preview-content { background-color: #f3f4f6; padding: 1rem; border-radius: 0.5rem; white-space: pre-wrap; word-wrap: break-word; font-size: 0.875em; line-height: 1.6; color: #1f2937; font-family: 'Inter', sans-serif; }

.header-qr-container { display: flex; flex-direction: column; align-items: center; gap: 4px; border: 2px solid #ef4444; padding: 4px; border-radius: 8px; background-color: white; }
.header-qr-container span { font-size: 0.75rem; font-weight: 600; color: #b91c1c; }
.header-qr-image { width: 50px; height: 50px; background-color: #f3f4f6; border-radius: 4px; }

.selection-item { display: flex; align-items: center; padding: 0.5rem; border-radius: 0.375rem; cursor: pointer; transition: background-color 0.2s ease-in-out; }
.selection-item:hover { background-color: #f3f4f6; }
.selection-item input[type="checkbox"] { width: 1rem; height: 1rem; margin-right: 0.75rem; }
.selection-item label { flex-grow: 1; cursor: pointer; }

.settings-trigger-btn { background: none; border: none; cursor: pointer; color: #9ca3af; transition: color 0.2s ease-in-out, transform 0.2s ease-in-out; padding: 2px; }
.settings-trigger-btn:hover { color: #3b82f6; transform: rotate(45deg); }
.settings-trigger-btn svg { width: 18px; height: 18px; display: block; }

#version-marquee-container { flex-grow: 1; margin: 0 1.5rem; overflow: hidden; position: relative; background-color: #eef2ff; border: 1px solid #c7d2fe; border-radius: 9999px; cursor: pointer; height: 38px; }
#version-marquee-container:hover .marquee-text { animation-play-state: paused; color: #312e81; }
.marquee-text { position: absolute; white-space: nowrap; will-change: transform; animation: marquee-scroll 25s linear infinite; font-weight: 600; color: #4338ca; line-height: 36px; }
@keyframes marquee-scroll { from { transform: translateX(100%); } to { transform: translateX(-100%); } }

.competition-summary-counter strong { font-size: 1.15rem !important; font-weight: 800 !important; white-space: nowrap; }
.competition-summary-counter .text-blue-600 { color: #2563eb !important; }
.competition-summary-counter .text-red-600 { color: #dc2626 !important; }

/* Column Toggle Button */
.column-toggle-btn { padding: 4px 12px; font-size: 12px; font-weight: 500; border: 1px solid; border-radius: 9999px; cursor: pointer; transition: all 0.2s ease-in-out; user-select: none; }
.column-toggle-btn.active { background-color: #3b82f6; color: white; border-color: #3b82f6; }
.column-toggle-btn:not(.active) { background-color: #e5e7eb; color: #374151; border-color: #d1d5db; }
.column-toggle-btn:not(.active):hover { background-color: #d1d5db; }
.column-toggle-btn.draggable-tag { cursor: grab; }
.column-toggle-btn.draggable-tag:active { cursor: grabbing; }
.column-toggle-btn.draggable-tag:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
.drag-handle-icon { color: #6b7280; transition: color 0.2s ease-in-out; cursor: grab; }
.drag-handle-icon:active { cursor: grabbing; }
.column-toggle-btn.draggable-tag:hover .drag-handle-icon { color: #1f2937; }

/* Draggable & Sortable */
.draggable-header { cursor: move; cursor: grab; }
.draggable-header:active { cursor: grabbing; }
.sortable-ghost { opacity: 0.4; background-color: #c7d2fe; }
.sortable-drag { opacity: 0.95; transform: rotate(-2deg); box-shadow: 0 8px 16px rgba(0,0,0,0.2); }

#sidebar .feather { width: 1.5rem; height: 1.5rem; stroke-width: 2; }
.page-header__help-btn .feather { width: 1.25rem; height: 1.25rem; }

/* LUY KE DETAIL */
.luyke-detail-header h3 { font-size: 1.75rem; font-weight: 800; color: #111827; text-align: center; }
.luyke-detail-progress-item { display: flex; flex-direction: column; gap: 4px; }
.luyke-detail-progress-label { display: flex; justify-content: space-between; align-items: baseline; font-size: 0.875rem; }
.luyke-detail-progress-values { display: flex; justify-content: space-between; font-size: 0.75rem; color: #4b5563; }
.luyke-detail-chart-container { position: relative; height: 350px; width: 100%; }

/* CUSTOMER ACCORDION (LUYKE) */
.customer-accordion-luyke summary { display: flex; flex-wrap: wrap; align-items: center; gap: 1rem; padding: 0.5rem 1rem; cursor: pointer; list-style: none; font-weight: 400; color: #4b5563; }
.customer-accordion-luyke summary:hover { background-color: #f9fafb; }
.customer-accordion-luyke .customer-name-small { font-weight: 500; font-size: 0.9rem; color: #2563eb; flex-grow: 1; min-width: 120px; }
.customer-accordion-luyke .order-metrics { display: flex; align-items: center; gap: 1rem; flex-shrink: 0; font-size: 0.75rem; }
.customer-accordion-luyke .order-metrics span { white-space: nowrap; }
.customer-accordion-luyke .order-metrics strong { font-weight: 500; color: #1f2937; }
.customer-accordion-luyke .order-metrics .text-gray-900 { color: #1f2937 !important; }
.customer-accordion-luyke .order-metrics .text-blue-600 { color: #2563eb !important; }
.customer-accordion-luyke .accordion-arrow { margin-left: auto; color: #9ca3af; transition: transform 0.2s ease-in-out; }
.customer-accordion-luyke details[open] > summary .accordion-arrow { transform: rotate(180deg); }
.customer-accordion-luyke .product-list-scrollable { display: block; max-height: 200px; overflow-y: auto; }
.customer-accordion-luyke .product-list-table { width: 100%; }
.customer-accordion-luyke .qd-below-target { color: #b91c1c; }
.customer-accordion-luyke .qd-above-target { color: #1d4ed8; }

/* CAPTURE PRESETS */
.capture-container.preset-mobile-portrait .preset-mobile-capture-area { box-sizing: border-box; }
.capture-container.preset-mobile-portrait #customer-detail-list-container,
.capture-container.preset-mobile-portrait #unexported-detail-list-container { width: 100% !important; max-width: 100% !important; box-sizing: border-box; }
<<< FILE_END: src/styles/components.css

>>> FILE_START: src/styles/dashboard-luyke.css
/* src/styles/dashboard-luyke.css */
/* Version 3.3 - Add CSS Variables support for KPI Cards */

/* =========================================
   1. LAYOUT & SCROLLING
   ========================================= */
.luyke-dashboard-container {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
}

.luyke-tier-1-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1.5rem;
    height: auto;
}

@media (min-width: 1024px) {
    .luyke-tier-1-grid {
        grid-template-columns: repeat(2, 1fr);
        height: 480px;
    }
}

.luyke-widget {
    background-color: #ffffff;
    border: 1px solid #e5e7eb;
    border-radius: 0.75rem;
    box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.05);
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
}

.luyke-widget-body {
    padding: 0.75rem;
    flex-grow: 1;
    overflow-y: auto;
    min-height: 0;
}

.luyke-widget-header {
    padding: 0.75rem 1rem;
    border-bottom: 1px solid #f3f4f6;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #ffffff;
    flex-shrink: 0;
}

.luyke-widget-title {
    font-size: 0.95rem;
    font-weight: 700;
    color: #374151;
    text-transform: uppercase;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* =========================================
   2. KPI CARDS (SOLID STYLE - CSS VARIABLES)
   ========================================= */
.kpi-grid-fixed {
    display: grid;
    grid-template-columns: repeat(1, 1fr);
    gap: 1rem;
}
@media (min-width: 768px) { .kpi-grid-fixed { grid-template-columns: repeat(2, 1fr); } }
@media (min-width: 1280px) { .kpi-grid-fixed { grid-template-columns: repeat(4, 1fr); } }

.kpi-card-solid {
    border-radius: 1rem;
    padding: 1.25rem;
    color: white;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s; /* Th√™m transition bg */
    min-height: 140px;
    position: relative;
    overflow: hidden;
}

/* [M·ªöI] Mapping bi·∫øn CSS cho c√°c th·∫ª KPI */
.kpi-card-solid.card-1 { background-color: var(--kpi-card-1-bg, #38bdf8); }
.kpi-card-solid.card-2 { background-color: var(--kpi-card-2-bg, #34d399); }
.kpi-card-solid.card-3 { background-color: var(--kpi-card-3-bg, #fbbf24); }
.kpi-card-solid.card-4 { background-color: var(--kpi-card-4-bg, #2dd4bf); }
.kpi-card-solid.card-5 { background-color: var(--kpi-card-5-bg, #a78bfa); }
.kpi-card-solid.card-6 { background-color: var(--kpi-card-6-bg, #f472b6); }
.kpi-card-solid.card-7 { background-color: var(--kpi-card-7-bg, #818cf8); }
.kpi-card-solid.card-8 { background-color: var(--kpi-card-8-bg, #f87171); }

.kpi-card-solid:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
}

.kpi-bg-icon {
    position: absolute;
    right: -10px;
    bottom: -10px;
    opacity: 0.15;
    transform: rotate(-15deg);
    pointer-events: none;
}
.kpi-bg-icon svg { width: 5rem; height: 5rem; }

.kpi-solid-header {
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    opacity: 0.9;
    margin-bottom: 0.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: var(--kpi-title-color, #ffffff); /* D√πng bi·∫øn */
}

.kpi-solid-value {
    font-size: var(--kpi-main-font-size, 2rem); /* D√πng bi·∫øn */
    font-weight: 800;
    line-height: 1;
    margin-bottom: 0.75rem;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
    color: var(--kpi-main-color, #ffffff); /* D√πng bi·∫øn */
}

.kpi-solid-sub {
    font-size: 0.8rem;
    font-weight: 500;
    border-top: 1px solid rgba(255,255,255,0.3);
    padding-top: 0.5rem;
    display: flex;
    justify-content: space-between;
    color: var(--kpi-sub-color, #ffffff); /* D√πng bi·∫øn */
}

/* ... (Ph·∫ßn c√≤n l·∫°i c·ªßa file gi·ªØ nguy√™n: EFFICIENCY LIST, CATEGORY CARDS, TOOLBAR, FILTER DROPDOWN) ... */
.eff-item-compact {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 0;
    border-bottom: 1px dashed #f3f4f6;
    width: 100%;
}
.eff-item-compact:last-child { border-bottom: none; }
.eff-icon-compact {
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 0.5rem;
    background-color: #f3f4f6;
    color: #6b7280;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}
.eff-content-compact {
    flex-grow: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
}
.eff-row-top {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 4px;
    width: 100%;
}
.eff-label-text { font-size: 0.9rem; font-weight: 600; color: #374151; }
.eff-value-text { font-size: 1rem; font-weight: 800; }
.eff-row-bottom { display: flex; align-items: center; gap: 0.75rem; width: 100%; }
.eff-bar-container { flex-grow: 1; height: 8px; background-color: #e5e7eb; border-radius: 4px; overflow: hidden; }
.eff-bar-fill { height: 100%; border-radius: 4px; transition: width 0.6s ease-out; }
.eff-target-text { font-size: 0.75rem; color: #6b7280; font-weight: 500; white-space: nowrap; min-width: 65px; text-align: right; }
.luyke-cat-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 0.75rem; }
.cat-card-colorful { border-radius: 0.75rem; padding: 0.75rem; transition: all 0.2s; border: 1px solid transparent; display: flex; flex-direction: column; justify-content: space-between; min-height: 110px; }
.cat-card-colorful:hover { transform: translateY(-3px); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
.theme-blue { background-color: #eff6ff; border-color: #bfdbfe; }
.theme-blue .cat-icon-box { background-color: #dbeafe; color: #2563eb; }
.theme-blue .cat-value-text { color: #1e40af; }
.theme-green { background-color: #ecfdf5; border-color: #a7f3d0; }
.theme-green .cat-icon-box { background-color: #d1fae5; color: #059669; }
.theme-green .cat-value-text { color: #065f46; }
.theme-orange { background-color: #fff7ed; border-color: #fed7aa; }
.theme-orange .cat-icon-box { background-color: #ffedd5; color: #ea580c; }
.theme-orange .cat-value-text { color: #9a3412; }
.theme-purple { background-color: #f5f3ff; border-color: #ddd6fe; }
.theme-purple .cat-icon-box { background-color: #ede9fe; color: #7c3aed; }
.theme-purple .cat-value-text { color: #5b21b6; }
.theme-teal { background-color: #f0fdfa; border-color: #99f6e4; }
.theme-teal .cat-icon-box { background-color: #ccfbf1; color: #0f766e; }
.theme-teal .cat-value-text { color: #115e59; }
.theme-gray { background-color: #f9fafb; border-color: #e5e7eb; }
.theme-gray .cat-icon-box { background-color: #f3f4f6; color: #4b5563; }
.theme-gray .cat-value-text { color: #1f2937; }
.theme-warning { background-color: #fffbeb; border-color: #fde047; background-image: repeating-linear-gradient(45deg, #fffbeb, #fffbeb 10px, #fef3c7 10px, #fef3c7 20px); }
.theme-warning .cat-icon-box { background-color: #fff7ed; color: #d97706; }
.theme-warning .cat-value-text { color: #b45309; }
.cat-top-row { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem; }
.cat-icon-box { width: 2rem; height: 2rem; border-radius: 0.5rem; display: flex; align-items: center; justify-content: center; }
.cat-name-text { font-size: 0.85rem; font-weight: 700; color: #374151; margin-bottom: 0.25rem; line-height: 1.2; min-height: 2.4em; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
.cat-value-text { font-size: 1.25rem; font-weight: 800; line-height: 1; margin-bottom: 0.5rem; }
.cat-footer-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.7rem; color: #6b7280; padding-top: 0.5rem; border-top: 1px solid rgba(0,0,0,0.05); }
.cat-percent-text { font-weight: 600; opacity: 0.8; }
.luyke-toolbar { background-color: #ffffff; padding: 0.5rem 1rem; border-bottom: 1px solid #e5e7eb; border-radius: 0.75rem 0.75rem 0 0; display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 1rem; }
.luyke-toolbar + .luyke-cat-grid, .luyke-toolbar + .luyke-charts-container { background-color: white; padding: 1rem; border: 1px solid #e5e7eb; border-top: none; border-radius: 0 0 0.75rem 0.75rem; }
.toggle-wrapper { display: inline-flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; padding: 6px 12px; border-radius: 999px; background-color: #f3f4f6; border: 1px solid #e5e7eb; transition: all 0.2s; }
.toggle-wrapper:hover { background-color: #e5e7eb; }
.toggle-wrapper.active { background-color: #fff7ed; border-color: #fdba74; }
.toggle-switch { position: relative; width: 36px; height: 20px; background-color: #d1d5db; border-radius: 9999px; transition: background-color 0.3s; flex-shrink: 0; }
.toggle-switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background-color: white; border-radius: 50%; transition: transform 0.3s; box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
.toggle-wrapper.active .toggle-switch { background-color: #f97316; }
.toggle-wrapper.active .toggle-switch::after { transform: translateX(16px); }
.toggle-label { font-size: 0.8rem; font-weight: 600; color: #4b5563; }
.toggle-wrapper.active .toggle-label { color: #c2410c; }
.view-mode-btn { display: inline-flex; align-items: center; gap: 4px; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; font-weight: 600; color: #6b7280; background-color: transparent; border: 1px solid transparent; transition: all 0.2s; }
.view-mode-btn:hover { background-color: #f3f4f6; }
.view-mode-btn.active { background-color: #eff6ff; color: #2563eb; border-color: #bfdbfe; }
.luyke-charts-container { display: grid; grid-template-columns: 1fr; gap: 1.5rem; }
@media (min-width: 1024px) { .luyke-charts-container { grid-template-columns: 4fr 6fr; } }
.chart-box { display: flex; flex-direction: column; height: 350px; position: relative; }
.filter-dropdown { position: absolute; top: 100%; right: 0; margin-top: 0.5rem; width: 280px; background-color: white; border: 1px solid #e5e7eb; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); z-index: 50; display: flex; flex-direction: column; max-height: 400px; }
.filter-header { padding: 0.75rem; border-bottom: 1px solid #f3f4f6; background-color: #f9fafb; border-radius: 0.5rem 0.5rem 0 0; }
.filter-search { width: 100%; padding: 0.5rem; font-size: 0.85rem; border: 1px solid #d1d5db; border-radius: 0.375rem; outline: none; }
.filter-search:focus { border-color: #3b82f6; }
.filter-body { overflow-y: auto; padding: 0.5rem; }
.filter-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; cursor: pointer; border-radius: 0.25rem; transition: background-color 0.1s; }
.filter-item:hover { background-color: #f3f4f6; }
.filter-item input[type="checkbox"] { width: 1rem; height: 1rem; border-radius: 0.25rem; cursor: pointer; accent-color: #3b82f6; }
.filter-item label { flex-grow: 1; font-size: 0.85rem; color: #374151; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.filter-actions { padding: 0.5rem; border-top: 1px solid #f3f4f6; display: flex; justify-content: space-between; background-color: #f9fafb; border-radius: 0 0 0.5rem 0.5rem; }
.filter-btn-link { font-size: 0.75rem; color: #2563eb; background: none; border: none; cursor: pointer; font-weight: 600; }
.filter-btn-link:hover { text-decoration: underline; }
.luyke-icon-btn { padding: 0.4rem; border-radius: 0.375rem; color: #6b7280; background-color: white; border: 1px solid #d1d5db; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; }
.luyke-icon-btn:hover { color: #3b82f6; border-color: #3b82f6; background-color: #eff6ff; }
.luyke-icon-btn.active { background-color: #dbeafe; color: #1e40af; border-color: #93c5fd; }
.luyke-search-input { padding: 0.4rem 0.75rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; outline: none; transition: border-color 0.2s; width: 200px; }
.luyke-search-input:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1); }
<<< FILE_END: src/styles/dashboard-luyke.css

>>> FILE_START: src/styles/layout.css
/* Version 1.0 - Layout styles (Refactored from v6.19) */
/* Ch·ª©a c√°c ID v√† class ƒë·ªãnh h√¨nh b·ªë c·ª•c ch√≠nh: sidebar, main-content, drawers, page-header */

#sidebar { 
    width: 68px; 
    transition: width 0.3s ease-in-out; 
    overflow-x: hidden; 
}
#sidebar:hover { 
    width: 256px; 
}
#sidebar.menu-locked:hover { 
    width: 68px; 
}

#sidebar .nav-link, #sidebar button {
    white-space: nowrap;
    gap: 1rem;
    justify-content: flex-start; /* FIX: Canh l·ªÅ tr√°i cho icon v√† text */
}

.menu-text {
    transition: opacity 0.2s ease-in-out, width 0.3s ease-in-out;
    opacity: 0;
    white-space: nowrap;
    width: 0;
    overflow: hidden;
}
#sidebar:hover .menu-text {
    opacity: 1;
    transition-delay: 0.1s;
    width: auto;
}
#sidebar.menu-locked:hover .menu-text {
    opacity: 0;
    width: 0;
}

/* === START: S·ª¨A L·ªñI (v6.14) === */
#main-content { 
    transition: margin-left 0.3s ease-in-out; 
    margin-left: 68px; 
    min-width: 0; /* NgƒÉn flex item co gi√£n theo n·ªôi dung con (c√°i b·∫£ng r·ªông) */
}
/* === END: S·ª¨A L·ªñI (v6.14) === */

.settings-drawer { 
    width: 400px; 
    max-width: 90vw; 
    transform: translateX(-100%); 
    transition: transform 0.3s ease-in-out; 
}
.settings-drawer.open { 
    transform: translateX(0); 
}
.close-drawer-btn { 
    font-size: 2rem; 
    line-height: 1; 
}

.page-header { 
    display: flex; 
    flex-wrap: wrap; 
    justify-content: space-between; 
    align-items: center; 
    gap: 1rem; 
    margin-bottom: 1.5rem; 
}
.page-header__title { 
    font-size: 1.75rem; 
    font-weight: 700; 
    color: #1f2937; 
}
<<< FILE_END: src/styles/layout.css

>>> FILE_START: src/styles/specific-composer.css
/* Version 1.0 - Specific: Composer (Refactored from v6.19) */
/* Ch·ª©a c√°c style CH·ªà d√†nh ri√™ng cho modal Tr√¨nh t·∫°o Nh·∫≠n x√©t & Xem tr∆∞·ªõc */

.composer { 
    display: flex; 
    flex-direction: column; 
    gap: 1.5rem; 
}
.composer__editor { 
    flex-grow: 1; 
}
.composer__tags { 
    width: 100%; 
}
.composer__label { 
    display: block; 
    font-weight: 500; 
    color: #374151; 
    margin-bottom: 0.5rem; 
}
.composer__textarea { 
    width: 100%; 
    border: 1px solid #d1d5db; 
    border-radius: 0.5rem; 
    padding: 0.75rem; 
    font-size: 0.875em; 
    resize: vertical; 
}
.composer__textarea:focus { 
    border-color: #3b82f6; 
    box-shadow: 0 0 0 1px #3b82f6; 
    outline: none; 
}
.composer__nav { 
    display: flex; 
    border-bottom: 1px solid #e5e7eb; 
    margin-bottom: 1rem; 
}
.composer__tab-btn { 
    padding: 0.5rem 1rem; 
    border: none; 
    background-color: transparent; 
    cursor: pointer; 
    font-weight: 500; 
    color: #6b7280; 
    border-bottom: 2px solid transparent; 
    margin-bottom: -1px; 
    font-size: 0.875em; 
}
.composer__tab-btn.active { 
    color: #3b82f6; 
    border-bottom-color: #3b82f6; 
}
.composer__tab-pane {
    display: none; 
}
.composer__tab-pane.active { 
    display: block; 
}
.composer__tag-group { 
    margin-bottom: 1rem; 
}
.composer__tag-group:last-child { 
    margin-bottom: 0; 
}
.composer__tag-group-title { 
    font-weight: 600; 
    font-size: 0.875em; 
    color: #4b5563; 
    margin-bottom: 0.75rem; 
    border-bottom: 1px solid #e5e7eb; 
    padding-bottom: 0.5rem; 
}
.composer__tag-btn { 
    background-color: #e0e7ff; 
    color: #3730a3; 
    border: 1px solid #c7d2fe; 
    border-radius: 9999px; 
    padding: 0.25rem 0.75rem; 
    font-size: 0.8rem; 
    font-weight: 500; 
    cursor: pointer; 
    margin: 0.25rem; 
}
.composer__icon-btn { 
    background-color: #f3f4f6; 
    color: #1f2937; 
    border: 1px solid #d1d5db; 
    border-radius: 9999px; 
    padding: 0.25rem 0.75rem; 
    font-size: 1.1rem; 
    font-weight: 500; 
    cursor: pointer; 
    margin: 0.25rem; 
    line-height: 1; 
}
.composer__filter-group { 
    margin-bottom: 1rem;
    padding-bottom: 1rem; 
    border-bottom: 1px solid #e5e7eb; 
}
.composer__select { 
    width: 100%; 
    padding: 0.5rem; 
    border: 1px solid #d1d5db; 
    border-radius: 0.375rem; 
    background-color: white; 
}
@media (min-width: 768px) { 
    .composer { 
        flex-direction: row; 
    } 
    .composer__tags { 
        width: 350px; 
        flex-shrink: 0; 
        border-left: 1px solid #e5e7eb; 
        padding-left: 1.5rem; 
    } 
}

.preview-content { 
    background-color: #f3f4f6; 
    padding: 1rem; 
    border-radius: 0.5rem; 
    white-space: pre-wrap; 
    word-wrap: break-word; 
    font-size: 0.875em; 
    line-height: 1.6; 
    color: #1f2937; 
    font-family: 'Inter', sans-serif; 
}
<<< FILE_END: src/styles/specific-composer.css

>>> FILE_START: src/styles/specific-realtime.css
/* Version 1.0 - Specific: Realtime (Refactored from v6.19) */
/* Ch·ª©a c√°c style CH·ªà d√†nh ri√™ng cho tab Realtime */

#video-container iframe {
    aspect-ratio: 16 / 9;
    width: 100%;
    height: auto;
    border-radius: 0.5rem;
}

.rt-customer-details table { 
    font-size: 0.8rem; 
}
<<< FILE_END: src/styles/specific-realtime.css

>>> FILE_START: src/styles/specific-sknv.css
/* Version 1.8 - No changes for this refactor
/* Version 1.7 - (YC 1) Change competition detail employee name color to dark green
/* Version 1.6 - Adjust detail view layout, colors, and KPI styling
/* Version 1.5 - Add standard 'line-clamp' property for compatibility
/* Version 1.4 - Implement "Multi-lane" layout & fix text wrap for competition detail
/* Version 1.3 - Add 3-column infographic styles and fix capture scroll
/* Version 1.2 - Fix drag-drop cursor for pasted competition toggles
/* Version 1.1 - Add sticky column styles for pasted competition table */
/* Ch·ª©a c√°c style CH·ªà d√†nh ri√™ng cho tab S·ª©c Kh·ªèe Nh√¢n Vi√™n (SKNV) */

#sknv-details-container .sknv-subtable-header th { 
    font-size: 0.875em; 
    font-weight: 600; 
    background-color: #f3f4f6; 
}

/* === START: SKNV INFOGRAPHIC CARD STYLES (V6.0) === */
.sknv-summary-grid {
    display: grid;
    grid-template-columns: 1fr; /* Default to 1 column for mobile */
    gap: 1.5rem;
}

@media (min-width: 768px) { /* 2 columns for tablets */
    .sknv-summary-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (min-width: 1280px) { /* 4 columns for large desktops */
    .sknv-summary-grid {
        grid-template-columns: repeat(4, 1fr);
    }
}

.sknv-card {
    background-color: #ffffff;
    border: 1px solid #e5e7eb;
    border-radius: 0.75rem;
    padding: 1rem; /* UPDATED: Compact padding */
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* UPDATED: Softer shadow */
    display: flex;
    flex-direction: column;
    gap: 0.75rem; /* UPDATED: Reduced gap */
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
    cursor: pointer;
    position: relative; /* Added for medal positioning */
}
.sknv-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.08), 0 4px 6px -2px rgba(0, 0, 0, 0.04);
}

.sknv-card__header {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.sknv-card__avatar {
    width: 48px;
    height: 48px;
    border-radius: 9999px;
    background-color: #eef2ff;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    /* (v6.18) Th√™m position relative ƒë·ªÉ canh s·ªë Top 3 */
    position: relative;
}

.sknv-card__avatar svg {
    width: 24px;
    height: 24px;
    color: #4338ca;
}

.sknv-card__info {
    flex-grow: 1;
    min-width: 0;
}
.sknv-card__info .name {
    font-weight: 700;
    color: #111827;
    line-height: 1.25;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
}

.sknv-card__info .id {
    font-size: 0.875rem;
    color: #6b7280;
}

.sknv-card__main-kpi {
    text-align: center;
    margin: 0.25rem 0; /* UPDATED: Reduced margin */
}

.sknv-card__main-kpi .value {
    font-size: 2.5rem; /* UPDATED: Reduced font size */
    font-weight: 800;
    line-height: 1;
    color: #4b5563;
}

.sknv-card__main-kpi .total {
    font-size: 1.25rem; /* UPDATED */
    font-weight: 600;
    color: #9ca3af;
}

.sknv-card__main-kpi .label {
    display: block;
    font-size: 0.875rem;
    color: #6b7280;
    margin-top: 0.25rem;
    font-weight: 500;
}

.sknv-card-kpi-strong { border-top: 4px solid #16a34a; } /* UPDATED: Added top border */
.sknv-card-kpi-medium { border-top: 4px solid #f59e0b; } /* UPDATED: Added top border */
.sknv-card-kpi-weak { border-top: 4px solid #ef4444; } /* UPDATED: Added top border */
.sknv-card-kpi-strong .value { color: #16a34a; }
.sknv-card-kpi-medium .value { color: #f59e0b; }
.sknv-card-kpi-weak .value { color: #ef4444; }

.sknv-card__sub-kpi-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.5rem; /* UPDATED: Reduced gap */
    border-top: 1px solid #f3f4f6;
    padding-top: 0.75rem; /* UPDATED: Reduced padding */
}

.sknv-card__sub-kpi-item {
    background-color: #f9fafb;
    border-radius: 0.5rem;
    padding: 0.5rem; /* UPDATED: Reduced padding */
    text-align: center;
    transition: background-color 0.2s ease-in-out;
}

/* === START: NEW SUB-KPI LAYOUT === */
.sknv-card__sub-kpi-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem;
}
.sknv-card__sub-kpi-header .feather {
    width: 1rem;
    height: 1rem;
    stroke-width: 2;
    color: #6b7280;
}
.sknv-card__sub-kpi-header .label {
    font-size: 0.7rem;
    font-weight: 600;
    color: #4b5563;
}
.sknv-card__sub-kpi-item .value {
    font-size: 0.875rem;
    font-weight: 700;
    margin-top: 2px;
    display: block; /* Ensures it's on a new line */
}
/* === END: NEW SUB-KPI LAYOUT === */

.sknv-card__sub-kpi-item.strong { border-bottom: 3px solid #22c55e; }
.sknv-card__sub-kpi-item.medium { border-bottom: 3px solid #f59e0b; }
.sknv-card__sub-kpi-item.weak { border-bottom: 3px solid #ef4444; }
/* === END: SKNV INFOGRAPHIC CARD STYLES === */

/* === START: SKNV Department Grouping Styles (V6.1) === */
.sknv-department-group {
    margin-bottom: 2.5rem; /* Space between department groups */
}

.sknv-department-group:last-child {
    margin-bottom: 1rem; /* Less space for the last group */
}

.sknv-department-header {
    font-size: 1.6rem;
    font-weight: 700;
    color: #1f2937; /* Dark gray for general headers */
    padding-bottom: 0.75rem;
    margin-bottom: 1.5rem;
    border-bottom: 3px solid #d1d5db; /* Light gray border */
    position: relative;
    padding-left: 0.5rem;
    /* (v6.18) Th√™m flex ƒë·ªÉ icon canh gi·ªØa */
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* (v6.18) ƒê·ªãnh d·∫°ng cho icon (n·∫øu c√≥) */
.sknv-department-header .header-icon {
    width: 1.4rem;
    height: 1.4rem;
}

.sknv-department-header--priority {
    color: #2563eb; /* Blue for priority department */
    border-bottom-color: #3b82f6; /* Matching blue border */
    background-color: #e0f2fe; /* Light blue background */
    padding: 0.75rem 1rem;
    border-radius: 0.5rem 0.5rem 0 0;
    margin-bottom: 0; /* Remove bottom margin to connect with cards */
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

/* (v6.18) B·ªè icon FontAwesome c≈© */
.sknv-department-header--priority::before {
    content: none;
}

/* Adjust grid gap and padding for priority department to integrate better */
.sknv-department-header--priority + .sknv-summary-grid {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    margin-top: 0; /* Remove top margin */
    padding-top: 1.5rem; /* Add padding inside grid */
    border: 1px solid #c7d2fe;
    background-color: #f3f4f6; /* Slightly different background */
    padding-left: 1rem;
    padding-right: 1rem;
    padding-bottom: 1rem;
    border-top: none;
}
/* === END: SKNV Department Grouping Styles === */

/* === START: SKNV DETAIL VIEW & MEDALS (V6.4) === */
/* NEW: Wrapper for compact detail view */
#sknv-detail-capture-area {
    max-width: 1100px;
    margin: 0 auto;
}
.sknv-detail-header-card {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    padding: 1rem; /* UPDATED: Compact padding */
    background-color: #eff6ff; /* blue-50 */
    border: 1px solid #dbeafe; /* blue-200 */
    border-top: 4px solid #3b82f6; /* blue-500 */
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
}
.sknv-detail-avatar {
    width: 64px;
    height: 64px;
    border-radius: 9999px;
    background-color: #dbeafe; /* blue-200 */
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}
.sknv-detail-avatar svg {
    width: 32px;
    height: 32px;
    color: #1e40af; /* blue-800 */
}
.sknv-detail-info .name {
    color: #1e40af; /* UPDATED: Dark blue color */
}
.sknv-detail-info .department,
.sknv-detail-info .kpi-summary {
    color: #1f2937; /* dark text */
}
.sknv-detail-info .kpi-summary .font-bold {
    color: #1d4ed8; /* darker blue */
}
.sknv-detail-info .name {
    font-size: 1.5rem;
    font-weight: 800;
    line-height: 1.2;
}
.sknv-detail-info .department {
    font-size: 1rem;
    font-weight: 500;
}
.sknv-detail-info .kpi-summary {
    margin-top: 0.5rem;
    font-weight: 600;
}

.sknv-detail-card-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem; /* UPDATED: Compact padding */
    color: #ffffff;
}
.sknv-detail-card-header .header-icon {
    width: 20px;
    height: 20px;
}
.sknv-header-blue { background-color: #2563eb; }
.sknv-header-green { background-color: #16a34a; }
.sknv-header-orange { background-color: #f97316; }
.sknv-header-yellow { background-color: #ca8a04; }
.sknv-header-indigo { background-color: #4f46e5; }
.sknv-header-purple { background-color: #7e22ce; }

.sknv-detail-grid-body {
    padding: 0.75rem 1rem; /* UPDATED: Compact padding */
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* UPDATED */
    gap: 0.75rem; /* UPDATED */
}
.sknv-detail-metric-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    padding: 0.5rem; /* UPDATED: Compact padding */
    background-color: #f9fafb;
    border-radius: 0.5rem;
    border: 1px solid #f3f4f6;
    transition: all 0.2s ease-in-out;
}
.sknv-detail-metric-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
}
.sknv-detail-metric-card .label {
    font-weight: 600;
    font-size: 0.8rem; /* UPDATED */
    color: #374151;
}
.sknv-detail-metric-card .value {
    font-weight: 700; /* UPDATED */
    font-size: 1.375rem; /* UPDATED: Reduced font size */
    line-height: 1.2;
    color: #111827;
    margin: 0.25rem 0;
}
.sknv-detail-metric-card .average {
    font-size: 0.7rem; /* UPDATED */
    color: #6b7280;
    font-style: italic;
}
.sknv-detail-metric-card .evaluation-badge {
    margin-top: 0.5rem;
    font-weight: 700;
    padding: 2px 8px;
    border-radius: 9999px;
    font-size: 0.7rem; /* UPDATED */
}
.evaluation-badge.text-green-600 { background-color: #dcfce7; }
.evaluation-badge.text-yellow-600 { background-color: #fef9c3; }

.medal-container {
    position: absolute; /* Changed for positioning */
    /* (v6.19) YC: TƒÉng size + ƒëi·ªÅu ch·ªânh v·ªã tr√≠ */
    top: -10px;
    left: 10px;
    width: 48px;
    height: 48px;
    flex-shrink: 0;
}
.medal-container svg {
    width: 100%;
    height: 100%;
    display: block;
    filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3)); /* Add a nice shadow */
}

/* NEW: Compact tables in detail view */
#sknv-details-container .sknv-subtable-header {
    font-size: 0.8rem;
}
#sknv-details-container .table-bordered td,
#sknv-details-container .table-bordered th {
    padding: 0.5rem;
}
/* === END: SKNV DETAIL VIEW & MEDALS === */

/* === START: SKNV Rank Number Styles (v6.21 - Soft Blue 3D) === */

/* 1. S·ªë th·ª© t·ª± cho Top 3 (ƒê√® l√™n huy ch∆∞∆°ng) - Gi·ªØ nguy√™n */
.sknv-card__avatar-rank {
    font-size: 1.75rem; 
    font-weight: 700; 
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 12; 
    color: #ffffff; 
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

/* 2. ·∫®n n·ªÅn avatar m·∫∑c ƒë·ªãnh khi c√≥ huy ch∆∞∆°ng - Gi·ªØ nguy√™n */
.sknv-card:has(.medal-container) .sknv-card__avatar {
    background-color: transparent;
}

/* 3. [DESIGN M·ªöI] ƒê·ªãnh d·∫°ng cho V√≤ng tr√≤n h·∫°ng 4+ (Soft Blue) */
.sknv-card__avatar--standard {
    /* N·ªÅn Gradient: T·ª´ xanh nh·∫°t sang xanh ƒë·∫≠m h∆°n x√≠u ƒë·ªÉ t·∫°o kh·ªëi c·∫ßu */
    background: linear-gradient(145deg, #eff6ff, #dbeafe); 
    
    /* Vi·ªÅn: M√†u xanh d∆∞∆°ng r√µ n√©t */
    border: 2px solid #93c5fd; 
    
    /* ƒê·ªï b√≥ng: 
       - B√≥ng d∆∞·ªõi: M√†u xanh ƒë·∫≠m m·ªù ƒë·ªÉ t·∫°o ƒë·ªô n·ªïi.
       - B√≥ng tr√™n: M√†u tr·∫Øng ƒë·ªÉ t·∫°o ƒë·ªô b√≥ng s√°ng (highlight).
    */
    box-shadow: 
        3px 3px 6px rgba(37, 99, 235, 0.15), 
        -3px -3px 6px rgba(255, 255, 255, 0.8);
    
    width: 44px; /* Fix size */
    height: 44px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: 2px;
    margin-left: 2px;
}

/* 4. [DESIGN M·ªöI] ƒê·ªãnh d·∫°ng cho S·ªê h·∫°ng 4+ */
.sknv-card__avatar--standard .sknv-card__avatar-rank {
    color: #1e40af; /* M√†u ch·ªØ: Xanh d∆∞∆°ng ƒë·∫≠m (Blue 800) thay v√¨ m√†u ƒëen/x√°m */
    position: static; 
    font-size: 1.25rem;
    font-weight: 800; 
    text-shadow: none; /* B·ªè b√≥ng ch·ªØ c·ªßa Top 3 */
    font-family: 'Inter', sans-serif;
}

/* 5. B·ªè SVG c≈© */
.sknv-card__avatar-medal {
    display: none;
}
/* === END: SKNV Rank Number Styles === */

/* === START: Declaration Accordion Styles (v6.11) === */
.declaration-group {
    border-bottom: 1px solid #e5e7eb; /* gray-200 */
}
.declaration-group:last-child {
    border-bottom: none;
}
.declaration-group summary {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 0.5rem;
    cursor: pointer;
    font-size: 1.125rem; /* text-lg */
    font-weight: 700; /* font-bold */
    color: #374151; /* gray-700 */
    list-style: none; /* Hide default marker */
}
.declaration-group summary::-webkit-details-marker {
    display: none; /* Hide default marker for Chrome */
}
.declaration-group summary:hover {
    background-color: #f9fafb; /* gray-50 */
}
.declaration-group summary::after {
    content: '+';
    font-size: 1.5rem;
    font-weight: 500;
    color: #6b7280; /* gray-500 */
    transition: transform 0.2s ease-in-out;
}
.declaration-group[open] > summary::after {
    transform: rotate(45deg);
    content: '√ó';
}
.declaration-content {
    padding: 1rem 0.5rem 1.5rem 0.5rem;
}
/* === END: Declaration Accordion Styles === */

/* === START: Pasted Competition Column Toggles & Header Wrap (v6.15) === */

/* Container for the toggle buttons */
#pasted-competition-column-toggles {
    padding: 0.75rem;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.5rem 0.25rem;
    background-color: #f9fafb; /* gray-50 */
}

/* Label for the toggles */
#pasted-competition-column-toggles .non-draggable {
    font-size: 0.875rem; /* text-sm */
    font-weight: 600; /* font-semibold */
    margin-right: 0.5rem; /* mr-2 */
    color: #374151; /* gray-700 */
}

/* Styles for the table headers to allow wrapping */
#pasted-competition-report-container table th {
    white-space: normal; /* Allow text wrapping */
    vertical-align: middle;
    line-height: 1.3;
    max-width: 150px; /* Set a max-width */
    width: 120px; /* Set a base width */
}

/* Keep employee name header slightly wider and no-wrap */
#pasted-competition-report-container table th[data-sort="hoTen"] {
    white-space: nowrap;
    width: 150px;
    min-width: 150px;
}
/* === END: Pasted Competition Styles === */

/* === START: LOGIN MODAL STYLES (V6.7) === */
#login-modal .modal__overlay {
    cursor: not-allowed;
}

#login-modal .modal__container {
    box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
}

#login-modal input[type="email"]:focus {
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
    outline: none;
}
/* === END: LOGIN MODAL STYLES === */

/* === START: Sticky Columns for Pasted Competition Table (v1.1) === */

/* 1. Container: Ph·∫£i b·∫≠t 'overflow-x-auto' (ƒë√£ c√≥) v√† 'position: relative' (quan tr·ªçng) */
.sknv-pasted-competition-scroller {
    position: relative; /* B·∫Øt bu·ªôc ƒë·ªÉ z-index c·ªßa sticky ho·∫°t ƒë·ªông */
}

/* 2. C√°c √¥ ti√™u ƒë·ªÅ (th) c·∫ßn "ƒë√≥ng bƒÉng" */
#pasted-competition-report-container table th.sticky-col {
    position: -webkit-sticky; /* cho Safari */
    position: sticky;
    z-index: 2; /* Ph·∫£i cao h∆°n z-index c·ªßa c√°c √¥ (td) */
    background-color: #e5e7eb; /* gray-200 (m√†u n·ªÅn thead) - R·∫•t quan tr·ªçng */
}

/* 3. C√°c √¥ d·ªØ li·ªáu (td) c·∫ßn "ƒë√≥ng bƒÉng" */
#pasted-competition-report-container table td.sticky-col {
    position: -webkit-sticky; /* cho Safari */
    position: sticky;
    z-index: 1; /* Ph·∫£i cao h∆°n c√°c √¥ td kh√°c, nh∆∞ng th·∫•p h∆°n th */
    background-color: #ffffff; /* M√†u n·ªÅn c·ªßa d√≤ng (tr·∫Øng) */
}

/* 4. ƒê·∫£m b·∫£o d√≤ng ch·∫µn/l·∫ª c≈©ng ƒë∆∞·ª£c ghi ƒë√® m√†u n·ªÅn */
#pasted-competition-report-container table tr:nth-child(even) td.sticky-col {
    background-color: #f9fafb; /* gray-50 (m√†u d√≤ng ch·∫µn) */
}

/* 5. ƒê·ªãnh v·ªã cho t·ª´ng c·ªôt */
.sticky-col.sticky-col-1 {
    left: 0; /* C·ªôt ƒë·∫ßu ti√™n */
}

.sticky-col.sticky-col-2 {
    left: 150px; /* C·ªôt th·ª© 2 - Ph·∫£i b·∫±ng ƒë·ªô r·ªông c·ªßa c·ªôt 1 (min-width: 150px t·ª´ CSS c≈©) */
}

/* 6. (An to√†n) ƒê·∫£m b·∫£o footer c≈©ng ƒë∆∞·ª£c "ƒë√≥ng bƒÉng" */
#pasted-competition-report-container table tfoot td.sticky-col {
    background-color: hsl(210, 20%, var(--header-lightness)); /* M√†u footer */
    z-index: 3; /* N·∫±m tr√™n c·∫£ ti√™u ƒë·ªÅ v√† n·ªôi dung */
}
/* === END: Sticky Columns (v1.1) === */

/* === START: Y√äU C·∫¶U 2 (v1.2) - S·ª≠a l·ªói con tr·ªè k√©o th·∫£ === */
.column-toggle-btn {
    /* M·∫∑c ƒë·ªãnh l√† pointer ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt c√≥ th·ªÉ click b·∫≠t/t·∫Øt */
    cursor: pointer;
}

.column-toggle-btn .drag-handle-icon {
    /* Ch·ªâ ri√™ng icon k√©o m·ªõi c√≥ cursor grab */
    cursor: grab;
}

.column-toggle-btn .drag-handle-icon:active {
    /* Khi ƒëang k√©o icon */
    cursor: grabbing;
}
/* === END: Y√äU C·∫¶U 2 (v1.2) === */

/* === START: UPDATED STYLES (v1.4) - "Multi-lane" Layout & Text Wrap === */

/* Container cho m·ªói "l√†n ƒë∆∞·ªùng" (ƒê·∫°t, G·∫ßn ƒê·∫°t, C·∫ßn C·ªë G·∫Øng) */
.sknv-thidua-lane {
    display: flex;
    flex-direction: column;
}

/* Container ch·ª©a c√°c th·∫ª card, cho ph√©p x·∫øp h√†ng ngang v√† xu·ªëng d√≤ng */
.sknv-thidua-horizontal-content {
    padding: 0.75rem; /* p-3 */
    display: flex;
    flex-direction: row; /* X·∫øp h√†ng ngang */
    flex-wrap: wrap;     /* T·ª± ƒë·ªông xu·ªëng d√≤ng */
    gap: 0.75rem;        /* Kho·∫£ng c√°ch gi·ªØa c√°c th·∫ª */
}

/* Th√¥ng b√°o khi l√†n ƒë∆∞·ªùng tr·ªëng */
.sknv-thidua-horizontal-content .empty-col-msg {
    font-size: 0.875rem; /* text-sm */
    color: #6b7280; /* gray-500 */
    text-align: center;
    padding: 1rem 0;
    font-style: italic;
    width: 100%; /* Chi·∫øm to√†n b·ªô chi·ªÅu r·ªông c·ªßa l√†n ƒë∆∞·ªùng */
}

/* Th·∫ª chi ti·∫øt t·ª´ng ng√†nh h√†ng (Y√™u c·∫ßu 3 - Layout) */
.sknv-thidua-item-card {
    background-color: #ffffff; /* bg-white */
    border-radius: 0.5rem; /* rounded-lg */
    border: 1px solid #e5e7eb; /* border */
    padding: 0.75rem; /* p-3 */
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
    transition: all 0.2s ease-in-out;
    
    /* Logic x·∫øp h√†ng ngang: */
    /* === START: Y√äU C·∫¶U 3 (v1.6) === */
    flex: 1 1 180px; /* Th·∫ª c√≥ th·ªÉ co gi√£n, c∆° s·ªü l√† 180px (thay v√¨ 220px) */
    min-width: 180px; /* Chi·ªÅu r·ªông t·ªëi thi·ªÉu 180px (thay v√¨ 220px) */
    /* === END: Y√äU C·∫¶U 3 (v1.6) === */
} 
.sknv-thidua-item-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); /* shadow-md */
}

/* Ti√™u ƒë·ªÅ ng√†nh h√†ng (Y√™u c·∫ßu 1 - Text Wrap) */
.item-card-title {
    font-weight: 600; /* font-semibold */
    color: #1f2937; /* gray-800 */
    margin-bottom: 0.5rem; /* mb-2 */
    
    /* B·∫Øt ƒë·∫ßu s·ª≠a l·ªói wrap text */
    white-space: normal; /* Cho ph√©p xu·ªëng d√≤ng */
    display: -webkit-box;
    -webkit-line-clamp: 2; /* Gi·ªõi h·∫°n 2 d√≤ng */
    line-clamp: 2; /* === TH√äM M·ªöI (v1.5) - S·ª≠a l·ªói t∆∞∆°ng th√≠ch === */
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    min-height: 2.5em; /* ƒê·∫£m b·∫£o ƒë·ªß chi·ªÅu cao cho 2 d√≤ng (line-height 1.25) */
    line-height: 1.25;
    /* K·∫øt th√∫c s·ª≠a l·ªói wrap text */
}

/* C√°c style c√≤n l·∫°i c·ªßa th·∫ª ƒë∆∞·ª£c gi·ªØ nguy√™n */
.item-card-progress-bar-container {
    width: 100%;
    background-color: #e5e7eb; /* gray-200 */
    border-radius: 9999px; /* rounded-full */
    height: 0.75rem; /* h-3 */
    overflow: hidden;
    margin-bottom: 0.5rem; /* mb-2 */
}
.item-card-progress-bar {
    height: 100%;
    border-radius: 9999px;
    transition: width 0.5s ease-in-out;
}
.item-card-metrics {
    font-size: 0.75rem; /* text-xs */
    color: #4b5563; /* gray-600 */
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 0.25rem 0.5rem; /* gap-x-2 gap-y-1 */
}
.item-card-metrics strong {
    font-weight: 600;
    color: #111827; /* gray-900 */
}
.item-card-metrics .text-green-600 { color: #16a34a; }
.item-card-metrics .text-red-600 { color: #dc2626; }

/* === END: UPDATED STYLES (v1.4) === */


/* === START: S·ª¨A L·ªñI (v1.3) - CƒÉn ch·ªânh icon cho th·∫ª KPI === */
.rt-infographic-summary-card .label {
    font-size: 0.875em;
    color: #4b5563;
    font-weight: 500;
    /* Th√™m c√°c thu·ªôc t√≠nh flex ƒë·ªÉ cƒÉn ch·ªânh icon */
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem; /* 4px */
}
.rt-infographic-summary-card .label .feather {
    width: 1em;
    height: 1em;
}
/* === END: S·ª¨A L·ªñI (v1.3) === */

/* === START: Y√äU C·∫¶U 5 (v1.6) - L√†m d·ªãu m√†u header === */
.sknv-thidua-column-header {
    display: flex;
    align-items: center;
    gap: 0.5rem; /* gap-2 */
    padding: 0.75rem 1rem; /* p-3 */
    border-bottom: 1px solid; /* C·∫≠p nh·∫≠t border color b√™n d∆∞·ªõi */
} 
.sknv-thidua-column-header .feather {
    width: 1.25rem; /* h-5 w-5 */
    height: 1.25rem;
    stroke-width: 2.5;
}
.sknv-thidua-column-header h4 {
    font-size: 1.125rem; /* text-lg */
    font-weight: 700; /* font-bold */
}
.sknv-thidua-column-header.header-blue {
    background-color: #dbeafe; /* blue-100 */
    color: #1e40af; /* blue-800 */
    border-color: #bfdbfe; /* blue-200 */
} 
.sknv-thidua-column-header.header-yellow {
    background-color: #fef9c3; /* yellow-100 */
    color: #854d0e; /* yellow-800 */
    border-color: #fde68a; /* yellow-200 */
} 
.sknv-thidua-column-header.header-red {
    background-color: #fee2e2; /* red-100 */
    color: #991b1b; /* red-800 */
    border-color: #fecaca; /* red-200 */
} 
/* === END: Y√äU C·∫¶U 5 (v1.6) === */


/* === START: (v1.6) Y√™u c·∫ßu t√πy ch·ªânh cho chi ti·∫øt thi ƒëua (Y√™u c·∫ßu 1 & 4) === */

/* Y√™u c·∫ßu 1: Ghi ƒë√® header nh√¢n vi√™n (lo·∫°i b·ªè m√†u t√≠m) */
#sknv-thidua-detail-capture-area .sknv-detail-header-card {
    background-color: #ffffff !important;
    border-color: #e5e7eb !important;
    border-top-width: 4px !important;
    border-top-color: #6b7280 !important; /* gray-500 */
} 
/* === START: THAY ƒê·ªîI (v1.7) === */
#sknv-thidua-detail-capture-area .sknv-detail-header-card .name {
    color: #166534 !important; /* YC 1 (v1.7): ƒê·ªïi sang xanh l√° c√¢y ƒë·∫≠m (green-800) */
} 
/* === END: THAY ƒê·ªîI (v1.7) === */
#sknv-thidua-detail-capture-area .sknv-detail-header-card .department {
    color: #374151 !important; /* gray-700 */
} 
#sknv-thidua-detail-capture-area .sknv-detail-header-card .sknv-card__avatar {
    background-color: #e5e7eb !important; /* gray-200 */
} 
#sknv-thidua-detail-capture-area .sknv-detail-header-card .sknv-card__avatar svg {
    color: #374151 !important; /* gray-700 */
} 

/* Y√™u c·∫ßu 4: Th√™m m√†u cho c√°c th·∫ª KPI */
.rt-infographic-summary-card .value.is-dat {
    color: #16a34a !important; /* green-600 */
} 
.rt-infographic-summary-card .value.is-positive {
    color: #2563eb !important; /* blue-600 */
} 
.rt-infographic-summary-card .value.is-gan-dat {
    color: #f59e0b !important; /* amber-500 */
} 
.rt-infographic-summary-card .value.is-can-co-gang,
.rt-infographic-summary-card .value.is-negative {
    color: #dc2626 !important; /* red-600 */
} 
/* === START: SKNV Rank Number Styles (Design Soft Blue) === */

/* Top 3 Rank Style */
.sknv-card__avatar-rank {
    /* Style m·∫∑c ƒë·ªãnh cho s·ªë c·ªßa Top 3 (ƒë∆∞·ª£c override b·ªüi inline class trong MedalIcon cho m√†u tr·∫Øng) */
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

/* Rank 4+ Circle Style */
.sknv-card__avatar--standard {
    /* N·ªÅn Gradient Xanh d∆∞∆°ng ph·∫•n */
    background: linear-gradient(145deg, #eff6ff, #dbeafe) !important;
    
    /* Vi·ªÅn Xanh d∆∞∆°ng s√°ng */
    border: 2px solid #93c5fd !important;
    
    /* ƒê·ªï b√≥ng n·ªïi kh·ªëi 3D */
    box-shadow: 
        3px 3px 6px rgba(37, 99, 235, 0.15), 
        -3px -3px 6px rgba(255, 255, 255, 0.8) !important;
    
    /* K√≠ch th∆∞·ªõc */
    width: 44px;
    height: 44px;
    border-radius: 50%;
    
    /* CƒÉn gi·ªØa s·ªë */
    display: flex;
    align-items: center;
    justify-content: center;
    
    /* CƒÉn v·ªã tr√≠ so v·ªõi Card */
    margin-top: 2px;
    margin-left: 2px;
}

/* Rank 4+ Text Style */
.sknv-card__avatar--standard .sknv-card__avatar-rank {
    color: #1e40af !important; /* Xanh d∆∞∆°ng ƒë·∫≠m */
    font-size: 1.25rem;
    font-weight: 800;
    text-shadow: none; /* B·ªè b√≥ng c·ªßa Top 3 */
    font-family: 'Inter', sans-serif;
}
/* === END: SKNV Rank Number Styles === */

<<< FILE_END: src/styles/specific-sknv.css

>>> FILE_START: src/styles/specific-tdv.css
/* Version 1.0 - Specific: TDV (Refactored from v6.19) */
/* Ch·ª©a c√°c style CH·ªà d√†nh ri√™ng cho tab Thi ƒêua V√πng (TDV) */

/* === B·∫ÆT ƒê·∫¶U: B·ªê C·ª§C CHO THI ƒêUA V√ôNG & THI ƒêUA L≈®Y K·∫æ (V5.9) === */
.tdv-rows-container { 
    display: flex; 
    flex-direction: column; 
    gap: 1.5rem; 
}
#subtab-luyke-thi-dua .tdv-row-body {
    display: grid;
    grid-template-columns: 1fr; /* M·∫∑c ƒë·ªãnh 1 c·ªôt cho mobile */
    gap: 1rem;
}
@media (min-width: 768px) { /* 2 c·ªôt cho tablet tr·ªü l√™n */
    #subtab-luyke-thi-dua .tdv-row-body {
        grid-template-columns: repeat(2, 1fr);
    }
}
/* === END: B·ªê C·ª§C M·ªöI === */

.tdv-infographic-card {
    background-color: transparent;
    border: none;
    box-shadow: none;
    padding: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
.tdv-header { 
    text-align: center; 
    margin-bottom: 2rem; 
}
.tdv-supermarket-name { 
    font-size: 2em; 
    font-weight: bold; 
    color: #005f73; 
}
.tdv-total-prize-container { 
    margin-top: 0.5rem; 
    font-size: 1.5em; 
    font-weight: bold; 
}
.tdv-total-prize-label { 
    color: #6b7280; 
    font-weight: normal; 
}
.tdv-total-prize-value { 
    color: #d90429; 
    margin-left: 0.5rem; 
}

.tdv-summary-grid { 
    display: grid; 
    grid-template-columns: repeat(2, 1fr); 
    gap: 1rem; 
    margin-top: 1.5rem; 
    margin-bottom: 2rem; 
}
@media (min-width: 768px) { 
    .tdv-summary-grid { 
        grid-template-columns: repeat(5, 1fr); 
    } 
}
.tdv-summary-item { 
    background-color: #ffffff; 
    border-radius: 8px;
    padding: 1rem; 
    text-align: center; 
    box-shadow: 0 2px 4px rgba(0,0,0,0.05); 
    border: 1px solid #e5e7eb;
}
/* === START: S·ª≠a m√†u v√† font-weight cho .tdv-summary-value === */
.tdv-summary-value {
    display: block;
    font-size: 1.75em;
    font-weight: 800; /* TƒÉng ƒë·ªô ƒë·∫≠m */
    color: #005f73; /* ƒê·ªïi m√†u xanh ƒë·∫≠m h∆°n */
}
/* === END: S·ª≠a m√†u === */
.tdv-summary-label { 
    display: block; 
    font-size: 0.9em; 
    color: #4a5568; 
    margin-top: 0.25rem; 
}
/* === START: Th√™m class m√†u cho t·ª∑ l·ªá ƒë·∫°t === */
.tdv-tyledat-high { 
    color: #2563eb !important; /* blue-600 */
} 
.tdv-tyledat-low { 
    color: #dc2626 !important; /* red-600 */
} 
/* === END: Th√™m class m√†u === */

.tdv-row { 
    background-color: #fdfdfd; 
    border-radius: 8px; 
    padding: 1rem; 
    border: 1px solid #dee2e6; 
}
.tdv-row-title { 
    font-size: 1.2em; 
    font-weight: bold;
    padding-bottom: 0.75rem; 
    margin-bottom: 1rem; 
    border-bottom: 2px solid; 
    line-height: 1.3; 
}
.tdv-row-title--prize { 
    border-color: #0d6efd; 
    color: #0d6efd; 
}
.tdv-row-title--soon-prize { 
    border-color: #e9c46a; 
    color: #e9c46a; 
}
.tdv-row-title--effort { 
    border-color: #6c757d; 
    color: #6c757d; 
}
.tdv-row-subtitle { 
    font-size: 0.8em; 
    font-weight: normal; 
    color: #d90429; 
}

/* === START: S·ª≠a layout 4 c·ªôt cho Thi ƒëua v√πng (S·ª¨A L·∫†I SELECTOR) === */
/* *** FIX: Corrected CSS selector to use #subtab-luyke-thidua-vung *** */
#subtab-luyke-thidua-vung .tdv-row-body {
    display: grid;
    grid-template-columns: repeat(1, 1fr); /* 1 c·ªôt cho mobile */
    gap: 1rem;
}
@media (min-width: 768px) { /* 2 c·ªôt cho tablet */
    #subtab-luyke-thidua-vung .tdv-row-body {
        grid-template-columns: repeat(2, 1fr);
    }
}
@media (min-width: 1280px) { /* 4 c·ªôt cho desktop l·ªõn */
    #subtab-luyke-thidua-vung .tdv-row-body {
        grid-template-columns: repeat(4, 1fr);
    }
}
/* === END: S·ª≠a layout === */
.tdv-row-body--effort { 
    display: block; 
}

.tdv-item-card { 
    background: #fff; 
    border: 1px solid #e0e0e0; 
    border-radius: 6px;
    padding: 12px; 
    box-shadow: 0 1px 3px rgba(0,0,0,0.05); 
    overflow: hidden; 
}
.tdv-item-card__title { 
    font-weight: bold;
    margin: 0 0 10px 0; 
    color: #333; 
}
.tdv-progress-bar-container {
    width: 100%;
    background-color: #e9ecef;
    border-radius: 20px;
    height: 28px;
    position: relative;
    font-size: 0.85em;
    font-weight: bold;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
}
.tdv-progress-bar { 
    height: 100%; 
    transition: width 0.5s ease; 
    position: absolute; 
    top: 0; 
    left: 0; 
}
.tdv-progress-bar--blue { 
    background-color: #0d6efd; 
}
.tdv-progress-bar--yellow { 
    background-color: #e9c46a; 
}
.tdv-progress-bar__text {
    position: relative;
    z-index: 1;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
    color: white;
}
.tdv-item-card__details { 
    font-size: 0.85em; 
    color: #555; 
    margin-top: 8px; 
    display: grid; 
    grid-template-columns: repeat(3, 1fr); 
    gap: 5px; 
}
.tdv-item-card__details span { 
    display: block; 
}
.tdv-item-card__details strong { 
    color: #000; 
}
.tdv-item-card__prize { 
    grid-column: 1 / -1; 
    font-weight: bold !important; 
    color: #d90429; 
    margin-top: 4px; 
}

.tdv-effort-subgroup { 
    margin-bottom: 1rem; 
}
.tdv-effort-subgroup:last-child { 
    margin-bottom: 0; 
}
.tdv-effort-subgroup__title { 
    font-weight: bold; 
    margin: 0 0 10px 0; 
    padding-bottom: 5px; 
    border-bottom: 1px solid #dee2e6; 
}
.tdv-effort-subgroup__title--potential { 
    color: #fd7e14; 
}
.tdv-effort-subgroup__title--major { 
    color: #6c757d; 
}
.tdv-effort-list { 
    display: flex; 
    flex-wrap: wrap; 
    gap: 8px; 
}
.tdv-effort-item { 
    background-color: #f1f3f5; 
    color: #495057; 
    padding: 5px 10px; 
    border-radius: 15px; 
    font-size: 0.9em; 
}
<<< FILE_END: src/styles/specific-tdv.css

>>> FILE_START: src/styles/tables.css
/* Version 1.0 - Tables styles (Refactored from v6.19) */
/* Ch·ª©a c√°c class chung cho b·∫£ng bi·ªÉu: borders, striping, header colors, sort indicators */

.table-bordered { 
    border-collapse: collapse; 
}
.table-bordered th, .table-bordered td { 
    border: 1px solid #e5e7eb; 
}
.table-striped tbody tr:nth-child(even) { 
    background-color: #f9fafb; 
}
.table-footer { 
    background-color: hsl(210, 20%, var(--header-lightness));
    border-top: 2px solid #9ca3af; 
}
.cell-performance.is-below { 
    background-color: hsl(0, 80%, var(--below-target-lightness)) !important; 
}

/* === Sort Indicators === */
.sortable { 
    cursor: pointer; 
    position: relative; 
    user-select: none; 
}
.sort-indicator { 
    display: inline-flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    width: 1em; 
    height: 1em; 
    margin-left: 4px; 
    vertical-align: middle; 
    color: #9ca3af; 
    transition: color 0.2s ease-in-out; 
}
.sortable .sort-indicator::before { 
    content: '‚ñ≤'; 
    font-size: 0.8em; 
    line-height: 0.5; 
    opacity: 0.4; 
}
.sortable .sort-indicator::after { 
    content: '‚ñº'; 
    font-size: 0.8em; 
    line-height: 0.5; 
    opacity: 0.4; 
}
.sortable:hover .sort-indicator { 
    color: #374151; 
}
.sortable.sorted-asc .sort-indicator::before { 
    opacity: 1; 
    color: #3b82f6; 
}
.sortable.sorted-asc .sort-indicator::after { 
    opacity: 0.4; 
}
.sortable.sorted-desc .sort-indicator::after { 
    opacity: 1; 
    color: #3b82f6; 
}
.sortable.sorted-desc .sort-indicator::before { 
    opacity: 0.4;
}

/* === Draggable Headers === */
.draggable-header {
    cursor: move;
    cursor: grab;
}
.draggable-header:active {
    cursor: grabbing;
}
.sortable-ghost {
    opacity: 0.4;
    background-color: #c7d2fe; /* indigo-200 */
}
.sortable-drag {
    opacity: 0.95;
    transform: rotate(-2deg);
    box-shadow: 0 8px 16px rgba(0,0,0,0.2);
}


/* === Table Header Colors === */
.header-bg-blue { background-color: hsl(217, 95%, var(--special-header-lightness)) !important; color: hsl(217, 80%, var(--header-text-lightness)) !important; }
.header-bg-green { background-color: hsl(145, 80%, var(--special-header-lightness)) !important; color: hsl(145, 70%, var(--header-text-lightness)) !important; }
.header-bg-yellow { background-color: hsl(45, 95%, var(--special-header-lightness)) !important; color: hsl(45, 80%, var(--header-text-lightness)) !important; }

.header-group-1 { background-color: hsl(30, 90%, var(--header-lightness)); }
.header-group-2 { background-color: hsl(90, 90%, var(--header-lightness)); }
.header-group-3 { background-color: hsl(180, 90%, var(--header-lightness)); }
.header-group-4 { background-color: hsl(240, 90%, var(--header-lightness)); }
.header-group-5 { background-color: hsl(300, 90%, var(--header-lightness)); }
.header-group-6 { background-color: hsl(0, 90%, var(--header-lightness)); }
.header-group-7 { background-color: hsl(160, 80%, var(--header-lightness)) !important; }
.header-group-8 { background-color: hsl(280, 80%, var(--header-lightness)) !important; }
.header-group-9 { background-color: hsl(70, 80%, var(--header-lightness)) !important; }
.header-group-10 { background-color: hsl(190, 80%, var(--header-lightness)) !important; }
.header-group-11 { background-color: hsl(340, 80%, var(--header-lightness)) !important; }
.header-group-12 { background-color: hsl(20, 80%, var(--header-lightness)) !important; }

.department-header-tv { background-color: #e0e7ff; color: #3730a3; }
.department-header-kho { background-color: #d1fae5; color: #065f46; }
.department-header-tt { background-color: #fef3c7; color: #92400e; }
.category-header-ict { background-color: #dbeafe; color: #1e40af; }
.category-header-phukien { background-color: #fee2e2; color: #991b1b; }
.category-header-giadung { background-color: #fef9c3; color: #854d0e; }
.category-header-ce { background-color: #e0f2fe; color: #0c4a6e; }
.category-header-baohiem { background-color: #f3e8ff; color: #6b21a8; }
.header-bg-indigo { background-color: #e0e7ff; color: #3730a3; }
.header-bg-purple { background-color: #f3e8ff; color: #6b21a8; }

.qdc-group-title { font-weight: 600; }
.qdc-group-ict { background-color: hsl(190, 80%, var(--special-header-lightness)); }
.qdc-group-vas { background-color: hsl(140, 80%, var(--special-header-lightness)); }
.qdc-group-giadung { background-color: hsl(0, 80%, var(--special-header-lightness)); }
.qdc-group-sim { background-color: hsl(40, 80%, var(--special-header-lightness)); }

.competition-header-doanhthu { border-color: #a78bfa; background-color: hsl(260, 90%, var(--bg-lightness)); }
.competition-header-soluong { border-color: #facc15; background-color: hsl(50, 90%, var(--bg-lightness)); }
.header-highlight-special { background-color: hsl(25, 90%, var(--header-lightness)) !important; }
.competition-row-below-100 td { background-color: #fee2e2; color: #991b1b; }

.header-highlight { background-color: hsl(50, 95%, var(--special-header-lightness)) !important; }
<<< FILE_END: src/styles/tables.css

>>> FILE_START: src/styles/vendor.css
/* Version 1.0 - Vendor overrides (Refactored from v6.19) */
/* Ch·ª©a c√°c style ghi ƒë√® l√™n th∆∞ vi·ªán b√™n th·ª© ba, v√≠ d·ª•: Choices.js */

#dtnv-realtime-employee-selector-container .choices__inner { 
    min-width: 300px; 
}
#dtnv-realtime-employee-selector-container .choices__list--single { 
    min-width: 300px; 
}

.choices__inner { 
    min-height: 42px; 
}
.choices__list--multiple .choices__item { 
    background-color: #3b82f6; 
    border-color: #2563eb; 
}

#goal-drawer .choices__inner {
    min-width: 250px;
}

#goal-drawer .choices__list--dropdown,
#goal-drawer .choices__list[aria-expanded] {
    min-width: 100%;
    width: auto;
    word-break: normal;
}

#goal-drawer .choices__list--multiple .choices__item {
    display: inline-flex;
    align-items: center;
    background-color: #3b82f6;
    border: 1px solid #2563eb;
    color: white;
    border-radius: 9999px;
    padding: 2px 8px;
    font-size: 0.8em;
    font-weight: 500;
    margin: 2px 4px 2px 0;
}
#goal-drawer .choices__inner {
    height: auto !important;
    min-height: 42px !important;
    display: flex !important;
    flex-wrap: wrap !important;
}
<<< FILE_END: src/styles/vendor.css
